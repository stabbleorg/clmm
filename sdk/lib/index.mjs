var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/generated/index.ts
var generated_exports = {};
__export(generated_exports, {
  AMM_CONFIG_DISCRIMINATOR: () => AMM_CONFIG_DISCRIMINATOR,
  AMM_V3_ERROR__ACCOUNT_LACK: () => AMM_V3_ERROR__ACCOUNT_LACK,
  AMM_V3_ERROR__CALCULATE_OVERFLOW: () => AMM_V3_ERROR__CALCULATE_OVERFLOW,
  AMM_V3_ERROR__CLOSE_POSITION_ERR: () => AMM_V3_ERROR__CLOSE_POSITION_ERR,
  AMM_V3_ERROR__EXCEPT_REWARD_MINT: () => AMM_V3_ERROR__EXCEPT_REWARD_MINT,
  AMM_V3_ERROR__FORBID_BOTH_ZERO_FOR_SUPPLY_LIQUIDITY: () => AMM_V3_ERROR__FORBID_BOTH_ZERO_FOR_SUPPLY_LIQUIDITY,
  AMM_V3_ERROR__FULL_REWARD_INFO: () => AMM_V3_ERROR__FULL_REWARD_INFO,
  AMM_V3_ERROR__INSUFFICIENT_LIQUIDITY_FOR_DIRECTION: () => AMM_V3_ERROR__INSUFFICIENT_LIQUIDITY_FOR_DIRECTION,
  AMM_V3_ERROR__INVALID_FIRST_TICK_ARRAY_ACCOUNT: () => AMM_V3_ERROR__INVALID_FIRST_TICK_ARRAY_ACCOUNT,
  AMM_V3_ERROR__INVALID_INPUT_POOL_VAULT: () => AMM_V3_ERROR__INVALID_INPUT_POOL_VAULT,
  AMM_V3_ERROR__INVALID_LIQUIDITY: () => AMM_V3_ERROR__INVALID_LIQUIDITY,
  AMM_V3_ERROR__INVALID_REWARD_DESIRED_AMOUNT: () => AMM_V3_ERROR__INVALID_REWARD_DESIRED_AMOUNT,
  AMM_V3_ERROR__INVALID_REWARD_INDEX: () => AMM_V3_ERROR__INVALID_REWARD_INDEX,
  AMM_V3_ERROR__INVALID_REWARD_INIT_PARAM: () => AMM_V3_ERROR__INVALID_REWARD_INIT_PARAM,
  AMM_V3_ERROR__INVALID_REWARD_INPUT_ACCOUNT_NUMBER: () => AMM_V3_ERROR__INVALID_REWARD_INPUT_ACCOUNT_NUMBER,
  AMM_V3_ERROR__INVALID_REWARD_PERIOD: () => AMM_V3_ERROR__INVALID_REWARD_PERIOD,
  AMM_V3_ERROR__INVALID_TICK_ARRAY: () => AMM_V3_ERROR__INVALID_TICK_ARRAY,
  AMM_V3_ERROR__INVALID_TICK_ARRAY_BOUNDARY: () => AMM_V3_ERROR__INVALID_TICK_ARRAY_BOUNDARY,
  AMM_V3_ERROR__INVALID_TICK_INDEX: () => AMM_V3_ERROR__INVALID_TICK_INDEX,
  AMM_V3_ERROR__INVALID_UPDATE_CONFIG_FLAG: () => AMM_V3_ERROR__INVALID_UPDATE_CONFIG_FLAG,
  AMM_V3_ERROR__LIQUIDITY_ADD_VALUE_ERR: () => AMM_V3_ERROR__LIQUIDITY_ADD_VALUE_ERR,
  AMM_V3_ERROR__LIQUIDITY_INSUFFICIENT: () => AMM_V3_ERROR__LIQUIDITY_INSUFFICIENT,
  AMM_V3_ERROR__LIQUIDITY_SUB_VALUE_ERR: () => AMM_V3_ERROR__LIQUIDITY_SUB_VALUE_ERR,
  AMM_V3_ERROR__L_O_K: () => AMM_V3_ERROR__L_O_K,
  AMM_V3_ERROR__MAX_TOKEN_OVERFLOW: () => AMM_V3_ERROR__MAX_TOKEN_OVERFLOW,
  AMM_V3_ERROR__MISSING_TICK_ARRAY_BITMAP_EXTENSION_ACCOUNT: () => AMM_V3_ERROR__MISSING_TICK_ARRAY_BITMAP_EXTENSION_ACCOUNT,
  AMM_V3_ERROR__NOT_APPROVED: () => AMM_V3_ERROR__NOT_APPROVED,
  AMM_V3_ERROR__NOT_APPROVE_UPDATE_REWARD_EMISSIONES: () => AMM_V3_ERROR__NOT_APPROVE_UPDATE_REWARD_EMISSIONES,
  AMM_V3_ERROR__NOT_ENOUGH_TICK_ARRAY_ACCOUNT: () => AMM_V3_ERROR__NOT_ENOUGH_TICK_ARRAY_ACCOUNT,
  AMM_V3_ERROR__NOT_SUPPORT_MINT: () => AMM_V3_ERROR__NOT_SUPPORT_MINT,
  AMM_V3_ERROR__PRICE_SLIPPAGE_CHECK: () => AMM_V3_ERROR__PRICE_SLIPPAGE_CHECK,
  AMM_V3_ERROR__REWARD_TOKEN_ALREADY_IN_USE: () => AMM_V3_ERROR__REWARD_TOKEN_ALREADY_IN_USE,
  AMM_V3_ERROR__SQRT_PRICE_LIMIT_OVERFLOW: () => AMM_V3_ERROR__SQRT_PRICE_LIMIT_OVERFLOW,
  AMM_V3_ERROR__SQRT_PRICE_X64: () => AMM_V3_ERROR__SQRT_PRICE_X64,
  AMM_V3_ERROR__TICK_AND_SPACING_NOT_MATCH: () => AMM_V3_ERROR__TICK_AND_SPACING_NOT_MATCH,
  AMM_V3_ERROR__TICK_INVALID_ORDER: () => AMM_V3_ERROR__TICK_INVALID_ORDER,
  AMM_V3_ERROR__TICK_LOWER_OVERFLOW: () => AMM_V3_ERROR__TICK_LOWER_OVERFLOW,
  AMM_V3_ERROR__TICK_UPPER_OVERFLOW: () => AMM_V3_ERROR__TICK_UPPER_OVERFLOW,
  AMM_V3_ERROR__TOO_LITTLE_OUTPUT_RECEIVED: () => AMM_V3_ERROR__TOO_LITTLE_OUTPUT_RECEIVED,
  AMM_V3_ERROR__TOO_MUCH_INPUT_PAID: () => AMM_V3_ERROR__TOO_MUCH_INPUT_PAID,
  AMM_V3_ERROR__TOO_SMALL_INPUT_OR_OUTPUT_AMOUNT: () => AMM_V3_ERROR__TOO_SMALL_INPUT_OR_OUTPUT_AMOUNT,
  AMM_V3_ERROR__TRANSACTION_TOO_OLD: () => AMM_V3_ERROR__TRANSACTION_TOO_OLD,
  AMM_V3_ERROR__TRANSFER_FEE_CALCULATE_NOT_MATCH: () => AMM_V3_ERROR__TRANSFER_FEE_CALCULATE_NOT_MATCH,
  AMM_V3_ERROR__UN_INITIALIZED_REWARD_INFO: () => AMM_V3_ERROR__UN_INITIALIZED_REWARD_INFO,
  AMM_V3_ERROR__ZERO_AMOUNT_SPECIFIED: () => AMM_V3_ERROR__ZERO_AMOUNT_SPECIFIED,
  AMM_V3_ERROR__ZERO_MINT_AMOUNT: () => AMM_V3_ERROR__ZERO_MINT_AMOUNT,
  AMM_V3_PROGRAM_ADDRESS: () => AMM_V3_PROGRAM_ADDRESS,
  AmmV3Account: () => AmmV3Account,
  AmmV3Instruction: () => AmmV3Instruction,
  CLOSE_POSITION_DISCRIMINATOR: () => CLOSE_POSITION_DISCRIMINATOR,
  CLOSE_PROTOCOL_POSITION_DISCRIMINATOR: () => CLOSE_PROTOCOL_POSITION_DISCRIMINATOR,
  COLLECT_FUND_FEE_DISCRIMINATOR: () => COLLECT_FUND_FEE_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEE_DISCRIMINATOR: () => COLLECT_PROTOCOL_FEE_DISCRIMINATOR,
  COLLECT_REMAINING_REWARDS_DISCRIMINATOR: () => COLLECT_REMAINING_REWARDS_DISCRIMINATOR,
  CREATE_AMM_CONFIG_DISCRIMINATOR: () => CREATE_AMM_CONFIG_DISCRIMINATOR,
  CREATE_OPERATION_ACCOUNT_DISCRIMINATOR: () => CREATE_OPERATION_ACCOUNT_DISCRIMINATOR,
  CREATE_POOL_DISCRIMINATOR: () => CREATE_POOL_DISCRIMINATOR,
  CREATE_SUPPORT_MINT_ASSOCIATED_DISCRIMINATOR: () => CREATE_SUPPORT_MINT_ASSOCIATED_DISCRIMINATOR,
  DECREASE_LIQUIDITY_DISCRIMINATOR: () => DECREASE_LIQUIDITY_DISCRIMINATOR,
  DECREASE_LIQUIDITY_V2_DISCRIMINATOR: () => DECREASE_LIQUIDITY_V2_DISCRIMINATOR,
  INCREASE_LIQUIDITY_DISCRIMINATOR: () => INCREASE_LIQUIDITY_DISCRIMINATOR,
  INCREASE_LIQUIDITY_V2_DISCRIMINATOR: () => INCREASE_LIQUIDITY_V2_DISCRIMINATOR,
  INITIALIZE_REWARD_DISCRIMINATOR: () => INITIALIZE_REWARD_DISCRIMINATOR,
  OBSERVATION_STATE_DISCRIMINATOR: () => OBSERVATION_STATE_DISCRIMINATOR,
  OPEN_POSITION_DISCRIMINATOR: () => OPEN_POSITION_DISCRIMINATOR,
  OPEN_POSITION_V2_DISCRIMINATOR: () => OPEN_POSITION_V2_DISCRIMINATOR,
  OPEN_POSITION_WITH_TOKEN22_NFT_DISCRIMINATOR: () => OPEN_POSITION_WITH_TOKEN22_NFT_DISCRIMINATOR,
  OPERATION_STATE_DISCRIMINATOR: () => OPERATION_STATE_DISCRIMINATOR,
  PERSONAL_POSITION_STATE_DISCRIMINATOR: () => PERSONAL_POSITION_STATE_DISCRIMINATOR,
  POOL_STATE_DISCRIMINATOR: () => POOL_STATE_DISCRIMINATOR,
  PROTOCOL_POSITION_STATE_DISCRIMINATOR: () => PROTOCOL_POSITION_STATE_DISCRIMINATOR,
  SET_REWARD_PARAMS_DISCRIMINATOR: () => SET_REWARD_PARAMS_DISCRIMINATOR,
  SUPPORT_MINT_ASSOCIATED_DISCRIMINATOR: () => SUPPORT_MINT_ASSOCIATED_DISCRIMINATOR,
  SWAP_DISCRIMINATOR: () => SWAP_DISCRIMINATOR,
  SWAP_ROUTER_BASE_IN_DISCRIMINATOR: () => SWAP_ROUTER_BASE_IN_DISCRIMINATOR,
  SWAP_V2_DISCRIMINATOR: () => SWAP_V2_DISCRIMINATOR,
  TICK_ARRAY_BITMAP_EXTENSION_DISCRIMINATOR: () => TICK_ARRAY_BITMAP_EXTENSION_DISCRIMINATOR,
  TICK_ARRAY_STATE_DISCRIMINATOR: () => TICK_ARRAY_STATE_DISCRIMINATOR,
  TRANSFER_REWARD_OWNER_DISCRIMINATOR: () => TRANSFER_REWARD_OWNER_DISCRIMINATOR,
  UPDATE_AMM_CONFIG_DISCRIMINATOR: () => UPDATE_AMM_CONFIG_DISCRIMINATOR,
  UPDATE_OPERATION_ACCOUNT_DISCRIMINATOR: () => UPDATE_OPERATION_ACCOUNT_DISCRIMINATOR,
  UPDATE_POOL_STATUS_DISCRIMINATOR: () => UPDATE_POOL_STATUS_DISCRIMINATOR,
  UPDATE_REWARD_INFOS_DISCRIMINATOR: () => UPDATE_REWARD_INFOS_DISCRIMINATOR,
  decodeAmmConfig: () => decodeAmmConfig,
  decodeObservationState: () => decodeObservationState,
  decodeOperationState: () => decodeOperationState,
  decodePersonalPositionState: () => decodePersonalPositionState,
  decodePoolState: () => decodePoolState,
  decodeProtocolPositionState: () => decodeProtocolPositionState,
  decodeSupportMintAssociated: () => decodeSupportMintAssociated,
  decodeTickArrayBitmapExtension: () => decodeTickArrayBitmapExtension,
  decodeTickArrayState: () => decodeTickArrayState,
  fetchAllAmmConfig: () => fetchAllAmmConfig,
  fetchAllMaybeAmmConfig: () => fetchAllMaybeAmmConfig,
  fetchAllMaybeObservationState: () => fetchAllMaybeObservationState,
  fetchAllMaybeOperationState: () => fetchAllMaybeOperationState,
  fetchAllMaybePersonalPositionState: () => fetchAllMaybePersonalPositionState,
  fetchAllMaybePoolState: () => fetchAllMaybePoolState,
  fetchAllMaybeProtocolPositionState: () => fetchAllMaybeProtocolPositionState,
  fetchAllMaybeSupportMintAssociated: () => fetchAllMaybeSupportMintAssociated,
  fetchAllMaybeTickArrayBitmapExtension: () => fetchAllMaybeTickArrayBitmapExtension,
  fetchAllMaybeTickArrayState: () => fetchAllMaybeTickArrayState,
  fetchAllObservationState: () => fetchAllObservationState,
  fetchAllOperationState: () => fetchAllOperationState,
  fetchAllPersonalPositionState: () => fetchAllPersonalPositionState,
  fetchAllPoolState: () => fetchAllPoolState,
  fetchAllProtocolPositionState: () => fetchAllProtocolPositionState,
  fetchAllSupportMintAssociated: () => fetchAllSupportMintAssociated,
  fetchAllTickArrayBitmapExtension: () => fetchAllTickArrayBitmapExtension,
  fetchAllTickArrayState: () => fetchAllTickArrayState,
  fetchAmmConfig: () => fetchAmmConfig,
  fetchMaybeAmmConfig: () => fetchMaybeAmmConfig,
  fetchMaybeObservationState: () => fetchMaybeObservationState,
  fetchMaybeOperationState: () => fetchMaybeOperationState,
  fetchMaybePersonalPositionState: () => fetchMaybePersonalPositionState,
  fetchMaybePoolState: () => fetchMaybePoolState,
  fetchMaybeProtocolPositionState: () => fetchMaybeProtocolPositionState,
  fetchMaybeSupportMintAssociated: () => fetchMaybeSupportMintAssociated,
  fetchMaybeTickArrayBitmapExtension: () => fetchMaybeTickArrayBitmapExtension,
  fetchMaybeTickArrayState: () => fetchMaybeTickArrayState,
  fetchObservationState: () => fetchObservationState,
  fetchOperationState: () => fetchOperationState,
  fetchPersonalPositionState: () => fetchPersonalPositionState,
  fetchPoolState: () => fetchPoolState,
  fetchProtocolPositionState: () => fetchProtocolPositionState,
  fetchSupportMintAssociated: () => fetchSupportMintAssociated,
  fetchTickArrayBitmapExtension: () => fetchTickArrayBitmapExtension,
  fetchTickArrayState: () => fetchTickArrayState,
  getAmmConfigCodec: () => getAmmConfigCodec,
  getAmmConfigDecoder: () => getAmmConfigDecoder,
  getAmmConfigDiscriminatorBytes: () => getAmmConfigDiscriminatorBytes,
  getAmmConfigEncoder: () => getAmmConfigEncoder,
  getAmmConfigSize: () => getAmmConfigSize,
  getAmmV3ErrorMessage: () => getAmmV3ErrorMessage,
  getClosePositionDiscriminatorBytes: () => getClosePositionDiscriminatorBytes,
  getClosePositionInstruction: () => getClosePositionInstruction,
  getClosePositionInstructionAsync: () => getClosePositionInstructionAsync,
  getClosePositionInstructionDataCodec: () => getClosePositionInstructionDataCodec,
  getClosePositionInstructionDataDecoder: () => getClosePositionInstructionDataDecoder,
  getClosePositionInstructionDataEncoder: () => getClosePositionInstructionDataEncoder,
  getCloseProtocolPositionDiscriminatorBytes: () => getCloseProtocolPositionDiscriminatorBytes,
  getCloseProtocolPositionInstruction: () => getCloseProtocolPositionInstruction,
  getCloseProtocolPositionInstructionDataCodec: () => getCloseProtocolPositionInstructionDataCodec,
  getCloseProtocolPositionInstructionDataDecoder: () => getCloseProtocolPositionInstructionDataDecoder,
  getCloseProtocolPositionInstructionDataEncoder: () => getCloseProtocolPositionInstructionDataEncoder,
  getCollectFundFeeDiscriminatorBytes: () => getCollectFundFeeDiscriminatorBytes,
  getCollectFundFeeInstruction: () => getCollectFundFeeInstruction,
  getCollectFundFeeInstructionDataCodec: () => getCollectFundFeeInstructionDataCodec,
  getCollectFundFeeInstructionDataDecoder: () => getCollectFundFeeInstructionDataDecoder,
  getCollectFundFeeInstructionDataEncoder: () => getCollectFundFeeInstructionDataEncoder,
  getCollectPersonalFeeEventCodec: () => getCollectPersonalFeeEventCodec,
  getCollectPersonalFeeEventDecoder: () => getCollectPersonalFeeEventDecoder,
  getCollectPersonalFeeEventEncoder: () => getCollectPersonalFeeEventEncoder,
  getCollectProtocolFeeDiscriminatorBytes: () => getCollectProtocolFeeDiscriminatorBytes,
  getCollectProtocolFeeEventCodec: () => getCollectProtocolFeeEventCodec,
  getCollectProtocolFeeEventDecoder: () => getCollectProtocolFeeEventDecoder,
  getCollectProtocolFeeEventEncoder: () => getCollectProtocolFeeEventEncoder,
  getCollectProtocolFeeInstruction: () => getCollectProtocolFeeInstruction,
  getCollectProtocolFeeInstructionDataCodec: () => getCollectProtocolFeeInstructionDataCodec,
  getCollectProtocolFeeInstructionDataDecoder: () => getCollectProtocolFeeInstructionDataDecoder,
  getCollectProtocolFeeInstructionDataEncoder: () => getCollectProtocolFeeInstructionDataEncoder,
  getCollectRemainingRewardsDiscriminatorBytes: () => getCollectRemainingRewardsDiscriminatorBytes,
  getCollectRemainingRewardsInstruction: () => getCollectRemainingRewardsInstruction,
  getCollectRemainingRewardsInstructionDataCodec: () => getCollectRemainingRewardsInstructionDataCodec,
  getCollectRemainingRewardsInstructionDataDecoder: () => getCollectRemainingRewardsInstructionDataDecoder,
  getCollectRemainingRewardsInstructionDataEncoder: () => getCollectRemainingRewardsInstructionDataEncoder,
  getConfigChangeEventCodec: () => getConfigChangeEventCodec,
  getConfigChangeEventDecoder: () => getConfigChangeEventDecoder,
  getConfigChangeEventEncoder: () => getConfigChangeEventEncoder,
  getCreateAmmConfigDiscriminatorBytes: () => getCreateAmmConfigDiscriminatorBytes,
  getCreateAmmConfigInstruction: () => getCreateAmmConfigInstruction,
  getCreateAmmConfigInstructionAsync: () => getCreateAmmConfigInstructionAsync,
  getCreateAmmConfigInstructionDataCodec: () => getCreateAmmConfigInstructionDataCodec,
  getCreateAmmConfigInstructionDataDecoder: () => getCreateAmmConfigInstructionDataDecoder,
  getCreateAmmConfigInstructionDataEncoder: () => getCreateAmmConfigInstructionDataEncoder,
  getCreateOperationAccountDiscriminatorBytes: () => getCreateOperationAccountDiscriminatorBytes,
  getCreateOperationAccountInstruction: () => getCreateOperationAccountInstruction,
  getCreateOperationAccountInstructionAsync: () => getCreateOperationAccountInstructionAsync,
  getCreateOperationAccountInstructionDataCodec: () => getCreateOperationAccountInstructionDataCodec,
  getCreateOperationAccountInstructionDataDecoder: () => getCreateOperationAccountInstructionDataDecoder,
  getCreateOperationAccountInstructionDataEncoder: () => getCreateOperationAccountInstructionDataEncoder,
  getCreatePersonalPositionEventCodec: () => getCreatePersonalPositionEventCodec,
  getCreatePersonalPositionEventDecoder: () => getCreatePersonalPositionEventDecoder,
  getCreatePersonalPositionEventEncoder: () => getCreatePersonalPositionEventEncoder,
  getCreatePoolDiscriminatorBytes: () => getCreatePoolDiscriminatorBytes,
  getCreatePoolInstruction: () => getCreatePoolInstruction,
  getCreatePoolInstructionAsync: () => getCreatePoolInstructionAsync,
  getCreatePoolInstructionDataCodec: () => getCreatePoolInstructionDataCodec,
  getCreatePoolInstructionDataDecoder: () => getCreatePoolInstructionDataDecoder,
  getCreatePoolInstructionDataEncoder: () => getCreatePoolInstructionDataEncoder,
  getCreateSupportMintAssociatedDiscriminatorBytes: () => getCreateSupportMintAssociatedDiscriminatorBytes,
  getCreateSupportMintAssociatedInstruction: () => getCreateSupportMintAssociatedInstruction,
  getCreateSupportMintAssociatedInstructionAsync: () => getCreateSupportMintAssociatedInstructionAsync,
  getCreateSupportMintAssociatedInstructionDataCodec: () => getCreateSupportMintAssociatedInstructionDataCodec,
  getCreateSupportMintAssociatedInstructionDataDecoder: () => getCreateSupportMintAssociatedInstructionDataDecoder,
  getCreateSupportMintAssociatedInstructionDataEncoder: () => getCreateSupportMintAssociatedInstructionDataEncoder,
  getDecreaseLiquidityDiscriminatorBytes: () => getDecreaseLiquidityDiscriminatorBytes,
  getDecreaseLiquidityEventCodec: () => getDecreaseLiquidityEventCodec,
  getDecreaseLiquidityEventDecoder: () => getDecreaseLiquidityEventDecoder,
  getDecreaseLiquidityEventEncoder: () => getDecreaseLiquidityEventEncoder,
  getDecreaseLiquidityInstruction: () => getDecreaseLiquidityInstruction,
  getDecreaseLiquidityInstructionDataCodec: () => getDecreaseLiquidityInstructionDataCodec,
  getDecreaseLiquidityInstructionDataDecoder: () => getDecreaseLiquidityInstructionDataDecoder,
  getDecreaseLiquidityInstructionDataEncoder: () => getDecreaseLiquidityInstructionDataEncoder,
  getDecreaseLiquidityV2DiscriminatorBytes: () => getDecreaseLiquidityV2DiscriminatorBytes,
  getDecreaseLiquidityV2Instruction: () => getDecreaseLiquidityV2Instruction,
  getDecreaseLiquidityV2InstructionDataCodec: () => getDecreaseLiquidityV2InstructionDataCodec,
  getDecreaseLiquidityV2InstructionDataDecoder: () => getDecreaseLiquidityV2InstructionDataDecoder,
  getDecreaseLiquidityV2InstructionDataEncoder: () => getDecreaseLiquidityV2InstructionDataEncoder,
  getIncreaseLiquidityDiscriminatorBytes: () => getIncreaseLiquidityDiscriminatorBytes,
  getIncreaseLiquidityEventCodec: () => getIncreaseLiquidityEventCodec,
  getIncreaseLiquidityEventDecoder: () => getIncreaseLiquidityEventDecoder,
  getIncreaseLiquidityEventEncoder: () => getIncreaseLiquidityEventEncoder,
  getIncreaseLiquidityInstruction: () => getIncreaseLiquidityInstruction,
  getIncreaseLiquidityInstructionDataCodec: () => getIncreaseLiquidityInstructionDataCodec,
  getIncreaseLiquidityInstructionDataDecoder: () => getIncreaseLiquidityInstructionDataDecoder,
  getIncreaseLiquidityInstructionDataEncoder: () => getIncreaseLiquidityInstructionDataEncoder,
  getIncreaseLiquidityV2DiscriminatorBytes: () => getIncreaseLiquidityV2DiscriminatorBytes,
  getIncreaseLiquidityV2Instruction: () => getIncreaseLiquidityV2Instruction,
  getIncreaseLiquidityV2InstructionDataCodec: () => getIncreaseLiquidityV2InstructionDataCodec,
  getIncreaseLiquidityV2InstructionDataDecoder: () => getIncreaseLiquidityV2InstructionDataDecoder,
  getIncreaseLiquidityV2InstructionDataEncoder: () => getIncreaseLiquidityV2InstructionDataEncoder,
  getInitializeRewardDiscriminatorBytes: () => getInitializeRewardDiscriminatorBytes,
  getInitializeRewardInstruction: () => getInitializeRewardInstruction,
  getInitializeRewardInstructionAsync: () => getInitializeRewardInstructionAsync,
  getInitializeRewardInstructionDataCodec: () => getInitializeRewardInstructionDataCodec,
  getInitializeRewardInstructionDataDecoder: () => getInitializeRewardInstructionDataDecoder,
  getInitializeRewardInstructionDataEncoder: () => getInitializeRewardInstructionDataEncoder,
  getLiquidityCalculateEventCodec: () => getLiquidityCalculateEventCodec,
  getLiquidityCalculateEventDecoder: () => getLiquidityCalculateEventDecoder,
  getLiquidityCalculateEventEncoder: () => getLiquidityCalculateEventEncoder,
  getLiquidityChangeEventCodec: () => getLiquidityChangeEventCodec,
  getLiquidityChangeEventDecoder: () => getLiquidityChangeEventDecoder,
  getLiquidityChangeEventEncoder: () => getLiquidityChangeEventEncoder,
  getObservationCodec: () => getObservationCodec,
  getObservationDecoder: () => getObservationDecoder,
  getObservationEncoder: () => getObservationEncoder,
  getObservationStateCodec: () => getObservationStateCodec,
  getObservationStateDecoder: () => getObservationStateDecoder,
  getObservationStateDiscriminatorBytes: () => getObservationStateDiscriminatorBytes,
  getObservationStateEncoder: () => getObservationStateEncoder,
  getObservationStateSize: () => getObservationStateSize,
  getOpenPositionDiscriminatorBytes: () => getOpenPositionDiscriminatorBytes,
  getOpenPositionInstruction: () => getOpenPositionInstruction,
  getOpenPositionInstructionAsync: () => getOpenPositionInstructionAsync,
  getOpenPositionInstructionDataCodec: () => getOpenPositionInstructionDataCodec,
  getOpenPositionInstructionDataDecoder: () => getOpenPositionInstructionDataDecoder,
  getOpenPositionInstructionDataEncoder: () => getOpenPositionInstructionDataEncoder,
  getOpenPositionV2DiscriminatorBytes: () => getOpenPositionV2DiscriminatorBytes,
  getOpenPositionV2Instruction: () => getOpenPositionV2Instruction,
  getOpenPositionV2InstructionAsync: () => getOpenPositionV2InstructionAsync,
  getOpenPositionV2InstructionDataCodec: () => getOpenPositionV2InstructionDataCodec,
  getOpenPositionV2InstructionDataDecoder: () => getOpenPositionV2InstructionDataDecoder,
  getOpenPositionV2InstructionDataEncoder: () => getOpenPositionV2InstructionDataEncoder,
  getOpenPositionWithToken22NftDiscriminatorBytes: () => getOpenPositionWithToken22NftDiscriminatorBytes,
  getOpenPositionWithToken22NftInstruction: () => getOpenPositionWithToken22NftInstruction,
  getOpenPositionWithToken22NftInstructionAsync: () => getOpenPositionWithToken22NftInstructionAsync,
  getOpenPositionWithToken22NftInstructionDataCodec: () => getOpenPositionWithToken22NftInstructionDataCodec,
  getOpenPositionWithToken22NftInstructionDataDecoder: () => getOpenPositionWithToken22NftInstructionDataDecoder,
  getOpenPositionWithToken22NftInstructionDataEncoder: () => getOpenPositionWithToken22NftInstructionDataEncoder,
  getOperationStateCodec: () => getOperationStateCodec,
  getOperationStateDecoder: () => getOperationStateDecoder,
  getOperationStateDiscriminatorBytes: () => getOperationStateDiscriminatorBytes,
  getOperationStateEncoder: () => getOperationStateEncoder,
  getOperationStateSize: () => getOperationStateSize,
  getPersonalPositionStateCodec: () => getPersonalPositionStateCodec,
  getPersonalPositionStateDecoder: () => getPersonalPositionStateDecoder,
  getPersonalPositionStateDiscriminatorBytes: () => getPersonalPositionStateDiscriminatorBytes,
  getPersonalPositionStateEncoder: () => getPersonalPositionStateEncoder,
  getPersonalPositionStateSize: () => getPersonalPositionStateSize,
  getPoolCreatedEventCodec: () => getPoolCreatedEventCodec,
  getPoolCreatedEventDecoder: () => getPoolCreatedEventDecoder,
  getPoolCreatedEventEncoder: () => getPoolCreatedEventEncoder,
  getPoolStateCodec: () => getPoolStateCodec,
  getPoolStateDecoder: () => getPoolStateDecoder,
  getPoolStateDiscriminatorBytes: () => getPoolStateDiscriminatorBytes,
  getPoolStateEncoder: () => getPoolStateEncoder,
  getPoolStateSize: () => getPoolStateSize,
  getPositionRewardInfoCodec: () => getPositionRewardInfoCodec,
  getPositionRewardInfoDecoder: () => getPositionRewardInfoDecoder,
  getPositionRewardInfoEncoder: () => getPositionRewardInfoEncoder,
  getProtocolPositionStateCodec: () => getProtocolPositionStateCodec,
  getProtocolPositionStateDecoder: () => getProtocolPositionStateDecoder,
  getProtocolPositionStateDiscriminatorBytes: () => getProtocolPositionStateDiscriminatorBytes,
  getProtocolPositionStateEncoder: () => getProtocolPositionStateEncoder,
  getProtocolPositionStateSize: () => getProtocolPositionStateSize,
  getRewardInfoCodec: () => getRewardInfoCodec,
  getRewardInfoDecoder: () => getRewardInfoDecoder,
  getRewardInfoEncoder: () => getRewardInfoEncoder,
  getSetRewardParamsDiscriminatorBytes: () => getSetRewardParamsDiscriminatorBytes,
  getSetRewardParamsInstruction: () => getSetRewardParamsInstruction,
  getSetRewardParamsInstructionAsync: () => getSetRewardParamsInstructionAsync,
  getSetRewardParamsInstructionDataCodec: () => getSetRewardParamsInstructionDataCodec,
  getSetRewardParamsInstructionDataDecoder: () => getSetRewardParamsInstructionDataDecoder,
  getSetRewardParamsInstructionDataEncoder: () => getSetRewardParamsInstructionDataEncoder,
  getSupportMintAssociatedCodec: () => getSupportMintAssociatedCodec,
  getSupportMintAssociatedDecoder: () => getSupportMintAssociatedDecoder,
  getSupportMintAssociatedDiscriminatorBytes: () => getSupportMintAssociatedDiscriminatorBytes,
  getSupportMintAssociatedEncoder: () => getSupportMintAssociatedEncoder,
  getSupportMintAssociatedSize: () => getSupportMintAssociatedSize,
  getSwapDiscriminatorBytes: () => getSwapDiscriminatorBytes,
  getSwapEventCodec: () => getSwapEventCodec,
  getSwapEventDecoder: () => getSwapEventDecoder,
  getSwapEventEncoder: () => getSwapEventEncoder,
  getSwapInstruction: () => getSwapInstruction,
  getSwapInstructionDataCodec: () => getSwapInstructionDataCodec,
  getSwapInstructionDataDecoder: () => getSwapInstructionDataDecoder,
  getSwapInstructionDataEncoder: () => getSwapInstructionDataEncoder,
  getSwapRouterBaseInDiscriminatorBytes: () => getSwapRouterBaseInDiscriminatorBytes,
  getSwapRouterBaseInInstruction: () => getSwapRouterBaseInInstruction,
  getSwapRouterBaseInInstructionDataCodec: () => getSwapRouterBaseInInstructionDataCodec,
  getSwapRouterBaseInInstructionDataDecoder: () => getSwapRouterBaseInInstructionDataDecoder,
  getSwapRouterBaseInInstructionDataEncoder: () => getSwapRouterBaseInInstructionDataEncoder,
  getSwapV2DiscriminatorBytes: () => getSwapV2DiscriminatorBytes,
  getSwapV2Instruction: () => getSwapV2Instruction,
  getSwapV2InstructionDataCodec: () => getSwapV2InstructionDataCodec,
  getSwapV2InstructionDataDecoder: () => getSwapV2InstructionDataDecoder,
  getSwapV2InstructionDataEncoder: () => getSwapV2InstructionDataEncoder,
  getTickArrayBitmapExtensionCodec: () => getTickArrayBitmapExtensionCodec,
  getTickArrayBitmapExtensionDecoder: () => getTickArrayBitmapExtensionDecoder,
  getTickArrayBitmapExtensionDiscriminatorBytes: () => getTickArrayBitmapExtensionDiscriminatorBytes,
  getTickArrayBitmapExtensionEncoder: () => getTickArrayBitmapExtensionEncoder,
  getTickArrayBitmapExtensionSize: () => getTickArrayBitmapExtensionSize,
  getTickArrayStateCodec: () => getTickArrayStateCodec,
  getTickArrayStateDecoder: () => getTickArrayStateDecoder,
  getTickArrayStateDiscriminatorBytes: () => getTickArrayStateDiscriminatorBytes,
  getTickArrayStateEncoder: () => getTickArrayStateEncoder,
  getTickArrayStateSize: () => getTickArrayStateSize,
  getTickStateCodec: () => getTickStateCodec,
  getTickStateDecoder: () => getTickStateDecoder,
  getTickStateEncoder: () => getTickStateEncoder,
  getTransferRewardOwnerDiscriminatorBytes: () => getTransferRewardOwnerDiscriminatorBytes,
  getTransferRewardOwnerInstruction: () => getTransferRewardOwnerInstruction,
  getTransferRewardOwnerInstructionDataCodec: () => getTransferRewardOwnerInstructionDataCodec,
  getTransferRewardOwnerInstructionDataDecoder: () => getTransferRewardOwnerInstructionDataDecoder,
  getTransferRewardOwnerInstructionDataEncoder: () => getTransferRewardOwnerInstructionDataEncoder,
  getUpdateAmmConfigDiscriminatorBytes: () => getUpdateAmmConfigDiscriminatorBytes,
  getUpdateAmmConfigInstruction: () => getUpdateAmmConfigInstruction,
  getUpdateAmmConfigInstructionDataCodec: () => getUpdateAmmConfigInstructionDataCodec,
  getUpdateAmmConfigInstructionDataDecoder: () => getUpdateAmmConfigInstructionDataDecoder,
  getUpdateAmmConfigInstructionDataEncoder: () => getUpdateAmmConfigInstructionDataEncoder,
  getUpdateOperationAccountDiscriminatorBytes: () => getUpdateOperationAccountDiscriminatorBytes,
  getUpdateOperationAccountInstruction: () => getUpdateOperationAccountInstruction,
  getUpdateOperationAccountInstructionAsync: () => getUpdateOperationAccountInstructionAsync,
  getUpdateOperationAccountInstructionDataCodec: () => getUpdateOperationAccountInstructionDataCodec,
  getUpdateOperationAccountInstructionDataDecoder: () => getUpdateOperationAccountInstructionDataDecoder,
  getUpdateOperationAccountInstructionDataEncoder: () => getUpdateOperationAccountInstructionDataEncoder,
  getUpdatePoolStatusDiscriminatorBytes: () => getUpdatePoolStatusDiscriminatorBytes,
  getUpdatePoolStatusInstruction: () => getUpdatePoolStatusInstruction,
  getUpdatePoolStatusInstructionDataCodec: () => getUpdatePoolStatusInstructionDataCodec,
  getUpdatePoolStatusInstructionDataDecoder: () => getUpdatePoolStatusInstructionDataDecoder,
  getUpdatePoolStatusInstructionDataEncoder: () => getUpdatePoolStatusInstructionDataEncoder,
  getUpdateRewardInfosDiscriminatorBytes: () => getUpdateRewardInfosDiscriminatorBytes,
  getUpdateRewardInfosEventCodec: () => getUpdateRewardInfosEventCodec,
  getUpdateRewardInfosEventDecoder: () => getUpdateRewardInfosEventDecoder,
  getUpdateRewardInfosEventEncoder: () => getUpdateRewardInfosEventEncoder,
  getUpdateRewardInfosInstruction: () => getUpdateRewardInfosInstruction,
  getUpdateRewardInfosInstructionDataCodec: () => getUpdateRewardInfosInstructionDataCodec,
  getUpdateRewardInfosInstructionDataDecoder: () => getUpdateRewardInfosInstructionDataDecoder,
  getUpdateRewardInfosInstructionDataEncoder: () => getUpdateRewardInfosInstructionDataEncoder,
  identifyAmmV3Account: () => identifyAmmV3Account,
  identifyAmmV3Instruction: () => identifyAmmV3Instruction,
  isAmmV3Error: () => isAmmV3Error,
  parseClosePositionInstruction: () => parseClosePositionInstruction,
  parseCloseProtocolPositionInstruction: () => parseCloseProtocolPositionInstruction,
  parseCollectFundFeeInstruction: () => parseCollectFundFeeInstruction,
  parseCollectProtocolFeeInstruction: () => parseCollectProtocolFeeInstruction,
  parseCollectRemainingRewardsInstruction: () => parseCollectRemainingRewardsInstruction,
  parseCreateAmmConfigInstruction: () => parseCreateAmmConfigInstruction,
  parseCreateOperationAccountInstruction: () => parseCreateOperationAccountInstruction,
  parseCreatePoolInstruction: () => parseCreatePoolInstruction,
  parseCreateSupportMintAssociatedInstruction: () => parseCreateSupportMintAssociatedInstruction,
  parseDecreaseLiquidityInstruction: () => parseDecreaseLiquidityInstruction,
  parseDecreaseLiquidityV2Instruction: () => parseDecreaseLiquidityV2Instruction,
  parseIncreaseLiquidityInstruction: () => parseIncreaseLiquidityInstruction,
  parseIncreaseLiquidityV2Instruction: () => parseIncreaseLiquidityV2Instruction,
  parseInitializeRewardInstruction: () => parseInitializeRewardInstruction,
  parseOpenPositionInstruction: () => parseOpenPositionInstruction,
  parseOpenPositionV2Instruction: () => parseOpenPositionV2Instruction,
  parseOpenPositionWithToken22NftInstruction: () => parseOpenPositionWithToken22NftInstruction,
  parseSetRewardParamsInstruction: () => parseSetRewardParamsInstruction,
  parseSwapInstruction: () => parseSwapInstruction,
  parseSwapRouterBaseInInstruction: () => parseSwapRouterBaseInInstruction,
  parseSwapV2Instruction: () => parseSwapV2Instruction,
  parseTransferRewardOwnerInstruction: () => parseTransferRewardOwnerInstruction,
  parseUpdateAmmConfigInstruction: () => parseUpdateAmmConfigInstruction,
  parseUpdateOperationAccountInstruction: () => parseUpdateOperationAccountInstruction,
  parseUpdatePoolStatusInstruction: () => parseUpdatePoolStatusInstruction,
  parseUpdateRewardInfosInstruction: () => parseUpdateRewardInfosInstruction
});

// src/generated/accounts/ammConfig.ts
import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder
} from "@solana/kit";
var AMM_CONFIG_DISCRIMINATOR = new Uint8Array([
  218,
  244,
  33,
  104,
  203,
  203,
  43,
  111
]);
function getAmmConfigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(AMM_CONFIG_DISCRIMINATOR);
}
function getAmmConfigEncoder() {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["bump", getU8Encoder()],
      ["index", getU16Encoder()],
      ["owner", getAddressEncoder()],
      ["protocolFeeRate", getU32Encoder()],
      ["tradeFeeRate", getU32Encoder()],
      ["tickSpacing", getU16Encoder()],
      ["fundFeeRate", getU32Encoder()],
      ["paddingU32", getU32Encoder()],
      ["fundOwner", getAddressEncoder()],
      ["padding", getArrayEncoder(getU64Encoder(), { size: 3 })]
    ]),
    (value) => ({ ...value, discriminator: AMM_CONFIG_DISCRIMINATOR })
  );
}
function getAmmConfigDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["bump", getU8Decoder()],
    ["index", getU16Decoder()],
    ["owner", getAddressDecoder()],
    ["protocolFeeRate", getU32Decoder()],
    ["tradeFeeRate", getU32Decoder()],
    ["tickSpacing", getU16Decoder()],
    ["fundFeeRate", getU32Decoder()],
    ["paddingU32", getU32Decoder()],
    ["fundOwner", getAddressDecoder()],
    ["padding", getArrayDecoder(getU64Decoder(), { size: 3 })]
  ]);
}
function getAmmConfigCodec() {
  return combineCodec(getAmmConfigEncoder(), getAmmConfigDecoder());
}
function decodeAmmConfig(encodedAccount) {
  return decodeAccount(
    encodedAccount,
    getAmmConfigDecoder()
  );
}
async function fetchAmmConfig(rpc, address4, config) {
  const maybeAccount = await fetchMaybeAmmConfig(rpc, address4, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAmmConfig(rpc, address4, config) {
  const maybeAccount = await fetchEncodedAccount(rpc, address4, config);
  return decodeAmmConfig(maybeAccount);
}
async function fetchAllAmmConfig(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeAmmConfig(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAmmConfig(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeAmmConfig(maybeAccount));
}
function getAmmConfigSize() {
  return 117;
}

// src/generated/accounts/observationState.ts
import {
  assertAccountExists as assertAccountExists2,
  assertAccountsExist as assertAccountsExist2,
  combineCodec as combineCodec17,
  decodeAccount as decodeAccount2,
  fetchEncodedAccount as fetchEncodedAccount2,
  fetchEncodedAccounts as fetchEncodedAccounts2,
  fixDecoderSize as fixDecoderSize2,
  fixEncoderSize as fixEncoderSize2,
  getAddressDecoder as getAddressDecoder12,
  getAddressEncoder as getAddressEncoder12,
  getArrayDecoder as getArrayDecoder6,
  getArrayEncoder as getArrayEncoder6,
  getBooleanDecoder as getBooleanDecoder2,
  getBooleanEncoder as getBooleanEncoder2,
  getBytesDecoder as getBytesDecoder2,
  getBytesEncoder as getBytesEncoder2,
  getStructDecoder as getStructDecoder17,
  getStructEncoder as getStructEncoder17,
  getU16Decoder as getU16Decoder4,
  getU16Encoder as getU16Encoder4,
  getU64Decoder as getU64Decoder12,
  getU64Encoder as getU64Encoder12,
  transformEncoder as transformEncoder2
} from "@solana/kit";

// src/generated/types/collectPersonalFeeEvent.ts
import {
  combineCodec as combineCodec2,
  getAddressDecoder as getAddressDecoder2,
  getAddressEncoder as getAddressEncoder2,
  getStructDecoder as getStructDecoder2,
  getStructEncoder as getStructEncoder2,
  getU64Decoder as getU64Decoder2,
  getU64Encoder as getU64Encoder2
} from "@solana/kit";
function getCollectPersonalFeeEventEncoder() {
  return getStructEncoder2([
    ["positionNftMint", getAddressEncoder2()],
    ["recipientTokenAccount0", getAddressEncoder2()],
    ["recipientTokenAccount1", getAddressEncoder2()],
    ["amount0", getU64Encoder2()],
    ["amount1", getU64Encoder2()]
  ]);
}
function getCollectPersonalFeeEventDecoder() {
  return getStructDecoder2([
    ["positionNftMint", getAddressDecoder2()],
    ["recipientTokenAccount0", getAddressDecoder2()],
    ["recipientTokenAccount1", getAddressDecoder2()],
    ["amount0", getU64Decoder2()],
    ["amount1", getU64Decoder2()]
  ]);
}
function getCollectPersonalFeeEventCodec() {
  return combineCodec2(
    getCollectPersonalFeeEventEncoder(),
    getCollectPersonalFeeEventDecoder()
  );
}

// src/generated/types/collectProtocolFeeEvent.ts
import {
  combineCodec as combineCodec3,
  getAddressDecoder as getAddressDecoder3,
  getAddressEncoder as getAddressEncoder3,
  getStructDecoder as getStructDecoder3,
  getStructEncoder as getStructEncoder3,
  getU64Decoder as getU64Decoder3,
  getU64Encoder as getU64Encoder3
} from "@solana/kit";
function getCollectProtocolFeeEventEncoder() {
  return getStructEncoder3([
    ["poolState", getAddressEncoder3()],
    ["recipientTokenAccount0", getAddressEncoder3()],
    ["recipientTokenAccount1", getAddressEncoder3()],
    ["amount0", getU64Encoder3()],
    ["amount1", getU64Encoder3()]
  ]);
}
function getCollectProtocolFeeEventDecoder() {
  return getStructDecoder3([
    ["poolState", getAddressDecoder3()],
    ["recipientTokenAccount0", getAddressDecoder3()],
    ["recipientTokenAccount1", getAddressDecoder3()],
    ["amount0", getU64Decoder3()],
    ["amount1", getU64Decoder3()]
  ]);
}
function getCollectProtocolFeeEventCodec() {
  return combineCodec3(
    getCollectProtocolFeeEventEncoder(),
    getCollectProtocolFeeEventDecoder()
  );
}

// src/generated/types/configChangeEvent.ts
import {
  combineCodec as combineCodec4,
  getAddressDecoder as getAddressDecoder4,
  getAddressEncoder as getAddressEncoder4,
  getStructDecoder as getStructDecoder4,
  getStructEncoder as getStructEncoder4,
  getU16Decoder as getU16Decoder2,
  getU16Encoder as getU16Encoder2,
  getU32Decoder as getU32Decoder2,
  getU32Encoder as getU32Encoder2
} from "@solana/kit";
function getConfigChangeEventEncoder() {
  return getStructEncoder4([
    ["index", getU16Encoder2()],
    ["owner", getAddressEncoder4()],
    ["protocolFeeRate", getU32Encoder2()],
    ["tradeFeeRate", getU32Encoder2()],
    ["tickSpacing", getU16Encoder2()],
    ["fundFeeRate", getU32Encoder2()],
    ["fundOwner", getAddressEncoder4()]
  ]);
}
function getConfigChangeEventDecoder() {
  return getStructDecoder4([
    ["index", getU16Decoder2()],
    ["owner", getAddressDecoder4()],
    ["protocolFeeRate", getU32Decoder2()],
    ["tradeFeeRate", getU32Decoder2()],
    ["tickSpacing", getU16Decoder2()],
    ["fundFeeRate", getU32Decoder2()],
    ["fundOwner", getAddressDecoder4()]
  ]);
}
function getConfigChangeEventCodec() {
  return combineCodec4(
    getConfigChangeEventEncoder(),
    getConfigChangeEventDecoder()
  );
}

// src/generated/types/createPersonalPositionEvent.ts
import {
  combineCodec as combineCodec5,
  getAddressDecoder as getAddressDecoder5,
  getAddressEncoder as getAddressEncoder5,
  getI32Decoder,
  getI32Encoder,
  getStructDecoder as getStructDecoder5,
  getStructEncoder as getStructEncoder5,
  getU128Decoder,
  getU128Encoder,
  getU64Decoder as getU64Decoder4,
  getU64Encoder as getU64Encoder4
} from "@solana/kit";
function getCreatePersonalPositionEventEncoder() {
  return getStructEncoder5([
    ["poolState", getAddressEncoder5()],
    ["minter", getAddressEncoder5()],
    ["nftOwner", getAddressEncoder5()],
    ["tickLowerIndex", getI32Encoder()],
    ["tickUpperIndex", getI32Encoder()],
    ["liquidity", getU128Encoder()],
    ["depositAmount0", getU64Encoder4()],
    ["depositAmount1", getU64Encoder4()],
    ["depositAmount0TransferFee", getU64Encoder4()],
    ["depositAmount1TransferFee", getU64Encoder4()]
  ]);
}
function getCreatePersonalPositionEventDecoder() {
  return getStructDecoder5([
    ["poolState", getAddressDecoder5()],
    ["minter", getAddressDecoder5()],
    ["nftOwner", getAddressDecoder5()],
    ["tickLowerIndex", getI32Decoder()],
    ["tickUpperIndex", getI32Decoder()],
    ["liquidity", getU128Decoder()],
    ["depositAmount0", getU64Decoder4()],
    ["depositAmount1", getU64Decoder4()],
    ["depositAmount0TransferFee", getU64Decoder4()],
    ["depositAmount1TransferFee", getU64Decoder4()]
  ]);
}
function getCreatePersonalPositionEventCodec() {
  return combineCodec5(
    getCreatePersonalPositionEventEncoder(),
    getCreatePersonalPositionEventDecoder()
  );
}

// src/generated/types/decreaseLiquidityEvent.ts
import {
  combineCodec as combineCodec6,
  getAddressDecoder as getAddressDecoder6,
  getAddressEncoder as getAddressEncoder6,
  getArrayDecoder as getArrayDecoder2,
  getArrayEncoder as getArrayEncoder2,
  getStructDecoder as getStructDecoder6,
  getStructEncoder as getStructEncoder6,
  getU128Decoder as getU128Decoder2,
  getU128Encoder as getU128Encoder2,
  getU64Decoder as getU64Decoder5,
  getU64Encoder as getU64Encoder5
} from "@solana/kit";
function getDecreaseLiquidityEventEncoder() {
  return getStructEncoder6([
    ["positionNftMint", getAddressEncoder6()],
    ["liquidity", getU128Encoder2()],
    ["decreaseAmount0", getU64Encoder5()],
    ["decreaseAmount1", getU64Encoder5()],
    ["feeAmount0", getU64Encoder5()],
    ["feeAmount1", getU64Encoder5()],
    ["rewardAmounts", getArrayEncoder2(getU64Encoder5(), { size: 3 })],
    ["transferFee0", getU64Encoder5()],
    ["transferFee1", getU64Encoder5()]
  ]);
}
function getDecreaseLiquidityEventDecoder() {
  return getStructDecoder6([
    ["positionNftMint", getAddressDecoder6()],
    ["liquidity", getU128Decoder2()],
    ["decreaseAmount0", getU64Decoder5()],
    ["decreaseAmount1", getU64Decoder5()],
    ["feeAmount0", getU64Decoder5()],
    ["feeAmount1", getU64Decoder5()],
    ["rewardAmounts", getArrayDecoder2(getU64Decoder5(), { size: 3 })],
    ["transferFee0", getU64Decoder5()],
    ["transferFee1", getU64Decoder5()]
  ]);
}
function getDecreaseLiquidityEventCodec() {
  return combineCodec6(
    getDecreaseLiquidityEventEncoder(),
    getDecreaseLiquidityEventDecoder()
  );
}

// src/generated/types/increaseLiquidityEvent.ts
import {
  combineCodec as combineCodec7,
  getAddressDecoder as getAddressDecoder7,
  getAddressEncoder as getAddressEncoder7,
  getStructDecoder as getStructDecoder7,
  getStructEncoder as getStructEncoder7,
  getU128Decoder as getU128Decoder3,
  getU128Encoder as getU128Encoder3,
  getU64Decoder as getU64Decoder6,
  getU64Encoder as getU64Encoder6
} from "@solana/kit";
function getIncreaseLiquidityEventEncoder() {
  return getStructEncoder7([
    ["positionNftMint", getAddressEncoder7()],
    ["liquidity", getU128Encoder3()],
    ["amount0", getU64Encoder6()],
    ["amount1", getU64Encoder6()],
    ["amount0TransferFee", getU64Encoder6()],
    ["amount1TransferFee", getU64Encoder6()]
  ]);
}
function getIncreaseLiquidityEventDecoder() {
  return getStructDecoder7([
    ["positionNftMint", getAddressDecoder7()],
    ["liquidity", getU128Decoder3()],
    ["amount0", getU64Decoder6()],
    ["amount1", getU64Decoder6()],
    ["amount0TransferFee", getU64Decoder6()],
    ["amount1TransferFee", getU64Decoder6()]
  ]);
}
function getIncreaseLiquidityEventCodec() {
  return combineCodec7(
    getIncreaseLiquidityEventEncoder(),
    getIncreaseLiquidityEventDecoder()
  );
}

// src/generated/types/liquidityCalculateEvent.ts
import {
  combineCodec as combineCodec8,
  getI32Decoder as getI32Decoder2,
  getI32Encoder as getI32Encoder2,
  getStructDecoder as getStructDecoder8,
  getStructEncoder as getStructEncoder8,
  getU128Decoder as getU128Decoder4,
  getU128Encoder as getU128Encoder4,
  getU64Decoder as getU64Decoder7,
  getU64Encoder as getU64Encoder7
} from "@solana/kit";
function getLiquidityCalculateEventEncoder() {
  return getStructEncoder8([
    ["poolLiquidity", getU128Encoder4()],
    ["poolSqrtPriceX64", getU128Encoder4()],
    ["poolTick", getI32Encoder2()],
    ["calcAmount0", getU64Encoder7()],
    ["calcAmount1", getU64Encoder7()],
    ["tradeFeeOwed0", getU64Encoder7()],
    ["tradeFeeOwed1", getU64Encoder7()],
    ["transferFee0", getU64Encoder7()],
    ["transferFee1", getU64Encoder7()]
  ]);
}
function getLiquidityCalculateEventDecoder() {
  return getStructDecoder8([
    ["poolLiquidity", getU128Decoder4()],
    ["poolSqrtPriceX64", getU128Decoder4()],
    ["poolTick", getI32Decoder2()],
    ["calcAmount0", getU64Decoder7()],
    ["calcAmount1", getU64Decoder7()],
    ["tradeFeeOwed0", getU64Decoder7()],
    ["tradeFeeOwed1", getU64Decoder7()],
    ["transferFee0", getU64Decoder7()],
    ["transferFee1", getU64Decoder7()]
  ]);
}
function getLiquidityCalculateEventCodec() {
  return combineCodec8(
    getLiquidityCalculateEventEncoder(),
    getLiquidityCalculateEventDecoder()
  );
}

// src/generated/types/liquidityChangeEvent.ts
import {
  combineCodec as combineCodec9,
  getAddressDecoder as getAddressDecoder8,
  getAddressEncoder as getAddressEncoder8,
  getI32Decoder as getI32Decoder3,
  getI32Encoder as getI32Encoder3,
  getStructDecoder as getStructDecoder9,
  getStructEncoder as getStructEncoder9,
  getU128Decoder as getU128Decoder5,
  getU128Encoder as getU128Encoder5
} from "@solana/kit";
function getLiquidityChangeEventEncoder() {
  return getStructEncoder9([
    ["poolState", getAddressEncoder8()],
    ["tick", getI32Encoder3()],
    ["tickLower", getI32Encoder3()],
    ["tickUpper", getI32Encoder3()],
    ["liquidityBefore", getU128Encoder5()],
    ["liquidityAfter", getU128Encoder5()]
  ]);
}
function getLiquidityChangeEventDecoder() {
  return getStructDecoder9([
    ["poolState", getAddressDecoder8()],
    ["tick", getI32Decoder3()],
    ["tickLower", getI32Decoder3()],
    ["tickUpper", getI32Decoder3()],
    ["liquidityBefore", getU128Decoder5()],
    ["liquidityAfter", getU128Decoder5()]
  ]);
}
function getLiquidityChangeEventCodec() {
  return combineCodec9(
    getLiquidityChangeEventEncoder(),
    getLiquidityChangeEventDecoder()
  );
}

// src/generated/types/observation.ts
import {
  combineCodec as combineCodec10,
  getArrayDecoder as getArrayDecoder3,
  getArrayEncoder as getArrayEncoder3,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder as getStructDecoder10,
  getStructEncoder as getStructEncoder10,
  getU32Decoder as getU32Decoder3,
  getU32Encoder as getU32Encoder3,
  getU64Decoder as getU64Decoder8,
  getU64Encoder as getU64Encoder8
} from "@solana/kit";
function getObservationEncoder() {
  return getStructEncoder10([
    ["blockTimestamp", getU32Encoder3()],
    ["tickCumulative", getI64Encoder()],
    ["padding", getArrayEncoder3(getU64Encoder8(), { size: 4 })]
  ]);
}
function getObservationDecoder() {
  return getStructDecoder10([
    ["blockTimestamp", getU32Decoder3()],
    ["tickCumulative", getI64Decoder()],
    ["padding", getArrayDecoder3(getU64Decoder8(), { size: 4 })]
  ]);
}
function getObservationCodec() {
  return combineCodec10(getObservationEncoder(), getObservationDecoder());
}

// src/generated/types/poolCreatedEvent.ts
import {
  combineCodec as combineCodec11,
  getAddressDecoder as getAddressDecoder9,
  getAddressEncoder as getAddressEncoder9,
  getI32Decoder as getI32Decoder4,
  getI32Encoder as getI32Encoder4,
  getStructDecoder as getStructDecoder11,
  getStructEncoder as getStructEncoder11,
  getU128Decoder as getU128Decoder6,
  getU128Encoder as getU128Encoder6,
  getU16Decoder as getU16Decoder3,
  getU16Encoder as getU16Encoder3
} from "@solana/kit";
function getPoolCreatedEventEncoder() {
  return getStructEncoder11([
    ["tokenMint0", getAddressEncoder9()],
    ["tokenMint1", getAddressEncoder9()],
    ["tickSpacing", getU16Encoder3()],
    ["poolState", getAddressEncoder9()],
    ["sqrtPriceX64", getU128Encoder6()],
    ["tick", getI32Encoder4()],
    ["tokenVault0", getAddressEncoder9()],
    ["tokenVault1", getAddressEncoder9()]
  ]);
}
function getPoolCreatedEventDecoder() {
  return getStructDecoder11([
    ["tokenMint0", getAddressDecoder9()],
    ["tokenMint1", getAddressDecoder9()],
    ["tickSpacing", getU16Decoder3()],
    ["poolState", getAddressDecoder9()],
    ["sqrtPriceX64", getU128Decoder6()],
    ["tick", getI32Decoder4()],
    ["tokenVault0", getAddressDecoder9()],
    ["tokenVault1", getAddressDecoder9()]
  ]);
}
function getPoolCreatedEventCodec() {
  return combineCodec11(
    getPoolCreatedEventEncoder(),
    getPoolCreatedEventDecoder()
  );
}

// src/generated/types/positionRewardInfo.ts
import {
  combineCodec as combineCodec12,
  getStructDecoder as getStructDecoder12,
  getStructEncoder as getStructEncoder12,
  getU128Decoder as getU128Decoder7,
  getU128Encoder as getU128Encoder7,
  getU64Decoder as getU64Decoder9,
  getU64Encoder as getU64Encoder9
} from "@solana/kit";
function getPositionRewardInfoEncoder() {
  return getStructEncoder12([
    ["growthInsideLastX64", getU128Encoder7()],
    ["rewardAmountOwed", getU64Encoder9()]
  ]);
}
function getPositionRewardInfoDecoder() {
  return getStructDecoder12([
    ["growthInsideLastX64", getU128Decoder7()],
    ["rewardAmountOwed", getU64Decoder9()]
  ]);
}
function getPositionRewardInfoCodec() {
  return combineCodec12(
    getPositionRewardInfoEncoder(),
    getPositionRewardInfoDecoder()
  );
}

// src/generated/types/rewardInfo.ts
import {
  combineCodec as combineCodec13,
  getAddressDecoder as getAddressDecoder10,
  getAddressEncoder as getAddressEncoder10,
  getStructDecoder as getStructDecoder13,
  getStructEncoder as getStructEncoder13,
  getU128Decoder as getU128Decoder8,
  getU128Encoder as getU128Encoder8,
  getU64Decoder as getU64Decoder10,
  getU64Encoder as getU64Encoder10,
  getU8Decoder as getU8Decoder2,
  getU8Encoder as getU8Encoder2
} from "@solana/kit";
function getRewardInfoEncoder() {
  return getStructEncoder13([
    ["rewardState", getU8Encoder2()],
    ["openTime", getU64Encoder10()],
    ["endTime", getU64Encoder10()],
    ["lastUpdateTime", getU64Encoder10()],
    ["emissionsPerSecondX64", getU128Encoder8()],
    ["rewardTotalEmissioned", getU64Encoder10()],
    ["rewardClaimed", getU64Encoder10()],
    ["tokenMint", getAddressEncoder10()],
    ["tokenVault", getAddressEncoder10()],
    ["authority", getAddressEncoder10()],
    ["rewardGrowthGlobalX64", getU128Encoder8()]
  ]);
}
function getRewardInfoDecoder() {
  return getStructDecoder13([
    ["rewardState", getU8Decoder2()],
    ["openTime", getU64Decoder10()],
    ["endTime", getU64Decoder10()],
    ["lastUpdateTime", getU64Decoder10()],
    ["emissionsPerSecondX64", getU128Decoder8()],
    ["rewardTotalEmissioned", getU64Decoder10()],
    ["rewardClaimed", getU64Decoder10()],
    ["tokenMint", getAddressDecoder10()],
    ["tokenVault", getAddressDecoder10()],
    ["authority", getAddressDecoder10()],
    ["rewardGrowthGlobalX64", getU128Decoder8()]
  ]);
}
function getRewardInfoCodec() {
  return combineCodec13(getRewardInfoEncoder(), getRewardInfoDecoder());
}

// src/generated/types/swapEvent.ts
import {
  combineCodec as combineCodec14,
  getAddressDecoder as getAddressDecoder11,
  getAddressEncoder as getAddressEncoder11,
  getBooleanDecoder,
  getBooleanEncoder,
  getI32Decoder as getI32Decoder5,
  getI32Encoder as getI32Encoder5,
  getStructDecoder as getStructDecoder14,
  getStructEncoder as getStructEncoder14,
  getU128Decoder as getU128Decoder9,
  getU128Encoder as getU128Encoder9,
  getU64Decoder as getU64Decoder11,
  getU64Encoder as getU64Encoder11
} from "@solana/kit";
function getSwapEventEncoder() {
  return getStructEncoder14([
    ["poolState", getAddressEncoder11()],
    ["sender", getAddressEncoder11()],
    ["tokenAccount0", getAddressEncoder11()],
    ["tokenAccount1", getAddressEncoder11()],
    ["amount0", getU64Encoder11()],
    ["transferFee0", getU64Encoder11()],
    ["amount1", getU64Encoder11()],
    ["transferFee1", getU64Encoder11()],
    ["zeroForOne", getBooleanEncoder()],
    ["sqrtPriceX64", getU128Encoder9()],
    ["liquidity", getU128Encoder9()],
    ["tick", getI32Encoder5()]
  ]);
}
function getSwapEventDecoder() {
  return getStructDecoder14([
    ["poolState", getAddressDecoder11()],
    ["sender", getAddressDecoder11()],
    ["tokenAccount0", getAddressDecoder11()],
    ["tokenAccount1", getAddressDecoder11()],
    ["amount0", getU64Decoder11()],
    ["transferFee0", getU64Decoder11()],
    ["amount1", getU64Decoder11()],
    ["transferFee1", getU64Decoder11()],
    ["zeroForOne", getBooleanDecoder()],
    ["sqrtPriceX64", getU128Decoder9()],
    ["liquidity", getU128Decoder9()],
    ["tick", getI32Decoder5()]
  ]);
}
function getSwapEventCodec() {
  return combineCodec14(getSwapEventEncoder(), getSwapEventDecoder());
}

// src/generated/types/tickState.ts
import {
  combineCodec as combineCodec15,
  getArrayDecoder as getArrayDecoder4,
  getArrayEncoder as getArrayEncoder4,
  getI128Decoder,
  getI128Encoder,
  getI32Decoder as getI32Decoder6,
  getI32Encoder as getI32Encoder6,
  getStructDecoder as getStructDecoder15,
  getStructEncoder as getStructEncoder15,
  getU128Decoder as getU128Decoder10,
  getU128Encoder as getU128Encoder10,
  getU32Decoder as getU32Decoder4,
  getU32Encoder as getU32Encoder4
} from "@solana/kit";
function getTickStateEncoder() {
  return getStructEncoder15([
    ["tick", getI32Encoder6()],
    ["liquidityNet", getI128Encoder()],
    ["liquidityGross", getU128Encoder10()],
    ["feeGrowthOutside0X64", getU128Encoder10()],
    ["feeGrowthOutside1X64", getU128Encoder10()],
    ["rewardGrowthsOutsideX64", getArrayEncoder4(getU128Encoder10(), { size: 3 })],
    ["padding", getArrayEncoder4(getU32Encoder4(), { size: 13 })]
  ]);
}
function getTickStateDecoder() {
  return getStructDecoder15([
    ["tick", getI32Decoder6()],
    ["liquidityNet", getI128Decoder()],
    ["liquidityGross", getU128Decoder10()],
    ["feeGrowthOutside0X64", getU128Decoder10()],
    ["feeGrowthOutside1X64", getU128Decoder10()],
    ["rewardGrowthsOutsideX64", getArrayDecoder4(getU128Decoder10(), { size: 3 })],
    ["padding", getArrayDecoder4(getU32Decoder4(), { size: 13 })]
  ]);
}
function getTickStateCodec() {
  return combineCodec15(getTickStateEncoder(), getTickStateDecoder());
}

// src/generated/types/updateRewardInfosEvent.ts
import {
  combineCodec as combineCodec16,
  getArrayDecoder as getArrayDecoder5,
  getArrayEncoder as getArrayEncoder5,
  getStructDecoder as getStructDecoder16,
  getStructEncoder as getStructEncoder16,
  getU128Decoder as getU128Decoder11,
  getU128Encoder as getU128Encoder11
} from "@solana/kit";
function getUpdateRewardInfosEventEncoder() {
  return getStructEncoder16([
    ["rewardGrowthGlobalX64", getArrayEncoder5(getU128Encoder11(), { size: 3 })]
  ]);
}
function getUpdateRewardInfosEventDecoder() {
  return getStructDecoder16([
    ["rewardGrowthGlobalX64", getArrayDecoder5(getU128Decoder11(), { size: 3 })]
  ]);
}
function getUpdateRewardInfosEventCodec() {
  return combineCodec16(
    getUpdateRewardInfosEventEncoder(),
    getUpdateRewardInfosEventDecoder()
  );
}

// src/generated/accounts/observationState.ts
var OBSERVATION_STATE_DISCRIMINATOR = new Uint8Array([
  122,
  174,
  197,
  53,
  129,
  9,
  165,
  132
]);
function getObservationStateDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder2(), 8).encode(
    OBSERVATION_STATE_DISCRIMINATOR
  );
}
function getObservationStateEncoder() {
  return transformEncoder2(
    getStructEncoder17([
      ["discriminator", fixEncoderSize2(getBytesEncoder2(), 8)],
      ["initialized", getBooleanEncoder2()],
      ["recentEpoch", getU64Encoder12()],
      ["observationIndex", getU16Encoder4()],
      ["poolId", getAddressEncoder12()],
      ["observations", getArrayEncoder6(getObservationEncoder(), { size: 100 })],
      ["padding", getArrayEncoder6(getU64Encoder12(), { size: 4 })]
    ]),
    (value) => ({ ...value, discriminator: OBSERVATION_STATE_DISCRIMINATOR })
  );
}
function getObservationStateDecoder() {
  return getStructDecoder17([
    ["discriminator", fixDecoderSize2(getBytesDecoder2(), 8)],
    ["initialized", getBooleanDecoder2()],
    ["recentEpoch", getU64Decoder12()],
    ["observationIndex", getU16Decoder4()],
    ["poolId", getAddressDecoder12()],
    ["observations", getArrayDecoder6(getObservationDecoder(), { size: 100 })],
    ["padding", getArrayDecoder6(getU64Decoder12(), { size: 4 })]
  ]);
}
function getObservationStateCodec() {
  return combineCodec17(
    getObservationStateEncoder(),
    getObservationStateDecoder()
  );
}
function decodeObservationState(encodedAccount) {
  return decodeAccount2(
    encodedAccount,
    getObservationStateDecoder()
  );
}
async function fetchObservationState(rpc, address4, config) {
  const maybeAccount = await fetchMaybeObservationState(rpc, address4, config);
  assertAccountExists2(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeObservationState(rpc, address4, config) {
  const maybeAccount = await fetchEncodedAccount2(rpc, address4, config);
  return decodeObservationState(maybeAccount);
}
async function fetchAllObservationState(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeObservationState(
    rpc,
    addresses,
    config
  );
  assertAccountsExist2(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeObservationState(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts2(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeObservationState(maybeAccount)
  );
}
function getObservationStateSize() {
  return 4483;
}

// src/generated/accounts/operationState.ts
import {
  assertAccountExists as assertAccountExists3,
  assertAccountsExist as assertAccountsExist3,
  combineCodec as combineCodec18,
  decodeAccount as decodeAccount3,
  fetchEncodedAccount as fetchEncodedAccount3,
  fetchEncodedAccounts as fetchEncodedAccounts3,
  fixDecoderSize as fixDecoderSize3,
  fixEncoderSize as fixEncoderSize3,
  getAddressDecoder as getAddressDecoder13,
  getAddressEncoder as getAddressEncoder13,
  getArrayDecoder as getArrayDecoder7,
  getArrayEncoder as getArrayEncoder7,
  getBytesDecoder as getBytesDecoder3,
  getBytesEncoder as getBytesEncoder3,
  getStructDecoder as getStructDecoder18,
  getStructEncoder as getStructEncoder18,
  getU8Decoder as getU8Decoder3,
  getU8Encoder as getU8Encoder3,
  transformEncoder as transformEncoder3
} from "@solana/kit";
var OPERATION_STATE_DISCRIMINATOR = new Uint8Array([
  19,
  236,
  58,
  237,
  81,
  222,
  183,
  252
]);
function getOperationStateDiscriminatorBytes() {
  return fixEncoderSize3(getBytesEncoder3(), 8).encode(
    OPERATION_STATE_DISCRIMINATOR
  );
}
function getOperationStateEncoder() {
  return transformEncoder3(
    getStructEncoder18([
      ["discriminator", fixEncoderSize3(getBytesEncoder3(), 8)],
      ["bump", getU8Encoder3()],
      ["operationOwners", getArrayEncoder7(getAddressEncoder13(), { size: 10 })],
      ["whitelistMints", getArrayEncoder7(getAddressEncoder13(), { size: 100 })]
    ]),
    (value) => ({ ...value, discriminator: OPERATION_STATE_DISCRIMINATOR })
  );
}
function getOperationStateDecoder() {
  return getStructDecoder18([
    ["discriminator", fixDecoderSize3(getBytesDecoder3(), 8)],
    ["bump", getU8Decoder3()],
    ["operationOwners", getArrayDecoder7(getAddressDecoder13(), { size: 10 })],
    ["whitelistMints", getArrayDecoder7(getAddressDecoder13(), { size: 100 })]
  ]);
}
function getOperationStateCodec() {
  return combineCodec18(getOperationStateEncoder(), getOperationStateDecoder());
}
function decodeOperationState(encodedAccount) {
  return decodeAccount3(
    encodedAccount,
    getOperationStateDecoder()
  );
}
async function fetchOperationState(rpc, address4, config) {
  const maybeAccount = await fetchMaybeOperationState(rpc, address4, config);
  assertAccountExists3(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeOperationState(rpc, address4, config) {
  const maybeAccount = await fetchEncodedAccount3(rpc, address4, config);
  return decodeOperationState(maybeAccount);
}
async function fetchAllOperationState(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeOperationState(
    rpc,
    addresses,
    config
  );
  assertAccountsExist3(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeOperationState(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts3(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeOperationState(maybeAccount)
  );
}
function getOperationStateSize() {
  return 3529;
}

// src/generated/accounts/personalPositionState.ts
import {
  assertAccountExists as assertAccountExists4,
  assertAccountsExist as assertAccountsExist4,
  combineCodec as combineCodec19,
  decodeAccount as decodeAccount4,
  fetchEncodedAccount as fetchEncodedAccount4,
  fetchEncodedAccounts as fetchEncodedAccounts4,
  fixDecoderSize as fixDecoderSize4,
  fixEncoderSize as fixEncoderSize4,
  getAddressDecoder as getAddressDecoder14,
  getAddressEncoder as getAddressEncoder14,
  getArrayDecoder as getArrayDecoder8,
  getArrayEncoder as getArrayEncoder8,
  getBytesDecoder as getBytesDecoder4,
  getBytesEncoder as getBytesEncoder4,
  getI32Decoder as getI32Decoder7,
  getI32Encoder as getI32Encoder7,
  getStructDecoder as getStructDecoder19,
  getStructEncoder as getStructEncoder19,
  getU128Decoder as getU128Decoder12,
  getU128Encoder as getU128Encoder12,
  getU64Decoder as getU64Decoder13,
  getU64Encoder as getU64Encoder13,
  transformEncoder as transformEncoder4
} from "@solana/kit";
var PERSONAL_POSITION_STATE_DISCRIMINATOR = new Uint8Array([
  70,
  111,
  150,
  126,
  230,
  15,
  25,
  117
]);
function getPersonalPositionStateDiscriminatorBytes() {
  return fixEncoderSize4(getBytesEncoder4(), 8).encode(
    PERSONAL_POSITION_STATE_DISCRIMINATOR
  );
}
function getPersonalPositionStateEncoder() {
  return transformEncoder4(
    getStructEncoder19([
      ["discriminator", fixEncoderSize4(getBytesEncoder4(), 8)],
      ["bump", fixEncoderSize4(getBytesEncoder4(), 1)],
      ["nftMint", getAddressEncoder14()],
      ["poolId", getAddressEncoder14()],
      ["tickLowerIndex", getI32Encoder7()],
      ["tickUpperIndex", getI32Encoder7()],
      ["liquidity", getU128Encoder12()],
      ["feeGrowthInside0LastX64", getU128Encoder12()],
      ["feeGrowthInside1LastX64", getU128Encoder12()],
      ["tokenFeesOwed0", getU64Encoder13()],
      ["tokenFeesOwed1", getU64Encoder13()],
      [
        "rewardInfos",
        getArrayEncoder8(getPositionRewardInfoEncoder(), { size: 3 })
      ],
      ["recentEpoch", getU64Encoder13()],
      ["padding", getArrayEncoder8(getU64Encoder13(), { size: 7 })]
    ]),
    (value) => ({
      ...value,
      discriminator: PERSONAL_POSITION_STATE_DISCRIMINATOR
    })
  );
}
function getPersonalPositionStateDecoder() {
  return getStructDecoder19([
    ["discriminator", fixDecoderSize4(getBytesDecoder4(), 8)],
    ["bump", fixDecoderSize4(getBytesDecoder4(), 1)],
    ["nftMint", getAddressDecoder14()],
    ["poolId", getAddressDecoder14()],
    ["tickLowerIndex", getI32Decoder7()],
    ["tickUpperIndex", getI32Decoder7()],
    ["liquidity", getU128Decoder12()],
    ["feeGrowthInside0LastX64", getU128Decoder12()],
    ["feeGrowthInside1LastX64", getU128Decoder12()],
    ["tokenFeesOwed0", getU64Decoder13()],
    ["tokenFeesOwed1", getU64Decoder13()],
    [
      "rewardInfos",
      getArrayDecoder8(getPositionRewardInfoDecoder(), { size: 3 })
    ],
    ["recentEpoch", getU64Decoder13()],
    ["padding", getArrayDecoder8(getU64Decoder13(), { size: 7 })]
  ]);
}
function getPersonalPositionStateCodec() {
  return combineCodec19(
    getPersonalPositionStateEncoder(),
    getPersonalPositionStateDecoder()
  );
}
function decodePersonalPositionState(encodedAccount) {
  return decodeAccount4(
    encodedAccount,
    getPersonalPositionStateDecoder()
  );
}
async function fetchPersonalPositionState(rpc, address4, config) {
  const maybeAccount = await fetchMaybePersonalPositionState(
    rpc,
    address4,
    config
  );
  assertAccountExists4(maybeAccount);
  return maybeAccount;
}
async function fetchMaybePersonalPositionState(rpc, address4, config) {
  const maybeAccount = await fetchEncodedAccount4(rpc, address4, config);
  return decodePersonalPositionState(maybeAccount);
}
async function fetchAllPersonalPositionState(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybePersonalPositionState(
    rpc,
    addresses,
    config
  );
  assertAccountsExist4(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybePersonalPositionState(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts4(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodePersonalPositionState(maybeAccount)
  );
}
function getPersonalPositionStateSize() {
  return 281;
}

// src/generated/accounts/poolState.ts
import {
  assertAccountExists as assertAccountExists5,
  assertAccountsExist as assertAccountsExist5,
  combineCodec as combineCodec20,
  decodeAccount as decodeAccount5,
  fetchEncodedAccount as fetchEncodedAccount5,
  fetchEncodedAccounts as fetchEncodedAccounts5,
  fixDecoderSize as fixDecoderSize5,
  fixEncoderSize as fixEncoderSize5,
  getAddressDecoder as getAddressDecoder15,
  getAddressEncoder as getAddressEncoder15,
  getArrayDecoder as getArrayDecoder9,
  getArrayEncoder as getArrayEncoder9,
  getBytesDecoder as getBytesDecoder5,
  getBytesEncoder as getBytesEncoder5,
  getI32Decoder as getI32Decoder8,
  getI32Encoder as getI32Encoder8,
  getStructDecoder as getStructDecoder20,
  getStructEncoder as getStructEncoder20,
  getU128Decoder as getU128Decoder13,
  getU128Encoder as getU128Encoder13,
  getU16Decoder as getU16Decoder5,
  getU16Encoder as getU16Encoder5,
  getU64Decoder as getU64Decoder14,
  getU64Encoder as getU64Encoder14,
  getU8Decoder as getU8Decoder4,
  getU8Encoder as getU8Encoder4,
  transformEncoder as transformEncoder5
} from "@solana/kit";
var POOL_STATE_DISCRIMINATOR = new Uint8Array([
  247,
  237,
  227,
  245,
  215,
  195,
  222,
  70
]);
function getPoolStateDiscriminatorBytes() {
  return fixEncoderSize5(getBytesEncoder5(), 8).encode(POOL_STATE_DISCRIMINATOR);
}
function getPoolStateEncoder() {
  return transformEncoder5(
    getStructEncoder20([
      ["discriminator", fixEncoderSize5(getBytesEncoder5(), 8)],
      ["bump", fixEncoderSize5(getBytesEncoder5(), 1)],
      ["ammConfig", getAddressEncoder15()],
      ["owner", getAddressEncoder15()],
      ["tokenMint0", getAddressEncoder15()],
      ["tokenMint1", getAddressEncoder15()],
      ["tokenVault0", getAddressEncoder15()],
      ["tokenVault1", getAddressEncoder15()],
      ["observationKey", getAddressEncoder15()],
      ["mintDecimals0", getU8Encoder4()],
      ["mintDecimals1", getU8Encoder4()],
      ["tickSpacing", getU16Encoder5()],
      ["liquidity", getU128Encoder13()],
      ["sqrtPriceX64", getU128Encoder13()],
      ["tickCurrent", getI32Encoder8()],
      ["padding3", getU16Encoder5()],
      ["padding4", getU16Encoder5()],
      ["feeGrowthGlobal0X64", getU128Encoder13()],
      ["feeGrowthGlobal1X64", getU128Encoder13()],
      ["protocolFeesToken0", getU64Encoder14()],
      ["protocolFeesToken1", getU64Encoder14()],
      ["swapInAmountToken0", getU128Encoder13()],
      ["swapOutAmountToken1", getU128Encoder13()],
      ["swapInAmountToken1", getU128Encoder13()],
      ["swapOutAmountToken0", getU128Encoder13()],
      ["status", getU8Encoder4()],
      ["padding", fixEncoderSize5(getBytesEncoder5(), 7)],
      ["rewardInfos", getArrayEncoder9(getRewardInfoEncoder(), { size: 3 })],
      ["tickArrayBitmap", getArrayEncoder9(getU64Encoder14(), { size: 16 })],
      ["totalFeesToken0", getU64Encoder14()],
      ["totalFeesClaimedToken0", getU64Encoder14()],
      ["totalFeesToken1", getU64Encoder14()],
      ["totalFeesClaimedToken1", getU64Encoder14()],
      ["fundFeesToken0", getU64Encoder14()],
      ["fundFeesToken1", getU64Encoder14()],
      ["openTime", getU64Encoder14()],
      ["recentEpoch", getU64Encoder14()],
      ["padding1", getArrayEncoder9(getU64Encoder14(), { size: 24 })],
      ["padding2", getArrayEncoder9(getU64Encoder14(), { size: 32 })]
    ]),
    (value) => ({ ...value, discriminator: POOL_STATE_DISCRIMINATOR })
  );
}
function getPoolStateDecoder() {
  return getStructDecoder20([
    ["discriminator", fixDecoderSize5(getBytesDecoder5(), 8)],
    ["bump", fixDecoderSize5(getBytesDecoder5(), 1)],
    ["ammConfig", getAddressDecoder15()],
    ["owner", getAddressDecoder15()],
    ["tokenMint0", getAddressDecoder15()],
    ["tokenMint1", getAddressDecoder15()],
    ["tokenVault0", getAddressDecoder15()],
    ["tokenVault1", getAddressDecoder15()],
    ["observationKey", getAddressDecoder15()],
    ["mintDecimals0", getU8Decoder4()],
    ["mintDecimals1", getU8Decoder4()],
    ["tickSpacing", getU16Decoder5()],
    ["liquidity", getU128Decoder13()],
    ["sqrtPriceX64", getU128Decoder13()],
    ["tickCurrent", getI32Decoder8()],
    ["padding3", getU16Decoder5()],
    ["padding4", getU16Decoder5()],
    ["feeGrowthGlobal0X64", getU128Decoder13()],
    ["feeGrowthGlobal1X64", getU128Decoder13()],
    ["protocolFeesToken0", getU64Decoder14()],
    ["protocolFeesToken1", getU64Decoder14()],
    ["swapInAmountToken0", getU128Decoder13()],
    ["swapOutAmountToken1", getU128Decoder13()],
    ["swapInAmountToken1", getU128Decoder13()],
    ["swapOutAmountToken0", getU128Decoder13()],
    ["status", getU8Decoder4()],
    ["padding", fixDecoderSize5(getBytesDecoder5(), 7)],
    ["rewardInfos", getArrayDecoder9(getRewardInfoDecoder(), { size: 3 })],
    ["tickArrayBitmap", getArrayDecoder9(getU64Decoder14(), { size: 16 })],
    ["totalFeesToken0", getU64Decoder14()],
    ["totalFeesClaimedToken0", getU64Decoder14()],
    ["totalFeesToken1", getU64Decoder14()],
    ["totalFeesClaimedToken1", getU64Decoder14()],
    ["fundFeesToken0", getU64Decoder14()],
    ["fundFeesToken1", getU64Decoder14()],
    ["openTime", getU64Decoder14()],
    ["recentEpoch", getU64Decoder14()],
    ["padding1", getArrayDecoder9(getU64Decoder14(), { size: 24 })],
    ["padding2", getArrayDecoder9(getU64Decoder14(), { size: 32 })]
  ]);
}
function getPoolStateCodec() {
  return combineCodec20(getPoolStateEncoder(), getPoolStateDecoder());
}
function decodePoolState(encodedAccount) {
  return decodeAccount5(
    encodedAccount,
    getPoolStateDecoder()
  );
}
async function fetchPoolState(rpc, address4, config) {
  const maybeAccount = await fetchMaybePoolState(rpc, address4, config);
  assertAccountExists5(maybeAccount);
  return maybeAccount;
}
async function fetchMaybePoolState(rpc, address4, config) {
  const maybeAccount = await fetchEncodedAccount5(rpc, address4, config);
  return decodePoolState(maybeAccount);
}
async function fetchAllPoolState(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybePoolState(rpc, addresses, config);
  assertAccountsExist5(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybePoolState(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts5(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodePoolState(maybeAccount));
}
function getPoolStateSize() {
  return 1544;
}

// src/generated/accounts/protocolPositionState.ts
import {
  assertAccountExists as assertAccountExists6,
  assertAccountsExist as assertAccountsExist6,
  combineCodec as combineCodec21,
  decodeAccount as decodeAccount6,
  fetchEncodedAccount as fetchEncodedAccount6,
  fetchEncodedAccounts as fetchEncodedAccounts6,
  fixDecoderSize as fixDecoderSize6,
  fixEncoderSize as fixEncoderSize6,
  getAddressDecoder as getAddressDecoder16,
  getAddressEncoder as getAddressEncoder16,
  getArrayDecoder as getArrayDecoder10,
  getArrayEncoder as getArrayEncoder10,
  getBytesDecoder as getBytesDecoder6,
  getBytesEncoder as getBytesEncoder6,
  getI32Decoder as getI32Decoder9,
  getI32Encoder as getI32Encoder9,
  getStructDecoder as getStructDecoder21,
  getStructEncoder as getStructEncoder21,
  getU128Decoder as getU128Decoder14,
  getU128Encoder as getU128Encoder14,
  getU64Decoder as getU64Decoder15,
  getU64Encoder as getU64Encoder15,
  getU8Decoder as getU8Decoder5,
  getU8Encoder as getU8Encoder5,
  transformEncoder as transformEncoder6
} from "@solana/kit";
var PROTOCOL_POSITION_STATE_DISCRIMINATOR = new Uint8Array([
  100,
  226,
  145,
  99,
  146,
  218,
  160,
  106
]);
function getProtocolPositionStateDiscriminatorBytes() {
  return fixEncoderSize6(getBytesEncoder6(), 8).encode(
    PROTOCOL_POSITION_STATE_DISCRIMINATOR
  );
}
function getProtocolPositionStateEncoder() {
  return transformEncoder6(
    getStructEncoder21([
      ["discriminator", fixEncoderSize6(getBytesEncoder6(), 8)],
      ["bump", getU8Encoder5()],
      ["poolId", getAddressEncoder16()],
      ["tickLowerIndex", getI32Encoder9()],
      ["tickUpperIndex", getI32Encoder9()],
      ["liquidity", getU128Encoder14()],
      ["feeGrowthInside0LastX64", getU128Encoder14()],
      ["feeGrowthInside1LastX64", getU128Encoder14()],
      ["tokenFeesOwed0", getU64Encoder15()],
      ["tokenFeesOwed1", getU64Encoder15()],
      ["rewardGrowthInside", getArrayEncoder10(getU128Encoder14(), { size: 3 })],
      ["recentEpoch", getU64Encoder15()],
      ["padding", getArrayEncoder10(getU64Encoder15(), { size: 7 })]
    ]),
    (value) => ({
      ...value,
      discriminator: PROTOCOL_POSITION_STATE_DISCRIMINATOR
    })
  );
}
function getProtocolPositionStateDecoder() {
  return getStructDecoder21([
    ["discriminator", fixDecoderSize6(getBytesDecoder6(), 8)],
    ["bump", getU8Decoder5()],
    ["poolId", getAddressDecoder16()],
    ["tickLowerIndex", getI32Decoder9()],
    ["tickUpperIndex", getI32Decoder9()],
    ["liquidity", getU128Decoder14()],
    ["feeGrowthInside0LastX64", getU128Decoder14()],
    ["feeGrowthInside1LastX64", getU128Decoder14()],
    ["tokenFeesOwed0", getU64Decoder15()],
    ["tokenFeesOwed1", getU64Decoder15()],
    ["rewardGrowthInside", getArrayDecoder10(getU128Decoder14(), { size: 3 })],
    ["recentEpoch", getU64Decoder15()],
    ["padding", getArrayDecoder10(getU64Decoder15(), { size: 7 })]
  ]);
}
function getProtocolPositionStateCodec() {
  return combineCodec21(
    getProtocolPositionStateEncoder(),
    getProtocolPositionStateDecoder()
  );
}
function decodeProtocolPositionState(encodedAccount) {
  return decodeAccount6(
    encodedAccount,
    getProtocolPositionStateDecoder()
  );
}
async function fetchProtocolPositionState(rpc, address4, config) {
  const maybeAccount = await fetchMaybeProtocolPositionState(
    rpc,
    address4,
    config
  );
  assertAccountExists6(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeProtocolPositionState(rpc, address4, config) {
  const maybeAccount = await fetchEncodedAccount6(rpc, address4, config);
  return decodeProtocolPositionState(maybeAccount);
}
async function fetchAllProtocolPositionState(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeProtocolPositionState(
    rpc,
    addresses,
    config
  );
  assertAccountsExist6(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeProtocolPositionState(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts6(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeProtocolPositionState(maybeAccount)
  );
}
function getProtocolPositionStateSize() {
  return 225;
}

// src/generated/accounts/supportMintAssociated.ts
import {
  assertAccountExists as assertAccountExists7,
  assertAccountsExist as assertAccountsExist7,
  combineCodec as combineCodec22,
  decodeAccount as decodeAccount7,
  fetchEncodedAccount as fetchEncodedAccount7,
  fetchEncodedAccounts as fetchEncodedAccounts7,
  fixDecoderSize as fixDecoderSize7,
  fixEncoderSize as fixEncoderSize7,
  getAddressDecoder as getAddressDecoder17,
  getAddressEncoder as getAddressEncoder17,
  getArrayDecoder as getArrayDecoder11,
  getArrayEncoder as getArrayEncoder11,
  getBytesDecoder as getBytesDecoder7,
  getBytesEncoder as getBytesEncoder7,
  getStructDecoder as getStructDecoder22,
  getStructEncoder as getStructEncoder22,
  getU64Decoder as getU64Decoder16,
  getU64Encoder as getU64Encoder16,
  getU8Decoder as getU8Decoder6,
  getU8Encoder as getU8Encoder6,
  transformEncoder as transformEncoder7
} from "@solana/kit";
var SUPPORT_MINT_ASSOCIATED_DISCRIMINATOR = new Uint8Array([
  134,
  40,
  183,
  79,
  12,
  112,
  162,
  53
]);
function getSupportMintAssociatedDiscriminatorBytes() {
  return fixEncoderSize7(getBytesEncoder7(), 8).encode(
    SUPPORT_MINT_ASSOCIATED_DISCRIMINATOR
  );
}
function getSupportMintAssociatedEncoder() {
  return transformEncoder7(
    getStructEncoder22([
      ["discriminator", fixEncoderSize7(getBytesEncoder7(), 8)],
      ["bump", getU8Encoder6()],
      ["mint", getAddressEncoder17()],
      ["padding", getArrayEncoder11(getU64Encoder16(), { size: 8 })]
    ]),
    (value) => ({
      ...value,
      discriminator: SUPPORT_MINT_ASSOCIATED_DISCRIMINATOR
    })
  );
}
function getSupportMintAssociatedDecoder() {
  return getStructDecoder22([
    ["discriminator", fixDecoderSize7(getBytesDecoder7(), 8)],
    ["bump", getU8Decoder6()],
    ["mint", getAddressDecoder17()],
    ["padding", getArrayDecoder11(getU64Decoder16(), { size: 8 })]
  ]);
}
function getSupportMintAssociatedCodec() {
  return combineCodec22(
    getSupportMintAssociatedEncoder(),
    getSupportMintAssociatedDecoder()
  );
}
function decodeSupportMintAssociated(encodedAccount) {
  return decodeAccount7(
    encodedAccount,
    getSupportMintAssociatedDecoder()
  );
}
async function fetchSupportMintAssociated(rpc, address4, config) {
  const maybeAccount = await fetchMaybeSupportMintAssociated(
    rpc,
    address4,
    config
  );
  assertAccountExists7(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeSupportMintAssociated(rpc, address4, config) {
  const maybeAccount = await fetchEncodedAccount7(rpc, address4, config);
  return decodeSupportMintAssociated(maybeAccount);
}
async function fetchAllSupportMintAssociated(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeSupportMintAssociated(
    rpc,
    addresses,
    config
  );
  assertAccountsExist7(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeSupportMintAssociated(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts7(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeSupportMintAssociated(maybeAccount)
  );
}
function getSupportMintAssociatedSize() {
  return 105;
}

// src/generated/accounts/tickArrayBitmapExtension.ts
import {
  assertAccountExists as assertAccountExists8,
  assertAccountsExist as assertAccountsExist8,
  combineCodec as combineCodec23,
  decodeAccount as decodeAccount8,
  fetchEncodedAccount as fetchEncodedAccount8,
  fetchEncodedAccounts as fetchEncodedAccounts8,
  fixDecoderSize as fixDecoderSize8,
  fixEncoderSize as fixEncoderSize8,
  getAddressDecoder as getAddressDecoder18,
  getAddressEncoder as getAddressEncoder18,
  getArrayDecoder as getArrayDecoder12,
  getArrayEncoder as getArrayEncoder12,
  getBytesDecoder as getBytesDecoder8,
  getBytesEncoder as getBytesEncoder8,
  getStructDecoder as getStructDecoder23,
  getStructEncoder as getStructEncoder23,
  getU64Decoder as getU64Decoder17,
  getU64Encoder as getU64Encoder17,
  transformEncoder as transformEncoder8
} from "@solana/kit";
var TICK_ARRAY_BITMAP_EXTENSION_DISCRIMINATOR = new Uint8Array([
  60,
  150,
  36,
  219,
  97,
  128,
  139,
  153
]);
function getTickArrayBitmapExtensionDiscriminatorBytes() {
  return fixEncoderSize8(getBytesEncoder8(), 8).encode(
    TICK_ARRAY_BITMAP_EXTENSION_DISCRIMINATOR
  );
}
function getTickArrayBitmapExtensionEncoder() {
  return transformEncoder8(
    getStructEncoder23([
      ["discriminator", fixEncoderSize8(getBytesEncoder8(), 8)],
      ["poolId", getAddressEncoder18()],
      [
        "positiveTickArrayBitmap",
        getArrayEncoder12(getArrayEncoder12(getU64Encoder17(), { size: 8 }), {
          size: 14
        })
      ],
      [
        "negativeTickArrayBitmap",
        getArrayEncoder12(getArrayEncoder12(getU64Encoder17(), { size: 8 }), {
          size: 14
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: TICK_ARRAY_BITMAP_EXTENSION_DISCRIMINATOR
    })
  );
}
function getTickArrayBitmapExtensionDecoder() {
  return getStructDecoder23([
    ["discriminator", fixDecoderSize8(getBytesDecoder8(), 8)],
    ["poolId", getAddressDecoder18()],
    [
      "positiveTickArrayBitmap",
      getArrayDecoder12(getArrayDecoder12(getU64Decoder17(), { size: 8 }), {
        size: 14
      })
    ],
    [
      "negativeTickArrayBitmap",
      getArrayDecoder12(getArrayDecoder12(getU64Decoder17(), { size: 8 }), {
        size: 14
      })
    ]
  ]);
}
function getTickArrayBitmapExtensionCodec() {
  return combineCodec23(
    getTickArrayBitmapExtensionEncoder(),
    getTickArrayBitmapExtensionDecoder()
  );
}
function decodeTickArrayBitmapExtension(encodedAccount) {
  return decodeAccount8(
    encodedAccount,
    getTickArrayBitmapExtensionDecoder()
  );
}
async function fetchTickArrayBitmapExtension(rpc, address4, config) {
  const maybeAccount = await fetchMaybeTickArrayBitmapExtension(
    rpc,
    address4,
    config
  );
  assertAccountExists8(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeTickArrayBitmapExtension(rpc, address4, config) {
  const maybeAccount = await fetchEncodedAccount8(rpc, address4, config);
  return decodeTickArrayBitmapExtension(maybeAccount);
}
async function fetchAllTickArrayBitmapExtension(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeTickArrayBitmapExtension(
    rpc,
    addresses,
    config
  );
  assertAccountsExist8(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeTickArrayBitmapExtension(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts8(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeTickArrayBitmapExtension(maybeAccount)
  );
}
function getTickArrayBitmapExtensionSize() {
  return 1832;
}

// src/generated/accounts/tickArrayState.ts
import {
  assertAccountExists as assertAccountExists9,
  assertAccountsExist as assertAccountsExist9,
  combineCodec as combineCodec24,
  decodeAccount as decodeAccount9,
  fetchEncodedAccount as fetchEncodedAccount9,
  fetchEncodedAccounts as fetchEncodedAccounts9,
  fixDecoderSize as fixDecoderSize9,
  fixEncoderSize as fixEncoderSize9,
  getAddressDecoder as getAddressDecoder19,
  getAddressEncoder as getAddressEncoder19,
  getArrayDecoder as getArrayDecoder13,
  getArrayEncoder as getArrayEncoder13,
  getBytesDecoder as getBytesDecoder9,
  getBytesEncoder as getBytesEncoder9,
  getI32Decoder as getI32Decoder10,
  getI32Encoder as getI32Encoder10,
  getStructDecoder as getStructDecoder24,
  getStructEncoder as getStructEncoder24,
  getU64Decoder as getU64Decoder18,
  getU64Encoder as getU64Encoder18,
  getU8Decoder as getU8Decoder7,
  getU8Encoder as getU8Encoder7,
  transformEncoder as transformEncoder9
} from "@solana/kit";
var TICK_ARRAY_STATE_DISCRIMINATOR = new Uint8Array([
  192,
  155,
  85,
  205,
  49,
  249,
  129,
  42
]);
function getTickArrayStateDiscriminatorBytes() {
  return fixEncoderSize9(getBytesEncoder9(), 8).encode(
    TICK_ARRAY_STATE_DISCRIMINATOR
  );
}
function getTickArrayStateEncoder() {
  return transformEncoder9(
    getStructEncoder24([
      ["discriminator", fixEncoderSize9(getBytesEncoder9(), 8)],
      ["poolId", getAddressEncoder19()],
      ["startTickIndex", getI32Encoder10()],
      ["ticks", getArrayEncoder13(getTickStateEncoder(), { size: 60 })],
      ["initializedTickCount", getU8Encoder7()],
      ["recentEpoch", getU64Encoder18()],
      ["padding", fixEncoderSize9(getBytesEncoder9(), 107)]
    ]),
    (value) => ({ ...value, discriminator: TICK_ARRAY_STATE_DISCRIMINATOR })
  );
}
function getTickArrayStateDecoder() {
  return getStructDecoder24([
    ["discriminator", fixDecoderSize9(getBytesDecoder9(), 8)],
    ["poolId", getAddressDecoder19()],
    ["startTickIndex", getI32Decoder10()],
    ["ticks", getArrayDecoder13(getTickStateDecoder(), { size: 60 })],
    ["initializedTickCount", getU8Decoder7()],
    ["recentEpoch", getU64Decoder18()],
    ["padding", fixDecoderSize9(getBytesDecoder9(), 107)]
  ]);
}
function getTickArrayStateCodec() {
  return combineCodec24(getTickArrayStateEncoder(), getTickArrayStateDecoder());
}
function decodeTickArrayState(encodedAccount) {
  return decodeAccount9(
    encodedAccount,
    getTickArrayStateDecoder()
  );
}
async function fetchTickArrayState(rpc, address4, config) {
  const maybeAccount = await fetchMaybeTickArrayState(rpc, address4, config);
  assertAccountExists9(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeTickArrayState(rpc, address4, config) {
  const maybeAccount = await fetchEncodedAccount9(rpc, address4, config);
  return decodeTickArrayState(maybeAccount);
}
async function fetchAllTickArrayState(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeTickArrayState(
    rpc,
    addresses,
    config
  );
  assertAccountsExist9(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeTickArrayState(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts9(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeTickArrayState(maybeAccount)
  );
}
function getTickArrayStateSize() {
  return 10240;
}

// src/generated/errors/ammV3.ts
import {
  isProgramError
} from "@solana/kit";

// src/generated/programs/ammV3.ts
import {
  containsBytes,
  fixEncoderSize as fixEncoderSize10,
  getBytesEncoder as getBytesEncoder10
} from "@solana/kit";
var AMM_V3_PROGRAM_ADDRESS = "6dMXqGZ3ga2dikrYS9ovDXgHGh5RUsb2RTUj6hrQXhk6";
var AmmV3Account = /* @__PURE__ */ ((AmmV3Account2) => {
  AmmV3Account2[AmmV3Account2["AmmConfig"] = 0] = "AmmConfig";
  AmmV3Account2[AmmV3Account2["ObservationState"] = 1] = "ObservationState";
  AmmV3Account2[AmmV3Account2["OperationState"] = 2] = "OperationState";
  AmmV3Account2[AmmV3Account2["PersonalPositionState"] = 3] = "PersonalPositionState";
  AmmV3Account2[AmmV3Account2["PoolState"] = 4] = "PoolState";
  AmmV3Account2[AmmV3Account2["ProtocolPositionState"] = 5] = "ProtocolPositionState";
  AmmV3Account2[AmmV3Account2["SupportMintAssociated"] = 6] = "SupportMintAssociated";
  AmmV3Account2[AmmV3Account2["TickArrayBitmapExtension"] = 7] = "TickArrayBitmapExtension";
  AmmV3Account2[AmmV3Account2["TickArrayState"] = 8] = "TickArrayState";
  return AmmV3Account2;
})(AmmV3Account || {});
function identifyAmmV3Account(account) {
  const data = "data" in account ? account.data : account;
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([218, 244, 33, 104, 203, 203, 43, 111])
    ),
    0
  )) {
    return 0 /* AmmConfig */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([122, 174, 197, 53, 129, 9, 165, 132])
    ),
    0
  )) {
    return 1 /* ObservationState */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([19, 236, 58, 237, 81, 222, 183, 252])
    ),
    0
  )) {
    return 2 /* OperationState */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([70, 111, 150, 126, 230, 15, 25, 117])
    ),
    0
  )) {
    return 3 /* PersonalPositionState */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([247, 237, 227, 245, 215, 195, 222, 70])
    ),
    0
  )) {
    return 4 /* PoolState */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([100, 226, 145, 99, 146, 218, 160, 106])
    ),
    0
  )) {
    return 5 /* ProtocolPositionState */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([134, 40, 183, 79, 12, 112, 162, 53])
    ),
    0
  )) {
    return 6 /* SupportMintAssociated */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([60, 150, 36, 219, 97, 128, 139, 153])
    ),
    0
  )) {
    return 7 /* TickArrayBitmapExtension */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([192, 155, 85, 205, 49, 249, 129, 42])
    ),
    0
  )) {
    return 8 /* TickArrayState */;
  }
  throw new Error(
    "The provided account could not be identified as a ammV3 account."
  );
}
var AmmV3Instruction = /* @__PURE__ */ ((AmmV3Instruction2) => {
  AmmV3Instruction2[AmmV3Instruction2["ClosePosition"] = 0] = "ClosePosition";
  AmmV3Instruction2[AmmV3Instruction2["CloseProtocolPosition"] = 1] = "CloseProtocolPosition";
  AmmV3Instruction2[AmmV3Instruction2["CollectFundFee"] = 2] = "CollectFundFee";
  AmmV3Instruction2[AmmV3Instruction2["CollectProtocolFee"] = 3] = "CollectProtocolFee";
  AmmV3Instruction2[AmmV3Instruction2["CollectRemainingRewards"] = 4] = "CollectRemainingRewards";
  AmmV3Instruction2[AmmV3Instruction2["CreateAmmConfig"] = 5] = "CreateAmmConfig";
  AmmV3Instruction2[AmmV3Instruction2["CreateOperationAccount"] = 6] = "CreateOperationAccount";
  AmmV3Instruction2[AmmV3Instruction2["CreatePool"] = 7] = "CreatePool";
  AmmV3Instruction2[AmmV3Instruction2["CreateSupportMintAssociated"] = 8] = "CreateSupportMintAssociated";
  AmmV3Instruction2[AmmV3Instruction2["DecreaseLiquidity"] = 9] = "DecreaseLiquidity";
  AmmV3Instruction2[AmmV3Instruction2["DecreaseLiquidityV2"] = 10] = "DecreaseLiquidityV2";
  AmmV3Instruction2[AmmV3Instruction2["IncreaseLiquidity"] = 11] = "IncreaseLiquidity";
  AmmV3Instruction2[AmmV3Instruction2["IncreaseLiquidityV2"] = 12] = "IncreaseLiquidityV2";
  AmmV3Instruction2[AmmV3Instruction2["InitializeReward"] = 13] = "InitializeReward";
  AmmV3Instruction2[AmmV3Instruction2["OpenPosition"] = 14] = "OpenPosition";
  AmmV3Instruction2[AmmV3Instruction2["OpenPositionV2"] = 15] = "OpenPositionV2";
  AmmV3Instruction2[AmmV3Instruction2["OpenPositionWithToken22Nft"] = 16] = "OpenPositionWithToken22Nft";
  AmmV3Instruction2[AmmV3Instruction2["SetRewardParams"] = 17] = "SetRewardParams";
  AmmV3Instruction2[AmmV3Instruction2["Swap"] = 18] = "Swap";
  AmmV3Instruction2[AmmV3Instruction2["SwapRouterBaseIn"] = 19] = "SwapRouterBaseIn";
  AmmV3Instruction2[AmmV3Instruction2["SwapV2"] = 20] = "SwapV2";
  AmmV3Instruction2[AmmV3Instruction2["TransferRewardOwner"] = 21] = "TransferRewardOwner";
  AmmV3Instruction2[AmmV3Instruction2["UpdateAmmConfig"] = 22] = "UpdateAmmConfig";
  AmmV3Instruction2[AmmV3Instruction2["UpdateOperationAccount"] = 23] = "UpdateOperationAccount";
  AmmV3Instruction2[AmmV3Instruction2["UpdatePoolStatus"] = 24] = "UpdatePoolStatus";
  AmmV3Instruction2[AmmV3Instruction2["UpdateRewardInfos"] = 25] = "UpdateRewardInfos";
  return AmmV3Instruction2;
})(AmmV3Instruction || {});
function identifyAmmV3Instruction(instruction) {
  const data = "data" in instruction ? instruction.data : instruction;
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([123, 134, 81, 0, 49, 68, 98, 98])
    ),
    0
  )) {
    return 0 /* ClosePosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([201, 117, 152, 144, 85, 85, 108, 178])
    ),
    0
  )) {
    return 1 /* CloseProtocolPosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([167, 138, 78, 149, 223, 194, 6, 126])
    ),
    0
  )) {
    return 2 /* CollectFundFee */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([136, 136, 252, 221, 194, 66, 126, 89])
    ),
    0
  )) {
    return 3 /* CollectProtocolFee */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([18, 237, 166, 197, 34, 16, 213, 144])
    ),
    0
  )) {
    return 4 /* CollectRemainingRewards */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([137, 52, 237, 212, 215, 117, 108, 104])
    ),
    0
  )) {
    return 5 /* CreateAmmConfig */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([63, 87, 148, 33, 109, 35, 8, 104])
    ),
    0
  )) {
    return 6 /* CreateOperationAccount */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([233, 146, 209, 142, 207, 104, 64, 188])
    ),
    0
  )) {
    return 7 /* CreatePool */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([17, 251, 65, 92, 136, 242, 14, 169])
    ),
    0
  )) {
    return 8 /* CreateSupportMintAssociated */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([160, 38, 208, 111, 104, 91, 44, 1])
    ),
    0
  )) {
    return 9 /* DecreaseLiquidity */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([58, 127, 188, 62, 79, 82, 196, 96])
    ),
    0
  )) {
    return 10 /* DecreaseLiquidityV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([46, 156, 243, 118, 13, 205, 251, 178])
    ),
    0
  )) {
    return 11 /* IncreaseLiquidity */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([133, 29, 89, 223, 69, 238, 176, 10])
    ),
    0
  )) {
    return 12 /* IncreaseLiquidityV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([95, 135, 192, 196, 242, 129, 230, 68])
    ),
    0
  )) {
    return 13 /* InitializeReward */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([135, 128, 47, 77, 15, 152, 240, 49])
    ),
    0
  )) {
    return 14 /* OpenPosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([77, 184, 74, 214, 112, 86, 241, 199])
    ),
    0
  )) {
    return 15 /* OpenPositionV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([77, 255, 174, 82, 125, 29, 201, 46])
    ),
    0
  )) {
    return 16 /* OpenPositionWithToken22Nft */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([112, 52, 167, 75, 32, 201, 211, 137])
    ),
    0
  )) {
    return 17 /* SetRewardParams */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([248, 198, 158, 145, 225, 117, 135, 200])
    ),
    0
  )) {
    return 18 /* Swap */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([69, 125, 115, 218, 245, 186, 242, 196])
    ),
    0
  )) {
    return 19 /* SwapRouterBaseIn */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([43, 4, 237, 11, 26, 201, 30, 98])
    ),
    0
  )) {
    return 20 /* SwapV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([7, 22, 12, 83, 242, 43, 48, 121])
    ),
    0
  )) {
    return 21 /* TransferRewardOwner */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([49, 60, 174, 136, 154, 28, 116, 200])
    ),
    0
  )) {
    return 22 /* UpdateAmmConfig */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([127, 70, 119, 40, 188, 227, 61, 7])
    ),
    0
  )) {
    return 23 /* UpdateOperationAccount */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([130, 87, 108, 6, 46, 224, 117, 123])
    ),
    0
  )) {
    return 24 /* UpdatePoolStatus */;
  }
  if (containsBytes(
    data,
    fixEncoderSize10(getBytesEncoder10(), 8).encode(
      new Uint8Array([163, 172, 224, 52, 11, 154, 106, 223])
    ),
    0
  )) {
    return 25 /* UpdateRewardInfos */;
  }
  throw new Error(
    "The provided instruction could not be identified as a ammV3 instruction."
  );
}

// src/generated/errors/ammV3.ts
var AMM_V3_ERROR__L_O_K = 6e3;
var AMM_V3_ERROR__NOT_APPROVED = 6001;
var AMM_V3_ERROR__INVALID_UPDATE_CONFIG_FLAG = 6002;
var AMM_V3_ERROR__ACCOUNT_LACK = 6003;
var AMM_V3_ERROR__CLOSE_POSITION_ERR = 6004;
var AMM_V3_ERROR__ZERO_MINT_AMOUNT = 6005;
var AMM_V3_ERROR__INVALID_TICK_INDEX = 6006;
var AMM_V3_ERROR__TICK_INVALID_ORDER = 6007;
var AMM_V3_ERROR__TICK_LOWER_OVERFLOW = 6008;
var AMM_V3_ERROR__TICK_UPPER_OVERFLOW = 6009;
var AMM_V3_ERROR__TICK_AND_SPACING_NOT_MATCH = 6010;
var AMM_V3_ERROR__INVALID_TICK_ARRAY = 6011;
var AMM_V3_ERROR__INVALID_TICK_ARRAY_BOUNDARY = 6012;
var AMM_V3_ERROR__SQRT_PRICE_LIMIT_OVERFLOW = 6013;
var AMM_V3_ERROR__SQRT_PRICE_X64 = 6014;
var AMM_V3_ERROR__LIQUIDITY_SUB_VALUE_ERR = 6015;
var AMM_V3_ERROR__LIQUIDITY_ADD_VALUE_ERR = 6016;
var AMM_V3_ERROR__INVALID_LIQUIDITY = 6017;
var AMM_V3_ERROR__FORBID_BOTH_ZERO_FOR_SUPPLY_LIQUIDITY = 6018;
var AMM_V3_ERROR__LIQUIDITY_INSUFFICIENT = 6019;
var AMM_V3_ERROR__TRANSACTION_TOO_OLD = 6020;
var AMM_V3_ERROR__PRICE_SLIPPAGE_CHECK = 6021;
var AMM_V3_ERROR__TOO_LITTLE_OUTPUT_RECEIVED = 6022;
var AMM_V3_ERROR__TOO_MUCH_INPUT_PAID = 6023;
var AMM_V3_ERROR__ZERO_AMOUNT_SPECIFIED = 6024;
var AMM_V3_ERROR__INVALID_INPUT_POOL_VAULT = 6025;
var AMM_V3_ERROR__TOO_SMALL_INPUT_OR_OUTPUT_AMOUNT = 6026;
var AMM_V3_ERROR__NOT_ENOUGH_TICK_ARRAY_ACCOUNT = 6027;
var AMM_V3_ERROR__INVALID_FIRST_TICK_ARRAY_ACCOUNT = 6028;
var AMM_V3_ERROR__INVALID_REWARD_INDEX = 6029;
var AMM_V3_ERROR__FULL_REWARD_INFO = 6030;
var AMM_V3_ERROR__REWARD_TOKEN_ALREADY_IN_USE = 6031;
var AMM_V3_ERROR__EXCEPT_REWARD_MINT = 6032;
var AMM_V3_ERROR__INVALID_REWARD_INIT_PARAM = 6033;
var AMM_V3_ERROR__INVALID_REWARD_DESIRED_AMOUNT = 6034;
var AMM_V3_ERROR__INVALID_REWARD_INPUT_ACCOUNT_NUMBER = 6035;
var AMM_V3_ERROR__INVALID_REWARD_PERIOD = 6036;
var AMM_V3_ERROR__NOT_APPROVE_UPDATE_REWARD_EMISSIONES = 6037;
var AMM_V3_ERROR__UN_INITIALIZED_REWARD_INFO = 6038;
var AMM_V3_ERROR__NOT_SUPPORT_MINT = 6039;
var AMM_V3_ERROR__MISSING_TICK_ARRAY_BITMAP_EXTENSION_ACCOUNT = 6040;
var AMM_V3_ERROR__INSUFFICIENT_LIQUIDITY_FOR_DIRECTION = 6041;
var AMM_V3_ERROR__MAX_TOKEN_OVERFLOW = 6042;
var AMM_V3_ERROR__CALCULATE_OVERFLOW = 6043;
var AMM_V3_ERROR__TRANSFER_FEE_CALCULATE_NOT_MATCH = 6044;
var ammV3ErrorMessages;
if (process.env.NODE_ENV !== "production") {
  ammV3ErrorMessages = {
    [AMM_V3_ERROR__ACCOUNT_LACK]: `Account lack`,
    [AMM_V3_ERROR__CALCULATE_OVERFLOW]: `Calculate overflow`,
    [AMM_V3_ERROR__CLOSE_POSITION_ERR]: `Remove liquitity, collect fees owed and reward then you can close position account`,
    [AMM_V3_ERROR__EXCEPT_REWARD_MINT]: `The reward tokens must contain one of pool vault mint except the last reward`,
    [AMM_V3_ERROR__FORBID_BOTH_ZERO_FOR_SUPPLY_LIQUIDITY]: `Both token amount must not be zero while supply liquidity`,
    [AMM_V3_ERROR__FULL_REWARD_INFO]: `The init reward token reach to the max`,
    [AMM_V3_ERROR__INSUFFICIENT_LIQUIDITY_FOR_DIRECTION]: `Insufficient liquidity for this direction`,
    [AMM_V3_ERROR__INVALID_FIRST_TICK_ARRAY_ACCOUNT]: `Invalid first tick array account`,
    [AMM_V3_ERROR__INVALID_INPUT_POOL_VAULT]: `Input pool vault is invalid`,
    [AMM_V3_ERROR__INVALID_LIQUIDITY]: `Invalid liquidity when update position`,
    [AMM_V3_ERROR__INVALID_REWARD_DESIRED_AMOUNT]: `Invalid collect reward desired amount`,
    [AMM_V3_ERROR__INVALID_REWARD_INDEX]: `Invalid reward index`,
    [AMM_V3_ERROR__INVALID_REWARD_INIT_PARAM]: `Invalid reward init param`,
    [AMM_V3_ERROR__INVALID_REWARD_INPUT_ACCOUNT_NUMBER]: `Invalid collect reward input account number`,
    [AMM_V3_ERROR__INVALID_REWARD_PERIOD]: `Invalid reward period`,
    [AMM_V3_ERROR__INVALID_TICK_ARRAY]: `Invalid tick array account`,
    [AMM_V3_ERROR__INVALID_TICK_ARRAY_BOUNDARY]: `Invalid tick array boundary`,
    [AMM_V3_ERROR__INVALID_TICK_INDEX]: `Tick out of range`,
    [AMM_V3_ERROR__INVALID_UPDATE_CONFIG_FLAG]: `invalid update amm config flag`,
    [AMM_V3_ERROR__LIQUIDITY_ADD_VALUE_ERR]: `Liquidity add delta L must be greater, or equal to before`,
    [AMM_V3_ERROR__LIQUIDITY_INSUFFICIENT]: `Liquidity insufficient`,
    [AMM_V3_ERROR__LIQUIDITY_SUB_VALUE_ERR]: `Liquidity sub delta L must be smaller than before`,
    [AMM_V3_ERROR__L_O_K]: `LOK`,
    [AMM_V3_ERROR__MAX_TOKEN_OVERFLOW]: `Max token overflow`,
    [AMM_V3_ERROR__MISSING_TICK_ARRAY_BITMAP_EXTENSION_ACCOUNT]: `Missing tickarray bitmap extension account`,
    [AMM_V3_ERROR__NOT_APPROVED]: `Not approved`,
    [AMM_V3_ERROR__NOT_APPROVE_UPDATE_REWARD_EMISSIONES]: `Modification of emissiones is allowed within 72 hours from the end of the previous cycle`,
    [AMM_V3_ERROR__NOT_ENOUGH_TICK_ARRAY_ACCOUNT]: `Not enought tick array account`,
    [AMM_V3_ERROR__NOT_SUPPORT_MINT]: `Not support token_2022 mint extension`,
    [AMM_V3_ERROR__PRICE_SLIPPAGE_CHECK]: `Price slippage check`,
    [AMM_V3_ERROR__REWARD_TOKEN_ALREADY_IN_USE]: `The init reward token already in use`,
    [AMM_V3_ERROR__SQRT_PRICE_LIMIT_OVERFLOW]: `Square root price limit overflow`,
    [AMM_V3_ERROR__SQRT_PRICE_X64]: `sqrt_price_x64 out of range`,
    [AMM_V3_ERROR__TICK_AND_SPACING_NOT_MATCH]: `tick % tick_spacing must be zero`,
    [AMM_V3_ERROR__TICK_INVALID_ORDER]: `The lower tick must be below the upper tick`,
    [AMM_V3_ERROR__TICK_LOWER_OVERFLOW]: `The tick must be greater, or equal to the minimum tick(-443636)`,
    [AMM_V3_ERROR__TICK_UPPER_OVERFLOW]: `The tick must be lesser than, or equal to the maximum tick(443636)`,
    [AMM_V3_ERROR__TOO_LITTLE_OUTPUT_RECEIVED]: `Too little output received`,
    [AMM_V3_ERROR__TOO_MUCH_INPUT_PAID]: `Too much input paid`,
    [AMM_V3_ERROR__TOO_SMALL_INPUT_OR_OUTPUT_AMOUNT]: `Swap input or output amount is too small`,
    [AMM_V3_ERROR__TRANSACTION_TOO_OLD]: `Transaction too old`,
    [AMM_V3_ERROR__TRANSFER_FEE_CALCULATE_NOT_MATCH]: `TransferFee calculate not match`,
    [AMM_V3_ERROR__UN_INITIALIZED_REWARD_INFO]: `uninitialized reward info`,
    [AMM_V3_ERROR__ZERO_AMOUNT_SPECIFIED]: `Swap special amount can not be zero`,
    [AMM_V3_ERROR__ZERO_MINT_AMOUNT]: `Minting amount should be greater than 0`
  };
}
function getAmmV3ErrorMessage(code) {
  if (process.env.NODE_ENV !== "production") {
    return ammV3ErrorMessages[code];
  }
  return "Error message not available in production bundles.";
}
function isAmmV3Error(error, transactionMessage, code) {
  return isProgramError(
    error,
    transactionMessage,
    AMM_V3_PROGRAM_ADDRESS,
    code
  );
}

// src/generated/instructions/closePosition.ts
import {
  combineCodec as combineCodec25,
  fixDecoderSize as fixDecoderSize10,
  fixEncoderSize as fixEncoderSize11,
  getAddressEncoder as getAddressEncoder20,
  getBytesDecoder as getBytesDecoder10,
  getBytesEncoder as getBytesEncoder11,
  getProgramDerivedAddress,
  getStructDecoder as getStructDecoder25,
  getStructEncoder as getStructEncoder25,
  transformEncoder as transformEncoder10
} from "@solana/kit";

// src/generated/shared/index.ts
import {
  AccountRole,
  isProgramDerivedAddress,
  isTransactionSigner as kitIsTransactionSigner,
  upgradeRoleToSigner
} from "@solana/kit";
function expectSome(value) {
  if (value === null || value === void 0) {
    throw new Error("Expected a value but received null or undefined.");
  }
  return value;
}
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      if (optionalAccountStrategy === "omitted") return;
      return Object.freeze({
        address: programAddress,
        role: AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner(value) {
  return !!value && typeof value === "object" && "address" in value && kitIsTransactionSigner(value);
}

// src/generated/instructions/closePosition.ts
var CLOSE_POSITION_DISCRIMINATOR = new Uint8Array([
  123,
  134,
  81,
  0,
  49,
  68,
  98,
  98
]);
function getClosePositionDiscriminatorBytes() {
  return fixEncoderSize11(getBytesEncoder11(), 8).encode(
    CLOSE_POSITION_DISCRIMINATOR
  );
}
function getClosePositionInstructionDataEncoder() {
  return transformEncoder10(
    getStructEncoder25([["discriminator", fixEncoderSize11(getBytesEncoder11(), 8)]]),
    (value) => ({ ...value, discriminator: CLOSE_POSITION_DISCRIMINATOR })
  );
}
function getClosePositionInstructionDataDecoder() {
  return getStructDecoder25([
    ["discriminator", fixDecoderSize10(getBytesDecoder10(), 8)]
  ]);
}
function getClosePositionInstructionDataCodec() {
  return combineCodec25(
    getClosePositionInstructionDataEncoder(),
    getClosePositionInstructionDataDecoder()
  );
}
async function getClosePositionInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    nftOwner: { value: input.nftOwner ?? null, isWritable: true },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true
    },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.personalPosition.value) {
    accounts.personalPosition.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder11().encode(
          new Uint8Array([112, 111, 115, 105, 116, 105, 111, 110])
        ),
        getAddressEncoder20().encode(
          expectAddress(accounts.positionNftMint.value)
        )
      ]
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.nftOwner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram)
    ],
    data: getClosePositionInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getClosePositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    nftOwner: { value: input.nftOwner ?? null, isWritable: true },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true
    },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.nftOwner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram)
    ],
    data: getClosePositionInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseClosePositionInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      nftOwner: getNextAccount(),
      positionNftMint: getNextAccount(),
      positionNftAccount: getNextAccount(),
      personalPosition: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getClosePositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/closeProtocolPosition.ts
import {
  combineCodec as combineCodec26,
  fixDecoderSize as fixDecoderSize11,
  fixEncoderSize as fixEncoderSize12,
  getBytesDecoder as getBytesDecoder11,
  getBytesEncoder as getBytesEncoder12,
  getStructDecoder as getStructDecoder26,
  getStructEncoder as getStructEncoder26,
  transformEncoder as transformEncoder11
} from "@solana/kit";
var CLOSE_PROTOCOL_POSITION_DISCRIMINATOR = new Uint8Array([
  201,
  117,
  152,
  144,
  85,
  85,
  108,
  178
]);
function getCloseProtocolPositionDiscriminatorBytes() {
  return fixEncoderSize12(getBytesEncoder12(), 8).encode(
    CLOSE_PROTOCOL_POSITION_DISCRIMINATOR
  );
}
function getCloseProtocolPositionInstructionDataEncoder() {
  return transformEncoder11(
    getStructEncoder26([["discriminator", fixEncoderSize12(getBytesEncoder12(), 8)]]),
    (value) => ({
      ...value,
      discriminator: CLOSE_PROTOCOL_POSITION_DISCRIMINATOR
    })
  );
}
function getCloseProtocolPositionInstructionDataDecoder() {
  return getStructDecoder26([
    ["discriminator", fixDecoderSize11(getBytesDecoder11(), 8)]
  ]);
}
function getCloseProtocolPositionInstructionDataCodec() {
  return combineCodec26(
    getCloseProtocolPositionInstructionDataEncoder(),
    getCloseProtocolPositionInstructionDataDecoder()
  );
}
function getCloseProtocolPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    admin: { value: input.admin ?? null, isWritable: true },
    protocolPosition: {
      value: input.protocolPosition ?? null,
      isWritable: true
    }
  };
  const accounts = originalAccounts;
  if (!accounts.admin.value) {
    accounts.admin.value = "AMeGg9qpzv1geQpiEWzhgXempJTuYYZeuLLKX1cYbmaw";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.admin),
      getAccountMeta(accounts.protocolPosition)
    ],
    data: getCloseProtocolPositionInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseCloseProtocolPositionInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { admin: getNextAccount(), protocolPosition: getNextAccount() },
    data: getCloseProtocolPositionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectFundFee.ts
import {
  combineCodec as combineCodec27,
  fixDecoderSize as fixDecoderSize12,
  fixEncoderSize as fixEncoderSize13,
  getBytesDecoder as getBytesDecoder12,
  getBytesEncoder as getBytesEncoder13,
  getStructDecoder as getStructDecoder27,
  getStructEncoder as getStructEncoder27,
  getU64Decoder as getU64Decoder19,
  getU64Encoder as getU64Encoder19,
  transformEncoder as transformEncoder12
} from "@solana/kit";
var COLLECT_FUND_FEE_DISCRIMINATOR = new Uint8Array([
  167,
  138,
  78,
  149,
  223,
  194,
  6,
  126
]);
function getCollectFundFeeDiscriminatorBytes() {
  return fixEncoderSize13(getBytesEncoder13(), 8).encode(
    COLLECT_FUND_FEE_DISCRIMINATOR
  );
}
function getCollectFundFeeInstructionDataEncoder() {
  return transformEncoder12(
    getStructEncoder27([
      ["discriminator", fixEncoderSize13(getBytesEncoder13(), 8)],
      ["amount0Requested", getU64Encoder19()],
      ["amount1Requested", getU64Encoder19()]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_FUND_FEE_DISCRIMINATOR })
  );
}
function getCollectFundFeeInstructionDataDecoder() {
  return getStructDecoder27([
    ["discriminator", fixDecoderSize12(getBytesDecoder12(), 8)],
    ["amount0Requested", getU64Decoder19()],
    ["amount1Requested", getU64Decoder19()]
  ]);
}
function getCollectFundFeeInstructionDataCodec() {
  return combineCodec27(
    getCollectFundFeeInstructionDataEncoder(),
    getCollectFundFeeInstructionDataDecoder()
  );
}
function getCollectFundFeeInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    ammConfig: { value: input.ammConfig ?? null, isWritable: false },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    vault0Mint: { value: input.vault0Mint ?? null, isWritable: false },
    vault1Mint: { value: input.vault1Mint ?? null, isWritable: false },
    recipientTokenAccount0: {
      value: input.recipientTokenAccount0 ?? null,
      isWritable: true
    },
    recipientTokenAccount1: {
      value: input.recipientTokenAccount1 ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.vault0Mint),
      getAccountMeta(accounts.vault1Mint),
      getAccountMeta(accounts.recipientTokenAccount0),
      getAccountMeta(accounts.recipientTokenAccount1),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenProgram2022)
    ],
    data: getCollectFundFeeInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseCollectFundFeeInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      owner: getNextAccount(),
      poolState: getNextAccount(),
      ammConfig: getNextAccount(),
      tokenVault0: getNextAccount(),
      tokenVault1: getNextAccount(),
      vault0Mint: getNextAccount(),
      vault1Mint: getNextAccount(),
      recipientTokenAccount0: getNextAccount(),
      recipientTokenAccount1: getNextAccount(),
      tokenProgram: getNextAccount(),
      tokenProgram2022: getNextAccount()
    },
    data: getCollectFundFeeInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectProtocolFee.ts
import {
  combineCodec as combineCodec28,
  fixDecoderSize as fixDecoderSize13,
  fixEncoderSize as fixEncoderSize14,
  getBytesDecoder as getBytesDecoder13,
  getBytesEncoder as getBytesEncoder14,
  getStructDecoder as getStructDecoder28,
  getStructEncoder as getStructEncoder28,
  getU64Decoder as getU64Decoder20,
  getU64Encoder as getU64Encoder20,
  transformEncoder as transformEncoder13
} from "@solana/kit";
var COLLECT_PROTOCOL_FEE_DISCRIMINATOR = new Uint8Array([
  136,
  136,
  252,
  221,
  194,
  66,
  126,
  89
]);
function getCollectProtocolFeeDiscriminatorBytes() {
  return fixEncoderSize14(getBytesEncoder14(), 8).encode(
    COLLECT_PROTOCOL_FEE_DISCRIMINATOR
  );
}
function getCollectProtocolFeeInstructionDataEncoder() {
  return transformEncoder13(
    getStructEncoder28([
      ["discriminator", fixEncoderSize14(getBytesEncoder14(), 8)],
      ["amount0Requested", getU64Encoder20()],
      ["amount1Requested", getU64Encoder20()]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_PROTOCOL_FEE_DISCRIMINATOR })
  );
}
function getCollectProtocolFeeInstructionDataDecoder() {
  return getStructDecoder28([
    ["discriminator", fixDecoderSize13(getBytesDecoder13(), 8)],
    ["amount0Requested", getU64Decoder20()],
    ["amount1Requested", getU64Decoder20()]
  ]);
}
function getCollectProtocolFeeInstructionDataCodec() {
  return combineCodec28(
    getCollectProtocolFeeInstructionDataEncoder(),
    getCollectProtocolFeeInstructionDataDecoder()
  );
}
function getCollectProtocolFeeInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    ammConfig: { value: input.ammConfig ?? null, isWritable: false },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    vault0Mint: { value: input.vault0Mint ?? null, isWritable: false },
    vault1Mint: { value: input.vault1Mint ?? null, isWritable: false },
    recipientTokenAccount0: {
      value: input.recipientTokenAccount0 ?? null,
      isWritable: true
    },
    recipientTokenAccount1: {
      value: input.recipientTokenAccount1 ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.vault0Mint),
      getAccountMeta(accounts.vault1Mint),
      getAccountMeta(accounts.recipientTokenAccount0),
      getAccountMeta(accounts.recipientTokenAccount1),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenProgram2022)
    ],
    data: getCollectProtocolFeeInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseCollectProtocolFeeInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      owner: getNextAccount(),
      poolState: getNextAccount(),
      ammConfig: getNextAccount(),
      tokenVault0: getNextAccount(),
      tokenVault1: getNextAccount(),
      vault0Mint: getNextAccount(),
      vault1Mint: getNextAccount(),
      recipientTokenAccount0: getNextAccount(),
      recipientTokenAccount1: getNextAccount(),
      tokenProgram: getNextAccount(),
      tokenProgram2022: getNextAccount()
    },
    data: getCollectProtocolFeeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectRemainingRewards.ts
import {
  combineCodec as combineCodec29,
  fixDecoderSize as fixDecoderSize14,
  fixEncoderSize as fixEncoderSize15,
  getBytesDecoder as getBytesDecoder14,
  getBytesEncoder as getBytesEncoder15,
  getStructDecoder as getStructDecoder29,
  getStructEncoder as getStructEncoder29,
  getU8Decoder as getU8Decoder8,
  getU8Encoder as getU8Encoder8,
  transformEncoder as transformEncoder14
} from "@solana/kit";
var COLLECT_REMAINING_REWARDS_DISCRIMINATOR = new Uint8Array([
  18,
  237,
  166,
  197,
  34,
  16,
  213,
  144
]);
function getCollectRemainingRewardsDiscriminatorBytes() {
  return fixEncoderSize15(getBytesEncoder15(), 8).encode(
    COLLECT_REMAINING_REWARDS_DISCRIMINATOR
  );
}
function getCollectRemainingRewardsInstructionDataEncoder() {
  return transformEncoder14(
    getStructEncoder29([
      ["discriminator", fixEncoderSize15(getBytesEncoder15(), 8)],
      ["rewardIndex", getU8Encoder8()]
    ]),
    (value) => ({
      ...value,
      discriminator: COLLECT_REMAINING_REWARDS_DISCRIMINATOR
    })
  );
}
function getCollectRemainingRewardsInstructionDataDecoder() {
  return getStructDecoder29([
    ["discriminator", fixDecoderSize14(getBytesDecoder14(), 8)],
    ["rewardIndex", getU8Decoder8()]
  ]);
}
function getCollectRemainingRewardsInstructionDataCodec() {
  return combineCodec29(
    getCollectRemainingRewardsInstructionDataEncoder(),
    getCollectRemainingRewardsInstructionDataDecoder()
  );
}
function getCollectRemainingRewardsInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    rewardFunder: { value: input.rewardFunder ?? null, isWritable: false },
    funderTokenAccount: {
      value: input.funderTokenAccount ?? null,
      isWritable: true
    },
    poolState: { value: input.poolState ?? null, isWritable: true },
    rewardTokenVault: {
      value: input.rewardTokenVault ?? null,
      isWritable: true
    },
    rewardVaultMint: {
      value: input.rewardVaultMint ?? null,
      isWritable: false
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  if (!accounts.memoProgram.value) {
    accounts.memoProgram.value = "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.rewardFunder),
      getAccountMeta(accounts.funderTokenAccount),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.rewardTokenVault),
      getAccountMeta(accounts.rewardVaultMint),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenProgram2022),
      getAccountMeta(accounts.memoProgram)
    ],
    data: getCollectRemainingRewardsInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseCollectRemainingRewardsInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rewardFunder: getNextAccount(),
      funderTokenAccount: getNextAccount(),
      poolState: getNextAccount(),
      rewardTokenVault: getNextAccount(),
      rewardVaultMint: getNextAccount(),
      tokenProgram: getNextAccount(),
      tokenProgram2022: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectRemainingRewardsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/createAmmConfig.ts
import {
  combineCodec as combineCodec30,
  fixDecoderSize as fixDecoderSize15,
  fixEncoderSize as fixEncoderSize16,
  getBytesDecoder as getBytesDecoder15,
  getBytesEncoder as getBytesEncoder16,
  getProgramDerivedAddress as getProgramDerivedAddress2,
  getStructDecoder as getStructDecoder30,
  getStructEncoder as getStructEncoder30,
  getU16Decoder as getU16Decoder6,
  getU16Encoder as getU16Encoder6,
  getU32Decoder as getU32Decoder5,
  getU32Encoder as getU32Encoder5,
  transformEncoder as transformEncoder15
} from "@solana/kit";
var CREATE_AMM_CONFIG_DISCRIMINATOR = new Uint8Array([
  137,
  52,
  237,
  212,
  215,
  117,
  108,
  104
]);
function getCreateAmmConfigDiscriminatorBytes() {
  return fixEncoderSize16(getBytesEncoder16(), 8).encode(
    CREATE_AMM_CONFIG_DISCRIMINATOR
  );
}
function getCreateAmmConfigInstructionDataEncoder() {
  return transformEncoder15(
    getStructEncoder30([
      ["discriminator", fixEncoderSize16(getBytesEncoder16(), 8)],
      ["index", getU16Encoder6()],
      ["tickSpacing", getU16Encoder6()],
      ["tradeFeeRate", getU32Encoder5()],
      ["protocolFeeRate", getU32Encoder5()],
      ["fundFeeRate", getU32Encoder5()]
    ]),
    (value) => ({ ...value, discriminator: CREATE_AMM_CONFIG_DISCRIMINATOR })
  );
}
function getCreateAmmConfigInstructionDataDecoder() {
  return getStructDecoder30([
    ["discriminator", fixDecoderSize15(getBytesDecoder15(), 8)],
    ["index", getU16Decoder6()],
    ["tickSpacing", getU16Decoder6()],
    ["tradeFeeRate", getU32Decoder5()],
    ["protocolFeeRate", getU32Decoder5()],
    ["fundFeeRate", getU32Decoder5()]
  ]);
}
function getCreateAmmConfigInstructionDataCodec() {
  return combineCodec30(
    getCreateAmmConfigInstructionDataEncoder(),
    getCreateAmmConfigInstructionDataDecoder()
  );
}
async function getCreateAmmConfigInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: true },
    ammConfig: { value: input.ammConfig ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.owner.value) {
    accounts.owner.value = "AMeGg9qpzv1geQpiEWzhgXempJTuYYZeuLLKX1cYbmaw";
  }
  if (!accounts.ammConfig.value) {
    accounts.ammConfig.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder16().encode(
          new Uint8Array([97, 109, 109, 95, 99, 111, 110, 102, 105, 103])
        ),
        getU16Encoder6().encode(expectSome(args.index))
      ]
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.systemProgram)
    ],
    data: getCreateAmmConfigInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function getCreateAmmConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: true },
    ammConfig: { value: input.ammConfig ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.owner.value) {
    accounts.owner.value = "AMeGg9qpzv1geQpiEWzhgXempJTuYYZeuLLKX1cYbmaw";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.systemProgram)
    ],
    data: getCreateAmmConfigInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseCreateAmmConfigInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      owner: getNextAccount(),
      ammConfig: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateAmmConfigInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/createOperationAccount.ts
import {
  combineCodec as combineCodec31,
  fixDecoderSize as fixDecoderSize16,
  fixEncoderSize as fixEncoderSize17,
  getBytesDecoder as getBytesDecoder16,
  getBytesEncoder as getBytesEncoder17,
  getProgramDerivedAddress as getProgramDerivedAddress3,
  getStructDecoder as getStructDecoder31,
  getStructEncoder as getStructEncoder31,
  transformEncoder as transformEncoder16
} from "@solana/kit";
var CREATE_OPERATION_ACCOUNT_DISCRIMINATOR = new Uint8Array([
  63,
  87,
  148,
  33,
  109,
  35,
  8,
  104
]);
function getCreateOperationAccountDiscriminatorBytes() {
  return fixEncoderSize17(getBytesEncoder17(), 8).encode(
    CREATE_OPERATION_ACCOUNT_DISCRIMINATOR
  );
}
function getCreateOperationAccountInstructionDataEncoder() {
  return transformEncoder16(
    getStructEncoder31([["discriminator", fixEncoderSize17(getBytesEncoder17(), 8)]]),
    (value) => ({
      ...value,
      discriminator: CREATE_OPERATION_ACCOUNT_DISCRIMINATOR
    })
  );
}
function getCreateOperationAccountInstructionDataDecoder() {
  return getStructDecoder31([
    ["discriminator", fixDecoderSize16(getBytesDecoder16(), 8)]
  ]);
}
function getCreateOperationAccountInstructionDataCodec() {
  return combineCodec31(
    getCreateOperationAccountInstructionDataEncoder(),
    getCreateOperationAccountInstructionDataDecoder()
  );
}
async function getCreateOperationAccountInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: true },
    operationState: { value: input.operationState ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.owner.value) {
    accounts.owner.value = "AMeGg9qpzv1geQpiEWzhgXempJTuYYZeuLLKX1cYbmaw";
  }
  if (!accounts.operationState.value) {
    accounts.operationState.value = await getProgramDerivedAddress3({
      programAddress,
      seeds: [
        getBytesEncoder17().encode(
          new Uint8Array([111, 112, 101, 114, 97, 116, 105, 111, 110])
        )
      ]
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.operationState),
      getAccountMeta(accounts.systemProgram)
    ],
    data: getCreateOperationAccountInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getCreateOperationAccountInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: true },
    operationState: { value: input.operationState ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.owner.value) {
    accounts.owner.value = "AMeGg9qpzv1geQpiEWzhgXempJTuYYZeuLLKX1cYbmaw";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.operationState),
      getAccountMeta(accounts.systemProgram)
    ],
    data: getCreateOperationAccountInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseCreateOperationAccountInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      owner: getNextAccount(),
      operationState: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateOperationAccountInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/createPool.ts
import {
  combineCodec as combineCodec32,
  fixDecoderSize as fixDecoderSize17,
  fixEncoderSize as fixEncoderSize18,
  getAddressEncoder as getAddressEncoder21,
  getBytesDecoder as getBytesDecoder17,
  getBytesEncoder as getBytesEncoder18,
  getProgramDerivedAddress as getProgramDerivedAddress4,
  getStructDecoder as getStructDecoder32,
  getStructEncoder as getStructEncoder32,
  getU128Decoder as getU128Decoder15,
  getU128Encoder as getU128Encoder15,
  getU64Decoder as getU64Decoder21,
  getU64Encoder as getU64Encoder21,
  transformEncoder as transformEncoder17
} from "@solana/kit";
var CREATE_POOL_DISCRIMINATOR = new Uint8Array([
  233,
  146,
  209,
  142,
  207,
  104,
  64,
  188
]);
function getCreatePoolDiscriminatorBytes() {
  return fixEncoderSize18(getBytesEncoder18(), 8).encode(CREATE_POOL_DISCRIMINATOR);
}
function getCreatePoolInstructionDataEncoder() {
  return transformEncoder17(
    getStructEncoder32([
      ["discriminator", fixEncoderSize18(getBytesEncoder18(), 8)],
      ["sqrtPriceX64", getU128Encoder15()],
      ["openTime", getU64Encoder21()]
    ]),
    (value) => ({ ...value, discriminator: CREATE_POOL_DISCRIMINATOR })
  );
}
function getCreatePoolInstructionDataDecoder() {
  return getStructDecoder32([
    ["discriminator", fixDecoderSize17(getBytesDecoder17(), 8)],
    ["sqrtPriceX64", getU128Decoder15()],
    ["openTime", getU64Decoder21()]
  ]);
}
function getCreatePoolInstructionDataCodec() {
  return combineCodec32(
    getCreatePoolInstructionDataEncoder(),
    getCreatePoolInstructionDataDecoder()
  );
}
async function getCreatePoolInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    poolCreator: { value: input.poolCreator ?? null, isWritable: true },
    ammConfig: { value: input.ammConfig ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    tokenMint0: { value: input.tokenMint0 ?? null, isWritable: false },
    tokenMint1: { value: input.tokenMint1 ?? null, isWritable: false },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    observationState: {
      value: input.observationState ?? null,
      isWritable: true
    },
    tickArrayBitmap: { value: input.tickArrayBitmap ?? null, isWritable: true },
    tokenProgram0: { value: input.tokenProgram0 ?? null, isWritable: false },
    tokenProgram1: { value: input.tokenProgram1 ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.poolState.value) {
    accounts.poolState.value = await getProgramDerivedAddress4({
      programAddress,
      seeds: [
        getBytesEncoder18().encode(new Uint8Array([112, 111, 111, 108])),
        getAddressEncoder21().encode(expectAddress(accounts.ammConfig.value)),
        getAddressEncoder21().encode(expectAddress(accounts.tokenMint0.value)),
        getAddressEncoder21().encode(expectAddress(accounts.tokenMint1.value))
      ]
    });
  }
  if (!accounts.tokenVault0.value) {
    accounts.tokenVault0.value = await getProgramDerivedAddress4({
      programAddress,
      seeds: [
        getBytesEncoder18().encode(
          new Uint8Array([112, 111, 111, 108, 95, 118, 97, 117, 108, 116])
        ),
        getAddressEncoder21().encode(expectAddress(accounts.poolState.value)),
        getAddressEncoder21().encode(expectAddress(accounts.tokenMint0.value))
      ]
    });
  }
  if (!accounts.tokenVault1.value) {
    accounts.tokenVault1.value = await getProgramDerivedAddress4({
      programAddress,
      seeds: [
        getBytesEncoder18().encode(
          new Uint8Array([112, 111, 111, 108, 95, 118, 97, 117, 108, 116])
        ),
        getAddressEncoder21().encode(expectAddress(accounts.poolState.value)),
        getAddressEncoder21().encode(expectAddress(accounts.tokenMint1.value))
      ]
    });
  }
  if (!accounts.observationState.value) {
    accounts.observationState.value = await getProgramDerivedAddress4({
      programAddress,
      seeds: [
        getBytesEncoder18().encode(
          new Uint8Array([111, 98, 115, 101, 114, 118, 97, 116, 105, 111, 110])
        ),
        getAddressEncoder21().encode(expectAddress(accounts.poolState.value))
      ]
    });
  }
  if (!accounts.tickArrayBitmap.value) {
    accounts.tickArrayBitmap.value = await getProgramDerivedAddress4({
      programAddress,
      seeds: [
        getBytesEncoder18().encode(
          new Uint8Array([
            112,
            111,
            111,
            108,
            95,
            116,
            105,
            99,
            107,
            95,
            97,
            114,
            114,
            97,
            121,
            95,
            98,
            105,
            116,
            109,
            97,
            112,
            95,
            101,
            120,
            116,
            101,
            110,
            115,
            105,
            111,
            110
          ])
        ),
        getAddressEncoder21().encode(expectAddress(accounts.poolState.value))
      ]
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.poolCreator),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.tokenMint0),
      getAccountMeta(accounts.tokenMint1),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.observationState),
      getAccountMeta(accounts.tickArrayBitmap),
      getAccountMeta(accounts.tokenProgram0),
      getAccountMeta(accounts.tokenProgram1),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    data: getCreatePoolInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function getCreatePoolInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    poolCreator: { value: input.poolCreator ?? null, isWritable: true },
    ammConfig: { value: input.ammConfig ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    tokenMint0: { value: input.tokenMint0 ?? null, isWritable: false },
    tokenMint1: { value: input.tokenMint1 ?? null, isWritable: false },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    observationState: {
      value: input.observationState ?? null,
      isWritable: true
    },
    tickArrayBitmap: { value: input.tickArrayBitmap ?? null, isWritable: true },
    tokenProgram0: { value: input.tokenProgram0 ?? null, isWritable: false },
    tokenProgram1: { value: input.tokenProgram1 ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.poolCreator),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.tokenMint0),
      getAccountMeta(accounts.tokenMint1),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.observationState),
      getAccountMeta(accounts.tickArrayBitmap),
      getAccountMeta(accounts.tokenProgram0),
      getAccountMeta(accounts.tokenProgram1),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    data: getCreatePoolInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseCreatePoolInstruction(instruction) {
  if (instruction.accounts.length < 13) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      poolCreator: getNextAccount(),
      ammConfig: getNextAccount(),
      poolState: getNextAccount(),
      tokenMint0: getNextAccount(),
      tokenMint1: getNextAccount(),
      tokenVault0: getNextAccount(),
      tokenVault1: getNextAccount(),
      observationState: getNextAccount(),
      tickArrayBitmap: getNextAccount(),
      tokenProgram0: getNextAccount(),
      tokenProgram1: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getCreatePoolInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/createSupportMintAssociated.ts
import {
  combineCodec as combineCodec33,
  fixDecoderSize as fixDecoderSize18,
  fixEncoderSize as fixEncoderSize19,
  getAddressEncoder as getAddressEncoder22,
  getBytesDecoder as getBytesDecoder18,
  getBytesEncoder as getBytesEncoder19,
  getProgramDerivedAddress as getProgramDerivedAddress5,
  getStructDecoder as getStructDecoder33,
  getStructEncoder as getStructEncoder33,
  transformEncoder as transformEncoder18
} from "@solana/kit";
var CREATE_SUPPORT_MINT_ASSOCIATED_DISCRIMINATOR = new Uint8Array([
  17,
  251,
  65,
  92,
  136,
  242,
  14,
  169
]);
function getCreateSupportMintAssociatedDiscriminatorBytes() {
  return fixEncoderSize19(getBytesEncoder19(), 8).encode(
    CREATE_SUPPORT_MINT_ASSOCIATED_DISCRIMINATOR
  );
}
function getCreateSupportMintAssociatedInstructionDataEncoder() {
  return transformEncoder18(
    getStructEncoder33([["discriminator", fixEncoderSize19(getBytesEncoder19(), 8)]]),
    (value) => ({
      ...value,
      discriminator: CREATE_SUPPORT_MINT_ASSOCIATED_DISCRIMINATOR
    })
  );
}
function getCreateSupportMintAssociatedInstructionDataDecoder() {
  return getStructDecoder33([
    ["discriminator", fixDecoderSize18(getBytesDecoder18(), 8)]
  ]);
}
function getCreateSupportMintAssociatedInstructionDataCodec() {
  return combineCodec33(
    getCreateSupportMintAssociatedInstructionDataEncoder(),
    getCreateSupportMintAssociatedInstructionDataDecoder()
  );
}
async function getCreateSupportMintAssociatedInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: true },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    supportMintAssociated: {
      value: input.supportMintAssociated ?? null,
      isWritable: true
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.supportMintAssociated.value) {
    accounts.supportMintAssociated.value = await getProgramDerivedAddress5({
      programAddress,
      seeds: [
        getBytesEncoder19().encode(
          new Uint8Array([
            115,
            117,
            112,
            112,
            111,
            114,
            116,
            95,
            109,
            105,
            110,
            116
          ])
        ),
        getAddressEncoder22().encode(expectAddress(accounts.tokenMint.value))
      ]
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.supportMintAssociated),
      getAccountMeta(accounts.systemProgram)
    ],
    data: getCreateSupportMintAssociatedInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getCreateSupportMintAssociatedInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: true },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    supportMintAssociated: {
      value: input.supportMintAssociated ?? null,
      isWritable: true
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.supportMintAssociated),
      getAccountMeta(accounts.systemProgram)
    ],
    data: getCreateSupportMintAssociatedInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseCreateSupportMintAssociatedInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      owner: getNextAccount(),
      tokenMint: getNextAccount(),
      supportMintAssociated: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateSupportMintAssociatedInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/decreaseLiquidity.ts
import {
  combineCodec as combineCodec34,
  fixDecoderSize as fixDecoderSize19,
  fixEncoderSize as fixEncoderSize20,
  getBytesDecoder as getBytesDecoder19,
  getBytesEncoder as getBytesEncoder20,
  getStructDecoder as getStructDecoder34,
  getStructEncoder as getStructEncoder34,
  getU128Decoder as getU128Decoder16,
  getU128Encoder as getU128Encoder16,
  getU64Decoder as getU64Decoder22,
  getU64Encoder as getU64Encoder22,
  transformEncoder as transformEncoder19
} from "@solana/kit";
var DECREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([
  160,
  38,
  208,
  111,
  104,
  91,
  44,
  1
]);
function getDecreaseLiquidityDiscriminatorBytes() {
  return fixEncoderSize20(getBytesEncoder20(), 8).encode(
    DECREASE_LIQUIDITY_DISCRIMINATOR
  );
}
function getDecreaseLiquidityInstructionDataEncoder() {
  return transformEncoder19(
    getStructEncoder34([
      ["discriminator", fixEncoderSize20(getBytesEncoder20(), 8)],
      ["liquidity", getU128Encoder16()],
      ["amount0Min", getU64Encoder22()],
      ["amount1Min", getU64Encoder22()]
    ]),
    (value) => ({ ...value, discriminator: DECREASE_LIQUIDITY_DISCRIMINATOR })
  );
}
function getDecreaseLiquidityInstructionDataDecoder() {
  return getStructDecoder34([
    ["discriminator", fixDecoderSize19(getBytesDecoder19(), 8)],
    ["liquidity", getU128Decoder16()],
    ["amount0Min", getU64Decoder22()],
    ["amount1Min", getU64Decoder22()]
  ]);
}
function getDecreaseLiquidityInstructionDataCodec() {
  return combineCodec34(
    getDecreaseLiquidityInstructionDataEncoder(),
    getDecreaseLiquidityInstructionDataDecoder()
  );
}
function getDecreaseLiquidityInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    nftOwner: { value: input.nftOwner ?? null, isWritable: false },
    nftAccount: { value: input.nftAccount ?? null, isWritable: false },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    poolState: { value: input.poolState ?? null, isWritable: true },
    protocolPosition: {
      value: input.protocolPosition ?? null,
      isWritable: false
    },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },
    recipientTokenAccount0: {
      value: input.recipientTokenAccount0 ?? null,
      isWritable: true
    },
    recipientTokenAccount1: {
      value: input.recipientTokenAccount1 ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.nftOwner),
      getAccountMeta(accounts.nftAccount),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.protocolPosition),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper),
      getAccountMeta(accounts.recipientTokenAccount0),
      getAccountMeta(accounts.recipientTokenAccount1),
      getAccountMeta(accounts.tokenProgram)
    ],
    data: getDecreaseLiquidityInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseDecreaseLiquidityInstruction(instruction) {
  if (instruction.accounts.length < 12) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      nftOwner: getNextAccount(),
      nftAccount: getNextAccount(),
      personalPosition: getNextAccount(),
      poolState: getNextAccount(),
      protocolPosition: getNextAccount(),
      tokenVault0: getNextAccount(),
      tokenVault1: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount(),
      recipientTokenAccount0: getNextAccount(),
      recipientTokenAccount1: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getDecreaseLiquidityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/decreaseLiquidityV2.ts
import {
  combineCodec as combineCodec35,
  fixDecoderSize as fixDecoderSize20,
  fixEncoderSize as fixEncoderSize21,
  getBytesDecoder as getBytesDecoder20,
  getBytesEncoder as getBytesEncoder21,
  getStructDecoder as getStructDecoder35,
  getStructEncoder as getStructEncoder35,
  getU128Decoder as getU128Decoder17,
  getU128Encoder as getU128Encoder17,
  getU64Decoder as getU64Decoder23,
  getU64Encoder as getU64Encoder23,
  transformEncoder as transformEncoder20
} from "@solana/kit";
var DECREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([
  58,
  127,
  188,
  62,
  79,
  82,
  196,
  96
]);
function getDecreaseLiquidityV2DiscriminatorBytes() {
  return fixEncoderSize21(getBytesEncoder21(), 8).encode(
    DECREASE_LIQUIDITY_V2_DISCRIMINATOR
  );
}
function getDecreaseLiquidityV2InstructionDataEncoder() {
  return transformEncoder20(
    getStructEncoder35([
      ["discriminator", fixEncoderSize21(getBytesEncoder21(), 8)],
      ["liquidity", getU128Encoder17()],
      ["amount0Min", getU64Encoder23()],
      ["amount1Min", getU64Encoder23()]
    ]),
    (value) => ({
      ...value,
      discriminator: DECREASE_LIQUIDITY_V2_DISCRIMINATOR
    })
  );
}
function getDecreaseLiquidityV2InstructionDataDecoder() {
  return getStructDecoder35([
    ["discriminator", fixDecoderSize20(getBytesDecoder20(), 8)],
    ["liquidity", getU128Decoder17()],
    ["amount0Min", getU64Decoder23()],
    ["amount1Min", getU64Decoder23()]
  ]);
}
function getDecreaseLiquidityV2InstructionDataCodec() {
  return combineCodec35(
    getDecreaseLiquidityV2InstructionDataEncoder(),
    getDecreaseLiquidityV2InstructionDataDecoder()
  );
}
function getDecreaseLiquidityV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    nftOwner: { value: input.nftOwner ?? null, isWritable: false },
    nftAccount: { value: input.nftAccount ?? null, isWritable: false },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    poolState: { value: input.poolState ?? null, isWritable: true },
    protocolPosition: {
      value: input.protocolPosition ?? null,
      isWritable: false
    },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },
    recipientTokenAccount0: {
      value: input.recipientTokenAccount0 ?? null,
      isWritable: true
    },
    recipientTokenAccount1: {
      value: input.recipientTokenAccount1 ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    vault0Mint: { value: input.vault0Mint ?? null, isWritable: false },
    vault1Mint: { value: input.vault1Mint ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  if (!accounts.memoProgram.value) {
    accounts.memoProgram.value = "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.nftOwner),
      getAccountMeta(accounts.nftAccount),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.protocolPosition),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper),
      getAccountMeta(accounts.recipientTokenAccount0),
      getAccountMeta(accounts.recipientTokenAccount1),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenProgram2022),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.vault0Mint),
      getAccountMeta(accounts.vault1Mint)
    ],
    data: getDecreaseLiquidityV2InstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseDecreaseLiquidityV2Instruction(instruction) {
  if (instruction.accounts.length < 16) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      nftOwner: getNextAccount(),
      nftAccount: getNextAccount(),
      personalPosition: getNextAccount(),
      poolState: getNextAccount(),
      protocolPosition: getNextAccount(),
      tokenVault0: getNextAccount(),
      tokenVault1: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount(),
      recipientTokenAccount0: getNextAccount(),
      recipientTokenAccount1: getNextAccount(),
      tokenProgram: getNextAccount(),
      tokenProgram2022: getNextAccount(),
      memoProgram: getNextAccount(),
      vault0Mint: getNextAccount(),
      vault1Mint: getNextAccount()
    },
    data: getDecreaseLiquidityV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/increaseLiquidity.ts
import {
  combineCodec as combineCodec36,
  fixDecoderSize as fixDecoderSize21,
  fixEncoderSize as fixEncoderSize22,
  getBytesDecoder as getBytesDecoder21,
  getBytesEncoder as getBytesEncoder22,
  getStructDecoder as getStructDecoder36,
  getStructEncoder as getStructEncoder36,
  getU128Decoder as getU128Decoder18,
  getU128Encoder as getU128Encoder18,
  getU64Decoder as getU64Decoder24,
  getU64Encoder as getU64Encoder24,
  transformEncoder as transformEncoder21
} from "@solana/kit";
var INCREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([
  46,
  156,
  243,
  118,
  13,
  205,
  251,
  178
]);
function getIncreaseLiquidityDiscriminatorBytes() {
  return fixEncoderSize22(getBytesEncoder22(), 8).encode(
    INCREASE_LIQUIDITY_DISCRIMINATOR
  );
}
function getIncreaseLiquidityInstructionDataEncoder() {
  return transformEncoder21(
    getStructEncoder36([
      ["discriminator", fixEncoderSize22(getBytesEncoder22(), 8)],
      ["liquidity", getU128Encoder18()],
      ["amount0Max", getU64Encoder24()],
      ["amount1Max", getU64Encoder24()]
    ]),
    (value) => ({ ...value, discriminator: INCREASE_LIQUIDITY_DISCRIMINATOR })
  );
}
function getIncreaseLiquidityInstructionDataDecoder() {
  return getStructDecoder36([
    ["discriminator", fixDecoderSize21(getBytesDecoder21(), 8)],
    ["liquidity", getU128Decoder18()],
    ["amount0Max", getU64Decoder24()],
    ["amount1Max", getU64Decoder24()]
  ]);
}
function getIncreaseLiquidityInstructionDataCodec() {
  return combineCodec36(
    getIncreaseLiquidityInstructionDataEncoder(),
    getIncreaseLiquidityInstructionDataDecoder()
  );
}
function getIncreaseLiquidityInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    nftOwner: { value: input.nftOwner ?? null, isWritable: false },
    nftAccount: { value: input.nftAccount ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    protocolPosition: {
      value: input.protocolPosition ?? null,
      isWritable: false
    },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },
    tokenAccount0: { value: input.tokenAccount0 ?? null, isWritable: true },
    tokenAccount1: { value: input.tokenAccount1 ?? null, isWritable: true },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.nftOwner),
      getAccountMeta(accounts.nftAccount),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.protocolPosition),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper),
      getAccountMeta(accounts.tokenAccount0),
      getAccountMeta(accounts.tokenAccount1),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.tokenProgram)
    ],
    data: getIncreaseLiquidityInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseIncreaseLiquidityInstruction(instruction) {
  if (instruction.accounts.length < 12) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      nftOwner: getNextAccount(),
      nftAccount: getNextAccount(),
      poolState: getNextAccount(),
      protocolPosition: getNextAccount(),
      personalPosition: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount(),
      tokenAccount0: getNextAccount(),
      tokenAccount1: getNextAccount(),
      tokenVault0: getNextAccount(),
      tokenVault1: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getIncreaseLiquidityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/increaseLiquidityV2.ts
import {
  combineCodec as combineCodec37,
  fixDecoderSize as fixDecoderSize22,
  fixEncoderSize as fixEncoderSize23,
  getBooleanDecoder as getBooleanDecoder3,
  getBooleanEncoder as getBooleanEncoder3,
  getBytesDecoder as getBytesDecoder22,
  getBytesEncoder as getBytesEncoder23,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder as getStructDecoder37,
  getStructEncoder as getStructEncoder37,
  getU128Decoder as getU128Decoder19,
  getU128Encoder as getU128Encoder19,
  getU64Decoder as getU64Decoder25,
  getU64Encoder as getU64Encoder25,
  transformEncoder as transformEncoder22
} from "@solana/kit";
var INCREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([
  133,
  29,
  89,
  223,
  69,
  238,
  176,
  10
]);
function getIncreaseLiquidityV2DiscriminatorBytes() {
  return fixEncoderSize23(getBytesEncoder23(), 8).encode(
    INCREASE_LIQUIDITY_V2_DISCRIMINATOR
  );
}
function getIncreaseLiquidityV2InstructionDataEncoder() {
  return transformEncoder22(
    getStructEncoder37([
      ["discriminator", fixEncoderSize23(getBytesEncoder23(), 8)],
      ["liquidity", getU128Encoder19()],
      ["amount0Max", getU64Encoder25()],
      ["amount1Max", getU64Encoder25()],
      ["baseFlag", getOptionEncoder(getBooleanEncoder3())]
    ]),
    (value) => ({
      ...value,
      discriminator: INCREASE_LIQUIDITY_V2_DISCRIMINATOR
    })
  );
}
function getIncreaseLiquidityV2InstructionDataDecoder() {
  return getStructDecoder37([
    ["discriminator", fixDecoderSize22(getBytesDecoder22(), 8)],
    ["liquidity", getU128Decoder19()],
    ["amount0Max", getU64Decoder25()],
    ["amount1Max", getU64Decoder25()],
    ["baseFlag", getOptionDecoder(getBooleanDecoder3())]
  ]);
}
function getIncreaseLiquidityV2InstructionDataCodec() {
  return combineCodec37(
    getIncreaseLiquidityV2InstructionDataEncoder(),
    getIncreaseLiquidityV2InstructionDataDecoder()
  );
}
function getIncreaseLiquidityV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    nftOwner: { value: input.nftOwner ?? null, isWritable: false },
    nftAccount: { value: input.nftAccount ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    protocolPosition: {
      value: input.protocolPosition ?? null,
      isWritable: false
    },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },
    tokenAccount0: { value: input.tokenAccount0 ?? null, isWritable: true },
    tokenAccount1: { value: input.tokenAccount1 ?? null, isWritable: true },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    },
    vault0Mint: { value: input.vault0Mint ?? null, isWritable: false },
    vault1Mint: { value: input.vault1Mint ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.nftOwner),
      getAccountMeta(accounts.nftAccount),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.protocolPosition),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper),
      getAccountMeta(accounts.tokenAccount0),
      getAccountMeta(accounts.tokenAccount1),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenProgram2022),
      getAccountMeta(accounts.vault0Mint),
      getAccountMeta(accounts.vault1Mint)
    ],
    data: getIncreaseLiquidityV2InstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseIncreaseLiquidityV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      nftOwner: getNextAccount(),
      nftAccount: getNextAccount(),
      poolState: getNextAccount(),
      protocolPosition: getNextAccount(),
      personalPosition: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount(),
      tokenAccount0: getNextAccount(),
      tokenAccount1: getNextAccount(),
      tokenVault0: getNextAccount(),
      tokenVault1: getNextAccount(),
      tokenProgram: getNextAccount(),
      tokenProgram2022: getNextAccount(),
      vault0Mint: getNextAccount(),
      vault1Mint: getNextAccount()
    },
    data: getIncreaseLiquidityV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeReward.ts
import {
  combineCodec as combineCodec38,
  fixDecoderSize as fixDecoderSize23,
  fixEncoderSize as fixEncoderSize24,
  getAddressEncoder as getAddressEncoder23,
  getBytesDecoder as getBytesDecoder23,
  getBytesEncoder as getBytesEncoder24,
  getProgramDerivedAddress as getProgramDerivedAddress6,
  getStructDecoder as getStructDecoder38,
  getStructEncoder as getStructEncoder38,
  getU128Decoder as getU128Decoder20,
  getU128Encoder as getU128Encoder20,
  getU64Decoder as getU64Decoder26,
  getU64Encoder as getU64Encoder26,
  transformEncoder as transformEncoder23
} from "@solana/kit";
var INITIALIZE_REWARD_DISCRIMINATOR = new Uint8Array([
  95,
  135,
  192,
  196,
  242,
  129,
  230,
  68
]);
function getInitializeRewardDiscriminatorBytes() {
  return fixEncoderSize24(getBytesEncoder24(), 8).encode(
    INITIALIZE_REWARD_DISCRIMINATOR
  );
}
function getInitializeRewardInstructionDataEncoder() {
  return transformEncoder23(
    getStructEncoder38([
      ["discriminator", fixEncoderSize24(getBytesEncoder24(), 8)],
      ["openTime", getU64Encoder26()],
      ["endTime", getU64Encoder26()],
      ["emissionsPerSecondX64", getU128Encoder20()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_REWARD_DISCRIMINATOR })
  );
}
function getInitializeRewardInstructionDataDecoder() {
  return getStructDecoder38([
    ["discriminator", fixDecoderSize23(getBytesDecoder23(), 8)],
    ["openTime", getU64Decoder26()],
    ["endTime", getU64Decoder26()],
    ["emissionsPerSecondX64", getU128Decoder20()]
  ]);
}
function getInitializeRewardInstructionDataCodec() {
  return combineCodec38(
    getInitializeRewardInstructionDataEncoder(),
    getInitializeRewardInstructionDataDecoder()
  );
}
async function getInitializeRewardInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    rewardFunder: { value: input.rewardFunder ?? null, isWritable: true },
    funderTokenAccount: {
      value: input.funderTokenAccount ?? null,
      isWritable: true
    },
    ammConfig: { value: input.ammConfig ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    operationState: { value: input.operationState ?? null, isWritable: false },
    rewardTokenMint: {
      value: input.rewardTokenMint ?? null,
      isWritable: false
    },
    rewardTokenVault: {
      value: input.rewardTokenVault ?? null,
      isWritable: true
    },
    rewardTokenProgram: {
      value: input.rewardTokenProgram ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.operationState.value) {
    accounts.operationState.value = await getProgramDerivedAddress6({
      programAddress,
      seeds: [
        getBytesEncoder24().encode(
          new Uint8Array([111, 112, 101, 114, 97, 116, 105, 111, 110])
        )
      ]
    });
  }
  if (!accounts.rewardTokenVault.value) {
    accounts.rewardTokenVault.value = await getProgramDerivedAddress6({
      programAddress,
      seeds: [
        getBytesEncoder24().encode(
          new Uint8Array([
            112,
            111,
            111,
            108,
            95,
            114,
            101,
            119,
            97,
            114,
            100,
            95,
            118,
            97,
            117,
            108,
            116
          ])
        ),
        getAddressEncoder23().encode(expectAddress(accounts.poolState.value)),
        getAddressEncoder23().encode(
          expectAddress(accounts.rewardTokenMint.value)
        )
      ]
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.rewardFunder),
      getAccountMeta(accounts.funderTokenAccount),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.operationState),
      getAccountMeta(accounts.rewardTokenMint),
      getAccountMeta(accounts.rewardTokenVault),
      getAccountMeta(accounts.rewardTokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    data: getInitializeRewardInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function getInitializeRewardInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    rewardFunder: { value: input.rewardFunder ?? null, isWritable: true },
    funderTokenAccount: {
      value: input.funderTokenAccount ?? null,
      isWritable: true
    },
    ammConfig: { value: input.ammConfig ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    operationState: { value: input.operationState ?? null, isWritable: false },
    rewardTokenMint: {
      value: input.rewardTokenMint ?? null,
      isWritable: false
    },
    rewardTokenVault: {
      value: input.rewardTokenVault ?? null,
      isWritable: true
    },
    rewardTokenProgram: {
      value: input.rewardTokenProgram ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.rewardFunder),
      getAccountMeta(accounts.funderTokenAccount),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.operationState),
      getAccountMeta(accounts.rewardTokenMint),
      getAccountMeta(accounts.rewardTokenVault),
      getAccountMeta(accounts.rewardTokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    data: getInitializeRewardInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseInitializeRewardInstruction(instruction) {
  if (instruction.accounts.length < 10) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rewardFunder: getNextAccount(),
      funderTokenAccount: getNextAccount(),
      ammConfig: getNextAccount(),
      poolState: getNextAccount(),
      operationState: getNextAccount(),
      rewardTokenMint: getNextAccount(),
      rewardTokenVault: getNextAccount(),
      rewardTokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeRewardInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/openPosition.ts
import {
  combineCodec as combineCodec39,
  fixDecoderSize as fixDecoderSize24,
  fixEncoderSize as fixEncoderSize25,
  getAddressEncoder as getAddressEncoder24,
  getBytesDecoder as getBytesDecoder24,
  getBytesEncoder as getBytesEncoder25,
  getI32Decoder as getI32Decoder11,
  getI32Encoder as getI32Encoder11,
  getProgramDerivedAddress as getProgramDerivedAddress7,
  getStructDecoder as getStructDecoder39,
  getStructEncoder as getStructEncoder39,
  getU128Decoder as getU128Decoder21,
  getU128Encoder as getU128Encoder21,
  getU64Decoder as getU64Decoder27,
  getU64Encoder as getU64Encoder27,
  transformEncoder as transformEncoder24
} from "@solana/kit";
var OPEN_POSITION_DISCRIMINATOR = new Uint8Array([
  135,
  128,
  47,
  77,
  15,
  152,
  240,
  49
]);
function getOpenPositionDiscriminatorBytes() {
  return fixEncoderSize25(getBytesEncoder25(), 8).encode(
    OPEN_POSITION_DISCRIMINATOR
  );
}
function getOpenPositionInstructionDataEncoder() {
  return transformEncoder24(
    getStructEncoder39([
      ["discriminator", fixEncoderSize25(getBytesEncoder25(), 8)],
      ["tickLowerIndex", getI32Encoder11()],
      ["tickUpperIndex", getI32Encoder11()],
      ["tickArrayLowerStartIndex", getI32Encoder11()],
      ["tickArrayUpperStartIndex", getI32Encoder11()],
      ["liquidity", getU128Encoder21()],
      ["amount0Max", getU64Encoder27()],
      ["amount1Max", getU64Encoder27()]
    ]),
    (value) => ({ ...value, discriminator: OPEN_POSITION_DISCRIMINATOR })
  );
}
function getOpenPositionInstructionDataDecoder() {
  return getStructDecoder39([
    ["discriminator", fixDecoderSize24(getBytesDecoder24(), 8)],
    ["tickLowerIndex", getI32Decoder11()],
    ["tickUpperIndex", getI32Decoder11()],
    ["tickArrayLowerStartIndex", getI32Decoder11()],
    ["tickArrayUpperStartIndex", getI32Decoder11()],
    ["liquidity", getU128Decoder21()],
    ["amount0Max", getU64Decoder27()],
    ["amount1Max", getU64Decoder27()]
  ]);
}
function getOpenPositionInstructionDataCodec() {
  return combineCodec39(
    getOpenPositionInstructionDataEncoder(),
    getOpenPositionInstructionDataDecoder()
  );
}
async function getOpenPositionInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    positionNftOwner: {
      value: input.positionNftOwner ?? null,
      isWritable: false
    },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true
    },
    metadataAccount: { value: input.metadataAccount ?? null, isWritable: true },
    poolState: { value: input.poolState ?? null, isWritable: true },
    protocolPosition: {
      value: input.protocolPosition ?? null,
      isWritable: false
    },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    tokenAccount0: { value: input.tokenAccount0 ?? null, isWritable: true },
    tokenAccount1: { value: input.tokenAccount1 ?? null, isWritable: true },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    rent: { value: input.rent ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.positionNftAccount.value) {
    accounts.positionNftAccount.value = await getProgramDerivedAddress7({
      programAddress: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
      seeds: [
        getAddressEncoder24().encode(
          expectAddress(accounts.positionNftOwner.value)
        ),
        getBytesEncoder25().encode(
          new Uint8Array([
            6,
            221,
            246,
            225,
            215,
            101,
            161,
            147,
            217,
            203,
            225,
            70,
            206,
            235,
            121,
            172,
            28,
            180,
            133,
            237,
            95,
            91,
            55,
            145,
            58,
            140,
            245,
            133,
            126,
            255,
            0,
            169
          ])
        ),
        getAddressEncoder24().encode(
          expectAddress(accounts.positionNftMint.value)
        )
      ]
    });
  }
  if (!accounts.tickArrayLower.value) {
    accounts.tickArrayLower.value = await getProgramDerivedAddress7({
      programAddress,
      seeds: [
        getBytesEncoder25().encode(
          new Uint8Array([116, 105, 99, 107, 95, 97, 114, 114, 97, 121])
        ),
        getAddressEncoder24().encode(expectAddress(accounts.poolState.value)),
        getI32Encoder11().encode(expectSome(args.tickArrayLowerStartIndex))
      ]
    });
  }
  if (!accounts.tickArrayUpper.value) {
    accounts.tickArrayUpper.value = await getProgramDerivedAddress7({
      programAddress,
      seeds: [
        getBytesEncoder25().encode(
          new Uint8Array([116, 105, 99, 107, 95, 97, 114, 114, 97, 121])
        ),
        getAddressEncoder24().encode(expectAddress(accounts.poolState.value)),
        getI32Encoder11().encode(expectSome(args.tickArrayUpperStartIndex))
      ]
    });
  }
  if (!accounts.personalPosition.value) {
    accounts.personalPosition.value = await getProgramDerivedAddress7({
      programAddress,
      seeds: [
        getBytesEncoder25().encode(
          new Uint8Array([112, 111, 115, 105, 116, 105, 111, 110])
        ),
        getAddressEncoder24().encode(
          expectAddress(accounts.positionNftMint.value)
        )
      ]
    });
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
  }
  if (!accounts.metadataProgram.value) {
    accounts.metadataProgram.value = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.positionNftOwner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.metadataAccount),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.protocolPosition),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.tokenAccount0),
      getAccountMeta(accounts.tokenAccount1),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram)
    ],
    data: getOpenPositionInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function getOpenPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    positionNftOwner: {
      value: input.positionNftOwner ?? null,
      isWritable: false
    },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true
    },
    metadataAccount: { value: input.metadataAccount ?? null, isWritable: true },
    poolState: { value: input.poolState ?? null, isWritable: true },
    protocolPosition: {
      value: input.protocolPosition ?? null,
      isWritable: false
    },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    tokenAccount0: { value: input.tokenAccount0 ?? null, isWritable: true },
    tokenAccount1: { value: input.tokenAccount1 ?? null, isWritable: true },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    rent: { value: input.rent ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
  }
  if (!accounts.metadataProgram.value) {
    accounts.metadataProgram.value = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.positionNftOwner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.metadataAccount),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.protocolPosition),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.tokenAccount0),
      getAccountMeta(accounts.tokenAccount1),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram)
    ],
    data: getOpenPositionInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseOpenPositionInstruction(instruction) {
  if (instruction.accounts.length < 19) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      positionNftOwner: getNextAccount(),
      positionNftMint: getNextAccount(),
      positionNftAccount: getNextAccount(),
      metadataAccount: getNextAccount(),
      poolState: getNextAccount(),
      protocolPosition: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount(),
      personalPosition: getNextAccount(),
      tokenAccount0: getNextAccount(),
      tokenAccount1: getNextAccount(),
      tokenVault0: getNextAccount(),
      tokenVault1: getNextAccount(),
      rent: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataProgram: getNextAccount()
    },
    data: getOpenPositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/openPositionV2.ts
import {
  combineCodec as combineCodec40,
  fixDecoderSize as fixDecoderSize25,
  fixEncoderSize as fixEncoderSize26,
  getAddressEncoder as getAddressEncoder25,
  getBooleanDecoder as getBooleanDecoder4,
  getBooleanEncoder as getBooleanEncoder4,
  getBytesDecoder as getBytesDecoder25,
  getBytesEncoder as getBytesEncoder26,
  getI32Decoder as getI32Decoder12,
  getI32Encoder as getI32Encoder12,
  getOptionDecoder as getOptionDecoder2,
  getOptionEncoder as getOptionEncoder2,
  getProgramDerivedAddress as getProgramDerivedAddress8,
  getStructDecoder as getStructDecoder40,
  getStructEncoder as getStructEncoder40,
  getU128Decoder as getU128Decoder22,
  getU128Encoder as getU128Encoder22,
  getU64Decoder as getU64Decoder28,
  getU64Encoder as getU64Encoder28,
  transformEncoder as transformEncoder25
} from "@solana/kit";
var OPEN_POSITION_V2_DISCRIMINATOR = new Uint8Array([
  77,
  184,
  74,
  214,
  112,
  86,
  241,
  199
]);
function getOpenPositionV2DiscriminatorBytes() {
  return fixEncoderSize26(getBytesEncoder26(), 8).encode(
    OPEN_POSITION_V2_DISCRIMINATOR
  );
}
function getOpenPositionV2InstructionDataEncoder() {
  return transformEncoder25(
    getStructEncoder40([
      ["discriminator", fixEncoderSize26(getBytesEncoder26(), 8)],
      ["tickLowerIndex", getI32Encoder12()],
      ["tickUpperIndex", getI32Encoder12()],
      ["tickArrayLowerStartIndex", getI32Encoder12()],
      ["tickArrayUpperStartIndex", getI32Encoder12()],
      ["liquidity", getU128Encoder22()],
      ["amount0Max", getU64Encoder28()],
      ["amount1Max", getU64Encoder28()],
      ["withMetadata", getBooleanEncoder4()],
      ["baseFlag", getOptionEncoder2(getBooleanEncoder4())]
    ]),
    (value) => ({ ...value, discriminator: OPEN_POSITION_V2_DISCRIMINATOR })
  );
}
function getOpenPositionV2InstructionDataDecoder() {
  return getStructDecoder40([
    ["discriminator", fixDecoderSize25(getBytesDecoder25(), 8)],
    ["tickLowerIndex", getI32Decoder12()],
    ["tickUpperIndex", getI32Decoder12()],
    ["tickArrayLowerStartIndex", getI32Decoder12()],
    ["tickArrayUpperStartIndex", getI32Decoder12()],
    ["liquidity", getU128Decoder22()],
    ["amount0Max", getU64Decoder28()],
    ["amount1Max", getU64Decoder28()],
    ["withMetadata", getBooleanDecoder4()],
    ["baseFlag", getOptionDecoder2(getBooleanDecoder4())]
  ]);
}
function getOpenPositionV2InstructionDataCodec() {
  return combineCodec40(
    getOpenPositionV2InstructionDataEncoder(),
    getOpenPositionV2InstructionDataDecoder()
  );
}
async function getOpenPositionV2InstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    positionNftOwner: {
      value: input.positionNftOwner ?? null,
      isWritable: false
    },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true
    },
    metadataAccount: { value: input.metadataAccount ?? null, isWritable: true },
    poolState: { value: input.poolState ?? null, isWritable: true },
    protocolPosition: {
      value: input.protocolPosition ?? null,
      isWritable: false
    },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    tokenAccount0: { value: input.tokenAccount0 ?? null, isWritable: true },
    tokenAccount1: { value: input.tokenAccount1 ?? null, isWritable: true },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    rent: { value: input.rent ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    },
    vault0Mint: { value: input.vault0Mint ?? null, isWritable: false },
    vault1Mint: { value: input.vault1Mint ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.positionNftAccount.value) {
    accounts.positionNftAccount.value = await getProgramDerivedAddress8({
      programAddress: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
      seeds: [
        getAddressEncoder25().encode(
          expectAddress(accounts.positionNftOwner.value)
        ),
        getBytesEncoder26().encode(
          new Uint8Array([
            6,
            221,
            246,
            225,
            215,
            101,
            161,
            147,
            217,
            203,
            225,
            70,
            206,
            235,
            121,
            172,
            28,
            180,
            133,
            237,
            95,
            91,
            55,
            145,
            58,
            140,
            245,
            133,
            126,
            255,
            0,
            169
          ])
        ),
        getAddressEncoder25().encode(
          expectAddress(accounts.positionNftMint.value)
        )
      ]
    });
  }
  if (!accounts.tickArrayLower.value) {
    accounts.tickArrayLower.value = await getProgramDerivedAddress8({
      programAddress,
      seeds: [
        getBytesEncoder26().encode(
          new Uint8Array([116, 105, 99, 107, 95, 97, 114, 114, 97, 121])
        ),
        getAddressEncoder25().encode(expectAddress(accounts.poolState.value)),
        getI32Encoder12().encode(expectSome(args.tickArrayLowerStartIndex))
      ]
    });
  }
  if (!accounts.tickArrayUpper.value) {
    accounts.tickArrayUpper.value = await getProgramDerivedAddress8({
      programAddress,
      seeds: [
        getBytesEncoder26().encode(
          new Uint8Array([116, 105, 99, 107, 95, 97, 114, 114, 97, 121])
        ),
        getAddressEncoder25().encode(expectAddress(accounts.poolState.value)),
        getI32Encoder12().encode(expectSome(args.tickArrayUpperStartIndex))
      ]
    });
  }
  if (!accounts.personalPosition.value) {
    accounts.personalPosition.value = await getProgramDerivedAddress8({
      programAddress,
      seeds: [
        getBytesEncoder26().encode(
          new Uint8Array([112, 111, 115, 105, 116, 105, 111, 110])
        ),
        getAddressEncoder25().encode(
          expectAddress(accounts.positionNftMint.value)
        )
      ]
    });
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
  }
  if (!accounts.metadataProgram.value) {
    accounts.metadataProgram.value = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.positionNftOwner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.metadataAccount),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.protocolPosition),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.tokenAccount0),
      getAccountMeta(accounts.tokenAccount1),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram),
      getAccountMeta(accounts.tokenProgram2022),
      getAccountMeta(accounts.vault0Mint),
      getAccountMeta(accounts.vault1Mint)
    ],
    data: getOpenPositionV2InstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function getOpenPositionV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    positionNftOwner: {
      value: input.positionNftOwner ?? null,
      isWritable: false
    },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true
    },
    metadataAccount: { value: input.metadataAccount ?? null, isWritable: true },
    poolState: { value: input.poolState ?? null, isWritable: true },
    protocolPosition: {
      value: input.protocolPosition ?? null,
      isWritable: false
    },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    tokenAccount0: { value: input.tokenAccount0 ?? null, isWritable: true },
    tokenAccount1: { value: input.tokenAccount1 ?? null, isWritable: true },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    rent: { value: input.rent ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    },
    vault0Mint: { value: input.vault0Mint ?? null, isWritable: false },
    vault1Mint: { value: input.vault1Mint ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
  }
  if (!accounts.metadataProgram.value) {
    accounts.metadataProgram.value = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.positionNftOwner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.metadataAccount),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.protocolPosition),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.tokenAccount0),
      getAccountMeta(accounts.tokenAccount1),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram),
      getAccountMeta(accounts.tokenProgram2022),
      getAccountMeta(accounts.vault0Mint),
      getAccountMeta(accounts.vault1Mint)
    ],
    data: getOpenPositionV2InstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseOpenPositionV2Instruction(instruction) {
  if (instruction.accounts.length < 22) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      positionNftOwner: getNextAccount(),
      positionNftMint: getNextAccount(),
      positionNftAccount: getNextAccount(),
      metadataAccount: getNextAccount(),
      poolState: getNextAccount(),
      protocolPosition: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount(),
      personalPosition: getNextAccount(),
      tokenAccount0: getNextAccount(),
      tokenAccount1: getNextAccount(),
      tokenVault0: getNextAccount(),
      tokenVault1: getNextAccount(),
      rent: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataProgram: getNextAccount(),
      tokenProgram2022: getNextAccount(),
      vault0Mint: getNextAccount(),
      vault1Mint: getNextAccount()
    },
    data: getOpenPositionV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/openPositionWithToken22Nft.ts
import {
  combineCodec as combineCodec41,
  fixDecoderSize as fixDecoderSize26,
  fixEncoderSize as fixEncoderSize27,
  getAddressEncoder as getAddressEncoder26,
  getBooleanDecoder as getBooleanDecoder5,
  getBooleanEncoder as getBooleanEncoder5,
  getBytesDecoder as getBytesDecoder26,
  getBytesEncoder as getBytesEncoder27,
  getI32Decoder as getI32Decoder13,
  getI32Encoder as getI32Encoder13,
  getOptionDecoder as getOptionDecoder3,
  getOptionEncoder as getOptionEncoder3,
  getProgramDerivedAddress as getProgramDerivedAddress9,
  getStructDecoder as getStructDecoder41,
  getStructEncoder as getStructEncoder41,
  getU128Decoder as getU128Decoder23,
  getU128Encoder as getU128Encoder23,
  getU64Decoder as getU64Decoder29,
  getU64Encoder as getU64Encoder29,
  transformEncoder as transformEncoder26
} from "@solana/kit";
var OPEN_POSITION_WITH_TOKEN22_NFT_DISCRIMINATOR = new Uint8Array([
  77,
  255,
  174,
  82,
  125,
  29,
  201,
  46
]);
function getOpenPositionWithToken22NftDiscriminatorBytes() {
  return fixEncoderSize27(getBytesEncoder27(), 8).encode(
    OPEN_POSITION_WITH_TOKEN22_NFT_DISCRIMINATOR
  );
}
function getOpenPositionWithToken22NftInstructionDataEncoder() {
  return transformEncoder26(
    getStructEncoder41([
      ["discriminator", fixEncoderSize27(getBytesEncoder27(), 8)],
      ["tickLowerIndex", getI32Encoder13()],
      ["tickUpperIndex", getI32Encoder13()],
      ["tickArrayLowerStartIndex", getI32Encoder13()],
      ["tickArrayUpperStartIndex", getI32Encoder13()],
      ["liquidity", getU128Encoder23()],
      ["amount0Max", getU64Encoder29()],
      ["amount1Max", getU64Encoder29()],
      ["withMetadata", getBooleanEncoder5()],
      ["baseFlag", getOptionEncoder3(getBooleanEncoder5())]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_POSITION_WITH_TOKEN22_NFT_DISCRIMINATOR
    })
  );
}
function getOpenPositionWithToken22NftInstructionDataDecoder() {
  return getStructDecoder41([
    ["discriminator", fixDecoderSize26(getBytesDecoder26(), 8)],
    ["tickLowerIndex", getI32Decoder13()],
    ["tickUpperIndex", getI32Decoder13()],
    ["tickArrayLowerStartIndex", getI32Decoder13()],
    ["tickArrayUpperStartIndex", getI32Decoder13()],
    ["liquidity", getU128Decoder23()],
    ["amount0Max", getU64Decoder29()],
    ["amount1Max", getU64Decoder29()],
    ["withMetadata", getBooleanDecoder5()],
    ["baseFlag", getOptionDecoder3(getBooleanDecoder5())]
  ]);
}
function getOpenPositionWithToken22NftInstructionDataCodec() {
  return combineCodec41(
    getOpenPositionWithToken22NftInstructionDataEncoder(),
    getOpenPositionWithToken22NftInstructionDataDecoder()
  );
}
async function getOpenPositionWithToken22NftInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    positionNftOwner: {
      value: input.positionNftOwner ?? null,
      isWritable: false
    },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true
    },
    poolState: { value: input.poolState ?? null, isWritable: true },
    protocolPosition: {
      value: input.protocolPosition ?? null,
      isWritable: false
    },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    tokenAccount0: { value: input.tokenAccount0 ?? null, isWritable: true },
    tokenAccount1: { value: input.tokenAccount1 ?? null, isWritable: true },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    rent: { value: input.rent ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    },
    vault0Mint: { value: input.vault0Mint ?? null, isWritable: false },
    vault1Mint: { value: input.vault1Mint ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tickArrayLower.value) {
    accounts.tickArrayLower.value = await getProgramDerivedAddress9({
      programAddress,
      seeds: [
        getBytesEncoder27().encode(
          new Uint8Array([116, 105, 99, 107, 95, 97, 114, 114, 97, 121])
        ),
        getAddressEncoder26().encode(expectAddress(accounts.poolState.value)),
        getI32Encoder13().encode(expectSome(args.tickArrayLowerStartIndex))
      ]
    });
  }
  if (!accounts.tickArrayUpper.value) {
    accounts.tickArrayUpper.value = await getProgramDerivedAddress9({
      programAddress,
      seeds: [
        getBytesEncoder27().encode(
          new Uint8Array([116, 105, 99, 107, 95, 97, 114, 114, 97, 121])
        ),
        getAddressEncoder26().encode(expectAddress(accounts.poolState.value)),
        getI32Encoder13().encode(expectSome(args.tickArrayUpperStartIndex))
      ]
    });
  }
  if (!accounts.personalPosition.value) {
    accounts.personalPosition.value = await getProgramDerivedAddress9({
      programAddress,
      seeds: [
        getBytesEncoder27().encode(
          new Uint8Array([112, 111, 115, 105, 116, 105, 111, 110])
        ),
        getAddressEncoder26().encode(
          expectAddress(accounts.positionNftMint.value)
        )
      ]
    });
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.positionNftOwner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.protocolPosition),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.tokenAccount0),
      getAccountMeta(accounts.tokenAccount1),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.tokenProgram2022),
      getAccountMeta(accounts.vault0Mint),
      getAccountMeta(accounts.vault1Mint)
    ],
    data: getOpenPositionWithToken22NftInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function getOpenPositionWithToken22NftInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    positionNftOwner: {
      value: input.positionNftOwner ?? null,
      isWritable: false
    },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true
    },
    poolState: { value: input.poolState ?? null, isWritable: true },
    protocolPosition: {
      value: input.protocolPosition ?? null,
      isWritable: false
    },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },
    personalPosition: {
      value: input.personalPosition ?? null,
      isWritable: true
    },
    tokenAccount0: { value: input.tokenAccount0 ?? null, isWritable: true },
    tokenAccount1: { value: input.tokenAccount1 ?? null, isWritable: true },
    tokenVault0: { value: input.tokenVault0 ?? null, isWritable: true },
    tokenVault1: { value: input.tokenVault1 ?? null, isWritable: true },
    rent: { value: input.rent ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    },
    vault0Mint: { value: input.vault0Mint ?? null, isWritable: false },
    vault1Mint: { value: input.vault1Mint ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.positionNftOwner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.protocolPosition),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper),
      getAccountMeta(accounts.personalPosition),
      getAccountMeta(accounts.tokenAccount0),
      getAccountMeta(accounts.tokenAccount1),
      getAccountMeta(accounts.tokenVault0),
      getAccountMeta(accounts.tokenVault1),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.tokenProgram2022),
      getAccountMeta(accounts.vault0Mint),
      getAccountMeta(accounts.vault1Mint)
    ],
    data: getOpenPositionWithToken22NftInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseOpenPositionWithToken22NftInstruction(instruction) {
  if (instruction.accounts.length < 20) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      positionNftOwner: getNextAccount(),
      positionNftMint: getNextAccount(),
      positionNftAccount: getNextAccount(),
      poolState: getNextAccount(),
      protocolPosition: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount(),
      personalPosition: getNextAccount(),
      tokenAccount0: getNextAccount(),
      tokenAccount1: getNextAccount(),
      tokenVault0: getNextAccount(),
      tokenVault1: getNextAccount(),
      rent: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      tokenProgram2022: getNextAccount(),
      vault0Mint: getNextAccount(),
      vault1Mint: getNextAccount()
    },
    data: getOpenPositionWithToken22NftInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardParams.ts
import {
  combineCodec as combineCodec42,
  fixDecoderSize as fixDecoderSize27,
  fixEncoderSize as fixEncoderSize28,
  getBytesDecoder as getBytesDecoder27,
  getBytesEncoder as getBytesEncoder28,
  getProgramDerivedAddress as getProgramDerivedAddress10,
  getStructDecoder as getStructDecoder42,
  getStructEncoder as getStructEncoder42,
  getU128Decoder as getU128Decoder24,
  getU128Encoder as getU128Encoder24,
  getU64Decoder as getU64Decoder30,
  getU64Encoder as getU64Encoder30,
  getU8Decoder as getU8Decoder9,
  getU8Encoder as getU8Encoder9,
  transformEncoder as transformEncoder27
} from "@solana/kit";
var SET_REWARD_PARAMS_DISCRIMINATOR = new Uint8Array([
  112,
  52,
  167,
  75,
  32,
  201,
  211,
  137
]);
function getSetRewardParamsDiscriminatorBytes() {
  return fixEncoderSize28(getBytesEncoder28(), 8).encode(
    SET_REWARD_PARAMS_DISCRIMINATOR
  );
}
function getSetRewardParamsInstructionDataEncoder() {
  return transformEncoder27(
    getStructEncoder42([
      ["discriminator", fixEncoderSize28(getBytesEncoder28(), 8)],
      ["rewardIndex", getU8Encoder9()],
      ["emissionsPerSecondX64", getU128Encoder24()],
      ["openTime", getU64Encoder30()],
      ["endTime", getU64Encoder30()]
    ]),
    (value) => ({ ...value, discriminator: SET_REWARD_PARAMS_DISCRIMINATOR })
  );
}
function getSetRewardParamsInstructionDataDecoder() {
  return getStructDecoder42([
    ["discriminator", fixDecoderSize27(getBytesDecoder27(), 8)],
    ["rewardIndex", getU8Decoder9()],
    ["emissionsPerSecondX64", getU128Decoder24()],
    ["openTime", getU64Decoder30()],
    ["endTime", getU64Decoder30()]
  ]);
}
function getSetRewardParamsInstructionDataCodec() {
  return combineCodec42(
    getSetRewardParamsInstructionDataEncoder(),
    getSetRewardParamsInstructionDataDecoder()
  );
}
async function getSetRewardParamsInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    authority: { value: input.authority ?? null, isWritable: false },
    ammConfig: { value: input.ammConfig ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    operationState: { value: input.operationState ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.operationState.value) {
    accounts.operationState.value = await getProgramDerivedAddress10({
      programAddress,
      seeds: [
        getBytesEncoder28().encode(
          new Uint8Array([111, 112, 101, 114, 97, 116, 105, 111, 110])
        )
      ]
    });
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.operationState),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenProgram2022)
    ],
    data: getSetRewardParamsInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function getSetRewardParamsInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    authority: { value: input.authority ?? null, isWritable: false },
    ammConfig: { value: input.ammConfig ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    operationState: { value: input.operationState ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.operationState),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenProgram2022)
    ],
    data: getSetRewardParamsInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseSetRewardParamsInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      authority: getNextAccount(),
      ammConfig: getNextAccount(),
      poolState: getNextAccount(),
      operationState: getNextAccount(),
      tokenProgram: getNextAccount(),
      tokenProgram2022: getNextAccount()
    },
    data: getSetRewardParamsInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/swap.ts
import {
  combineCodec as combineCodec43,
  fixDecoderSize as fixDecoderSize28,
  fixEncoderSize as fixEncoderSize29,
  getBooleanDecoder as getBooleanDecoder6,
  getBooleanEncoder as getBooleanEncoder6,
  getBytesDecoder as getBytesDecoder28,
  getBytesEncoder as getBytesEncoder29,
  getStructDecoder as getStructDecoder43,
  getStructEncoder as getStructEncoder43,
  getU128Decoder as getU128Decoder25,
  getU128Encoder as getU128Encoder25,
  getU64Decoder as getU64Decoder31,
  getU64Encoder as getU64Encoder31,
  transformEncoder as transformEncoder28
} from "@solana/kit";
var SWAP_DISCRIMINATOR = new Uint8Array([
  248,
  198,
  158,
  145,
  225,
  117,
  135,
  200
]);
function getSwapDiscriminatorBytes() {
  return fixEncoderSize29(getBytesEncoder29(), 8).encode(SWAP_DISCRIMINATOR);
}
function getSwapInstructionDataEncoder() {
  return transformEncoder28(
    getStructEncoder43([
      ["discriminator", fixEncoderSize29(getBytesEncoder29(), 8)],
      ["amount", getU64Encoder31()],
      ["otherAmountThreshold", getU64Encoder31()],
      ["sqrtPriceLimitX64", getU128Encoder25()],
      ["isBaseInput", getBooleanEncoder6()]
    ]),
    (value) => ({ ...value, discriminator: SWAP_DISCRIMINATOR })
  );
}
function getSwapInstructionDataDecoder() {
  return getStructDecoder43([
    ["discriminator", fixDecoderSize28(getBytesDecoder28(), 8)],
    ["amount", getU64Decoder31()],
    ["otherAmountThreshold", getU64Decoder31()],
    ["sqrtPriceLimitX64", getU128Decoder25()],
    ["isBaseInput", getBooleanDecoder6()]
  ]);
}
function getSwapInstructionDataCodec() {
  return combineCodec43(
    getSwapInstructionDataEncoder(),
    getSwapInstructionDataDecoder()
  );
}
function getSwapInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: false },
    ammConfig: { value: input.ammConfig ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    inputTokenAccount: {
      value: input.inputTokenAccount ?? null,
      isWritable: true
    },
    outputTokenAccount: {
      value: input.outputTokenAccount ?? null,
      isWritable: true
    },
    inputVault: { value: input.inputVault ?? null, isWritable: true },
    outputVault: { value: input.outputVault ?? null, isWritable: true },
    observationState: {
      value: input.observationState ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tickArray: { value: input.tickArray ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.inputTokenAccount),
      getAccountMeta(accounts.outputTokenAccount),
      getAccountMeta(accounts.inputVault),
      getAccountMeta(accounts.outputVault),
      getAccountMeta(accounts.observationState),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tickArray)
    ],
    data: getSwapInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseSwapInstruction(instruction) {
  if (instruction.accounts.length < 10) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      ammConfig: getNextAccount(),
      poolState: getNextAccount(),
      inputTokenAccount: getNextAccount(),
      outputTokenAccount: getNextAccount(),
      inputVault: getNextAccount(),
      outputVault: getNextAccount(),
      observationState: getNextAccount(),
      tokenProgram: getNextAccount(),
      tickArray: getNextAccount()
    },
    data: getSwapInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/swapRouterBaseIn.ts
import {
  combineCodec as combineCodec44,
  fixDecoderSize as fixDecoderSize29,
  fixEncoderSize as fixEncoderSize30,
  getBytesDecoder as getBytesDecoder29,
  getBytesEncoder as getBytesEncoder30,
  getStructDecoder as getStructDecoder44,
  getStructEncoder as getStructEncoder44,
  getU64Decoder as getU64Decoder32,
  getU64Encoder as getU64Encoder32,
  transformEncoder as transformEncoder29
} from "@solana/kit";
var SWAP_ROUTER_BASE_IN_DISCRIMINATOR = new Uint8Array([
  69,
  125,
  115,
  218,
  245,
  186,
  242,
  196
]);
function getSwapRouterBaseInDiscriminatorBytes() {
  return fixEncoderSize30(getBytesEncoder30(), 8).encode(
    SWAP_ROUTER_BASE_IN_DISCRIMINATOR
  );
}
function getSwapRouterBaseInInstructionDataEncoder() {
  return transformEncoder29(
    getStructEncoder44([
      ["discriminator", fixEncoderSize30(getBytesEncoder30(), 8)],
      ["amountIn", getU64Encoder32()],
      ["amountOutMinimum", getU64Encoder32()]
    ]),
    (value) => ({ ...value, discriminator: SWAP_ROUTER_BASE_IN_DISCRIMINATOR })
  );
}
function getSwapRouterBaseInInstructionDataDecoder() {
  return getStructDecoder44([
    ["discriminator", fixDecoderSize29(getBytesDecoder29(), 8)],
    ["amountIn", getU64Decoder32()],
    ["amountOutMinimum", getU64Decoder32()]
  ]);
}
function getSwapRouterBaseInInstructionDataCodec() {
  return combineCodec44(
    getSwapRouterBaseInInstructionDataEncoder(),
    getSwapRouterBaseInInstructionDataDecoder()
  );
}
function getSwapRouterBaseInInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: false },
    inputTokenAccount: {
      value: input.inputTokenAccount ?? null,
      isWritable: true
    },
    inputTokenMint: { value: input.inputTokenMint ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  if (!accounts.memoProgram.value) {
    accounts.memoProgram.value = "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.inputTokenAccount),
      getAccountMeta(accounts.inputTokenMint),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenProgram2022),
      getAccountMeta(accounts.memoProgram)
    ],
    data: getSwapRouterBaseInInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseSwapRouterBaseInInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      inputTokenAccount: getNextAccount(),
      inputTokenMint: getNextAccount(),
      tokenProgram: getNextAccount(),
      tokenProgram2022: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getSwapRouterBaseInInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/swapV2.ts
import {
  combineCodec as combineCodec45,
  fixDecoderSize as fixDecoderSize30,
  fixEncoderSize as fixEncoderSize31,
  getBooleanDecoder as getBooleanDecoder7,
  getBooleanEncoder as getBooleanEncoder7,
  getBytesDecoder as getBytesDecoder30,
  getBytesEncoder as getBytesEncoder31,
  getStructDecoder as getStructDecoder45,
  getStructEncoder as getStructEncoder45,
  getU128Decoder as getU128Decoder26,
  getU128Encoder as getU128Encoder26,
  getU64Decoder as getU64Decoder33,
  getU64Encoder as getU64Encoder33,
  transformEncoder as transformEncoder30
} from "@solana/kit";
var SWAP_V2_DISCRIMINATOR = new Uint8Array([
  43,
  4,
  237,
  11,
  26,
  201,
  30,
  98
]);
function getSwapV2DiscriminatorBytes() {
  return fixEncoderSize31(getBytesEncoder31(), 8).encode(SWAP_V2_DISCRIMINATOR);
}
function getSwapV2InstructionDataEncoder() {
  return transformEncoder30(
    getStructEncoder45([
      ["discriminator", fixEncoderSize31(getBytesEncoder31(), 8)],
      ["amount", getU64Encoder33()],
      ["otherAmountThreshold", getU64Encoder33()],
      ["sqrtPriceLimitX64", getU128Encoder26()],
      ["isBaseInput", getBooleanEncoder7()]
    ]),
    (value) => ({ ...value, discriminator: SWAP_V2_DISCRIMINATOR })
  );
}
function getSwapV2InstructionDataDecoder() {
  return getStructDecoder45([
    ["discriminator", fixDecoderSize30(getBytesDecoder30(), 8)],
    ["amount", getU64Decoder33()],
    ["otherAmountThreshold", getU64Decoder33()],
    ["sqrtPriceLimitX64", getU128Decoder26()],
    ["isBaseInput", getBooleanDecoder7()]
  ]);
}
function getSwapV2InstructionDataCodec() {
  return combineCodec45(
    getSwapV2InstructionDataEncoder(),
    getSwapV2InstructionDataDecoder()
  );
}
function getSwapV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: false },
    ammConfig: { value: input.ammConfig ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    inputTokenAccount: {
      value: input.inputTokenAccount ?? null,
      isWritable: true
    },
    outputTokenAccount: {
      value: input.outputTokenAccount ?? null,
      isWritable: true
    },
    inputVault: { value: input.inputVault ?? null, isWritable: true },
    outputVault: { value: input.outputVault ?? null, isWritable: true },
    observationState: {
      value: input.observationState ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false
    },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    inputVaultMint: { value: input.inputVaultMint ?? null, isWritable: false },
    outputVaultMint: {
      value: input.outputVaultMint ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  if (!accounts.memoProgram.value) {
    accounts.memoProgram.value = "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.inputTokenAccount),
      getAccountMeta(accounts.outputTokenAccount),
      getAccountMeta(accounts.inputVault),
      getAccountMeta(accounts.outputVault),
      getAccountMeta(accounts.observationState),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenProgram2022),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.inputVaultMint),
      getAccountMeta(accounts.outputVaultMint)
    ],
    data: getSwapV2InstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseSwapV2Instruction(instruction) {
  if (instruction.accounts.length < 13) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      ammConfig: getNextAccount(),
      poolState: getNextAccount(),
      inputTokenAccount: getNextAccount(),
      outputTokenAccount: getNextAccount(),
      inputVault: getNextAccount(),
      outputVault: getNextAccount(),
      observationState: getNextAccount(),
      tokenProgram: getNextAccount(),
      tokenProgram2022: getNextAccount(),
      memoProgram: getNextAccount(),
      inputVaultMint: getNextAccount(),
      outputVaultMint: getNextAccount()
    },
    data: getSwapV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/transferRewardOwner.ts
import {
  combineCodec as combineCodec46,
  fixDecoderSize as fixDecoderSize31,
  fixEncoderSize as fixEncoderSize32,
  getAddressDecoder as getAddressDecoder20,
  getAddressEncoder as getAddressEncoder27,
  getBytesDecoder as getBytesDecoder31,
  getBytesEncoder as getBytesEncoder32,
  getStructDecoder as getStructDecoder46,
  getStructEncoder as getStructEncoder46,
  transformEncoder as transformEncoder31
} from "@solana/kit";
var TRANSFER_REWARD_OWNER_DISCRIMINATOR = new Uint8Array([
  7,
  22,
  12,
  83,
  242,
  43,
  48,
  121
]);
function getTransferRewardOwnerDiscriminatorBytes() {
  return fixEncoderSize32(getBytesEncoder32(), 8).encode(
    TRANSFER_REWARD_OWNER_DISCRIMINATOR
  );
}
function getTransferRewardOwnerInstructionDataEncoder() {
  return transformEncoder31(
    getStructEncoder46([
      ["discriminator", fixEncoderSize32(getBytesEncoder32(), 8)],
      ["newOwner", getAddressEncoder27()]
    ]),
    (value) => ({
      ...value,
      discriminator: TRANSFER_REWARD_OWNER_DISCRIMINATOR
    })
  );
}
function getTransferRewardOwnerInstructionDataDecoder() {
  return getStructDecoder46([
    ["discriminator", fixDecoderSize31(getBytesDecoder31(), 8)],
    ["newOwner", getAddressDecoder20()]
  ]);
}
function getTransferRewardOwnerInstructionDataCodec() {
  return combineCodec46(
    getTransferRewardOwnerInstructionDataEncoder(),
    getTransferRewardOwnerInstructionDataDecoder()
  );
}
function getTransferRewardOwnerInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    authority: { value: input.authority ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.authority.value) {
    accounts.authority.value = "AMeGg9qpzv1geQpiEWzhgXempJTuYYZeuLLKX1cYbmaw";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.poolState)
    ],
    data: getTransferRewardOwnerInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseTransferRewardOwnerInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { authority: getNextAccount(), poolState: getNextAccount() },
    data: getTransferRewardOwnerInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/updateAmmConfig.ts
import {
  combineCodec as combineCodec47,
  fixDecoderSize as fixDecoderSize32,
  fixEncoderSize as fixEncoderSize33,
  getBytesDecoder as getBytesDecoder32,
  getBytesEncoder as getBytesEncoder33,
  getStructDecoder as getStructDecoder47,
  getStructEncoder as getStructEncoder47,
  getU32Decoder as getU32Decoder6,
  getU32Encoder as getU32Encoder6,
  getU8Decoder as getU8Decoder10,
  getU8Encoder as getU8Encoder10,
  transformEncoder as transformEncoder32
} from "@solana/kit";
var UPDATE_AMM_CONFIG_DISCRIMINATOR = new Uint8Array([
  49,
  60,
  174,
  136,
  154,
  28,
  116,
  200
]);
function getUpdateAmmConfigDiscriminatorBytes() {
  return fixEncoderSize33(getBytesEncoder33(), 8).encode(
    UPDATE_AMM_CONFIG_DISCRIMINATOR
  );
}
function getUpdateAmmConfigInstructionDataEncoder() {
  return transformEncoder32(
    getStructEncoder47([
      ["discriminator", fixEncoderSize33(getBytesEncoder33(), 8)],
      ["param", getU8Encoder10()],
      ["value", getU32Encoder6()]
    ]),
    (value) => ({ ...value, discriminator: UPDATE_AMM_CONFIG_DISCRIMINATOR })
  );
}
function getUpdateAmmConfigInstructionDataDecoder() {
  return getStructDecoder47([
    ["discriminator", fixDecoderSize32(getBytesDecoder32(), 8)],
    ["param", getU8Decoder10()],
    ["value", getU32Decoder6()]
  ]);
}
function getUpdateAmmConfigInstructionDataCodec() {
  return combineCodec47(
    getUpdateAmmConfigInstructionDataEncoder(),
    getUpdateAmmConfigInstructionDataDecoder()
  );
}
function getUpdateAmmConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    ammConfig: { value: input.ammConfig ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.owner.value) {
    accounts.owner.value = "AMeGg9qpzv1geQpiEWzhgXempJTuYYZeuLLKX1cYbmaw";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.ammConfig)
    ],
    data: getUpdateAmmConfigInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseUpdateAmmConfigInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { owner: getNextAccount(), ammConfig: getNextAccount() },
    data: getUpdateAmmConfigInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/updateOperationAccount.ts
import {
  combineCodec as combineCodec48,
  fixDecoderSize as fixDecoderSize33,
  fixEncoderSize as fixEncoderSize34,
  getAddressDecoder as getAddressDecoder21,
  getAddressEncoder as getAddressEncoder28,
  getArrayDecoder as getArrayDecoder14,
  getArrayEncoder as getArrayEncoder14,
  getBytesDecoder as getBytesDecoder33,
  getBytesEncoder as getBytesEncoder34,
  getProgramDerivedAddress as getProgramDerivedAddress11,
  getStructDecoder as getStructDecoder48,
  getStructEncoder as getStructEncoder48,
  getU8Decoder as getU8Decoder11,
  getU8Encoder as getU8Encoder11,
  transformEncoder as transformEncoder33
} from "@solana/kit";
var UPDATE_OPERATION_ACCOUNT_DISCRIMINATOR = new Uint8Array([
  127,
  70,
  119,
  40,
  188,
  227,
  61,
  7
]);
function getUpdateOperationAccountDiscriminatorBytes() {
  return fixEncoderSize34(getBytesEncoder34(), 8).encode(
    UPDATE_OPERATION_ACCOUNT_DISCRIMINATOR
  );
}
function getUpdateOperationAccountInstructionDataEncoder() {
  return transformEncoder33(
    getStructEncoder48([
      ["discriminator", fixEncoderSize34(getBytesEncoder34(), 8)],
      ["param", getU8Encoder11()],
      ["keys", getArrayEncoder14(getAddressEncoder28())]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_OPERATION_ACCOUNT_DISCRIMINATOR
    })
  );
}
function getUpdateOperationAccountInstructionDataDecoder() {
  return getStructDecoder48([
    ["discriminator", fixDecoderSize33(getBytesDecoder33(), 8)],
    ["param", getU8Decoder11()],
    ["keys", getArrayDecoder14(getAddressDecoder21())]
  ]);
}
function getUpdateOperationAccountInstructionDataCodec() {
  return combineCodec48(
    getUpdateOperationAccountInstructionDataEncoder(),
    getUpdateOperationAccountInstructionDataDecoder()
  );
}
async function getUpdateOperationAccountInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    operationState: { value: input.operationState ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.owner.value) {
    accounts.owner.value = "AMeGg9qpzv1geQpiEWzhgXempJTuYYZeuLLKX1cYbmaw";
  }
  if (!accounts.operationState.value) {
    accounts.operationState.value = await getProgramDerivedAddress11({
      programAddress,
      seeds: [
        getBytesEncoder34().encode(
          new Uint8Array([111, 112, 101, 114, 97, 116, 105, 111, 110])
        )
      ]
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.operationState),
      getAccountMeta(accounts.systemProgram)
    ],
    data: getUpdateOperationAccountInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function getUpdateOperationAccountInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    operationState: { value: input.operationState ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.owner.value) {
    accounts.owner.value = "AMeGg9qpzv1geQpiEWzhgXempJTuYYZeuLLKX1cYbmaw";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.operationState),
      getAccountMeta(accounts.systemProgram)
    ],
    data: getUpdateOperationAccountInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseUpdateOperationAccountInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      owner: getNextAccount(),
      operationState: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getUpdateOperationAccountInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/updatePoolStatus.ts
import {
  combineCodec as combineCodec49,
  fixDecoderSize as fixDecoderSize34,
  fixEncoderSize as fixEncoderSize35,
  getBytesDecoder as getBytesDecoder34,
  getBytesEncoder as getBytesEncoder35,
  getStructDecoder as getStructDecoder49,
  getStructEncoder as getStructEncoder49,
  getU8Decoder as getU8Decoder12,
  getU8Encoder as getU8Encoder12,
  transformEncoder as transformEncoder34
} from "@solana/kit";
var UPDATE_POOL_STATUS_DISCRIMINATOR = new Uint8Array([
  130,
  87,
  108,
  6,
  46,
  224,
  117,
  123
]);
function getUpdatePoolStatusDiscriminatorBytes() {
  return fixEncoderSize35(getBytesEncoder35(), 8).encode(
    UPDATE_POOL_STATUS_DISCRIMINATOR
  );
}
function getUpdatePoolStatusInstructionDataEncoder() {
  return transformEncoder34(
    getStructEncoder49([
      ["discriminator", fixEncoderSize35(getBytesEncoder35(), 8)],
      ["status", getU8Encoder12()]
    ]),
    (value) => ({ ...value, discriminator: UPDATE_POOL_STATUS_DISCRIMINATOR })
  );
}
function getUpdatePoolStatusInstructionDataDecoder() {
  return getStructDecoder49([
    ["discriminator", fixDecoderSize34(getBytesDecoder34(), 8)],
    ["status", getU8Decoder12()]
  ]);
}
function getUpdatePoolStatusInstructionDataCodec() {
  return combineCodec49(
    getUpdatePoolStatusInstructionDataEncoder(),
    getUpdatePoolStatusInstructionDataDecoder()
  );
}
function getUpdatePoolStatusInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    authority: { value: input.authority ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.authority.value) {
    accounts.authority.value = "AMeGg9qpzv1geQpiEWzhgXempJTuYYZeuLLKX1cYbmaw";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.poolState)
    ],
    data: getUpdatePoolStatusInstructionDataEncoder().encode(
      args
    ),
    programAddress
  });
}
function parseUpdatePoolStatusInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { authority: getNextAccount(), poolState: getNextAccount() },
    data: getUpdatePoolStatusInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/updateRewardInfos.ts
import {
  combineCodec as combineCodec50,
  fixDecoderSize as fixDecoderSize35,
  fixEncoderSize as fixEncoderSize36,
  getBytesDecoder as getBytesDecoder35,
  getBytesEncoder as getBytesEncoder36,
  getStructDecoder as getStructDecoder50,
  getStructEncoder as getStructEncoder50,
  transformEncoder as transformEncoder35
} from "@solana/kit";
var UPDATE_REWARD_INFOS_DISCRIMINATOR = new Uint8Array([
  163,
  172,
  224,
  52,
  11,
  154,
  106,
  223
]);
function getUpdateRewardInfosDiscriminatorBytes() {
  return fixEncoderSize36(getBytesEncoder36(), 8).encode(
    UPDATE_REWARD_INFOS_DISCRIMINATOR
  );
}
function getUpdateRewardInfosInstructionDataEncoder() {
  return transformEncoder35(
    getStructEncoder50([["discriminator", fixEncoderSize36(getBytesEncoder36(), 8)]]),
    (value) => ({ ...value, discriminator: UPDATE_REWARD_INFOS_DISCRIMINATOR })
  );
}
function getUpdateRewardInfosInstructionDataDecoder() {
  return getStructDecoder50([
    ["discriminator", fixDecoderSize35(getBytesDecoder35(), 8)]
  ]);
}
function getUpdateRewardInfosInstructionDataCodec() {
  return combineCodec50(
    getUpdateRewardInfosInstructionDataEncoder(),
    getUpdateRewardInfosInstructionDataDecoder()
  );
}
function getUpdateRewardInfosInstruction(input, config) {
  const programAddress = config?.programAddress ?? AMM_V3_PROGRAM_ADDRESS;
  const originalAccounts = {
    poolState: { value: input.poolState ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [getAccountMeta(accounts.poolState)],
    data: getUpdateRewardInfosInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseUpdateRewardInfosInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { poolState: getNextAccount() },
    data: getUpdateRewardInfosInstructionDataDecoder().decode(instruction.data)
  };
}

// src/utils/math.ts
import BN2 from "bn.js";
import Decimal from "decimal.js";

// src/constants.ts
import BN from "bn.js";
var STABBLE_CLMM_PROGRAM_ID = "6dMXqGZ3ga2dikrYS9ovDXgHGh5RUsb2RTUj6hrQXhk6";
var METADATA_PROGRAM_ID = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
var SYSTEM_PROGRAM_ID = "11111111111111111111111111111111";
var SYSVAR_RENT_PROGRAM_ID = "SysvarRent111111111111111111111111111111111";
var ZERO = new BN(0);
var ONE = new BN(1);
var NEGATIVE_ONE = new BN(-1);
var BIT_PRECISION = 16;
var Q64 = new BN(2).pow(new BN(64));
var Q128 = new BN(2).pow(new BN(128));
var MaxU64 = Q64.sub(ONE);
var MIN_TICK = -443636;
var MAX_TICK = 443636;
var MIN_SQRT_RATIO = new BN("4295128739");
var MAX_SQRT_RATIO = new BN(
  "1461446703485210103287273052203988822378723970342"
);
var DEFAULT_SLIPPAGE_TOLERANCE = 0.01;
var DEFAULT_DEADLINE_SECONDS = 300;
var FEE_RATE_DENOMINATOR = new BN(10).pow(new BN(6));
var U64Resolution = 64;
var MaxUint128 = Q128.sub(ONE);
var MIN_SQRT_PRICE_X64 = MIN_SQRT_RATIO;
var MAX_SQRT_PRICE_X64 = MAX_SQRT_RATIO;
var LOG_B_2_X32 = "295232799039604140847618609643520000000";
var LOG_B_P_ERR_MARGIN_LOWER_X64 = "184467440737095516";
var LOG_B_P_ERR_MARGIN_UPPER_X64 = "15793534762490258745";
var FEE_TIERS = {
  VERY_LOW: 100,
  // 0.01%
  LOW: 500,
  // 0.05%
  MEDIUM: 3e3,
  // 0.3%
  HIGH: 1e4
  // 1%
};
var TICK_SPACINGS = {
  [FEE_TIERS.VERY_LOW]: 1,
  [FEE_TIERS.LOW]: 10,
  [FEE_TIERS.MEDIUM]: 60,
  [FEE_TIERS.HIGH]: 200
};
var DEFAULT_CONFIG = {
  SLIPPAGE_TOLERANCE: 0.01,
  // 1%
  DEADLINE_SECONDS: 300,
  // 5 minutes
  COMMITMENT: "confirmed",
  MAX_RETRIES: 3,
  RETRY_DELAY: 1e3
  // 1 second
};
var TICKS_PER_ARRAY = 60;
var PDA_SEEDS = {
  AMM_CONFIG: "amm_config",
  POOL_STATE: "pool",
  POOL_VAULT: "pool_vault",
  POOL_REWARD_VAULT_SEED: "pool_reward_vault",
  POSITION_STATE: "position",
  TICK_ARRAY_STATE: "tick_array",
  OBSERVATION_STATE: "observation",
  OPERATION: "operation",
  BITMAP_EXTENSION: "pool_tick_array_bitmap_extension"
};
var STABBLE_CLMM_API_DEVNET = "https://dev-mclmm-api.stabble.org";
var STABBLE_CLMM_API_MAINNET = "https://mclmm-api.stabble.org";
var API_ENDPONTS = {
  mainnet: STABBLE_CLMM_API_MAINNET,
  devnet: STABBLE_CLMM_API_DEVNET
};

// src/utils/math.ts
var MathUtils = class {
  static mulDivRoundingUp(a, b, denominator) {
    const numerator = a.mul(b);
    let result = numerator.div(denominator);
    if (!numerator.mod(denominator).eq(ZERO)) {
      result = result.add(ONE);
    }
    return result;
  }
  static mulDivFloor(a, b, denominator) {
    if (denominator.eq(ZERO)) {
      throw new Error("division by 0");
    }
    return a.mul(b).div(denominator);
  }
  static mulDivCeil(a, b, denominator) {
    if (denominator.eq(ZERO)) {
      throw new Error("division by 0");
    }
    const numerator = a.mul(b).add(denominator.sub(ONE));
    return numerator.div(denominator);
  }
  static x64ToDecimal(num, decimalPlaces) {
    return new Decimal(num.toString()).div(Decimal.pow(2, 64)).toDecimalPlaces(decimalPlaces);
  }
  static decimalToX64(num) {
    return new BN2(num.mul(Decimal.pow(2, 64)).floor().toFixed());
  }
  static wrappingSubU128(n0, n1) {
    return n0.add(Q128).sub(n1).mod(Q128);
  }
};
function mulRightShift(val, mulBy) {
  return signedRightShift(val.mul(mulBy), 64, 256);
}
function signedLeftShift(n0, shiftBy, bitWidth) {
  const twosN0 = n0.toTwos(bitWidth).shln(shiftBy);
  twosN0.imaskn(bitWidth + 1);
  return twosN0.fromTwos(bitWidth);
}
function signedRightShift(n0, shiftBy, bitWidth) {
  const twoN0 = n0.toTwos(bitWidth).shrn(shiftBy);
  twoN0.imaskn(bitWidth - shiftBy + 1);
  return twoN0.fromTwos(bitWidth - shiftBy);
}
var SqrtPriceMath = class _SqrtPriceMath {
  static sqrtPriceX64ToPrice(sqrtPriceX64, decimalsA, decimalsB) {
    return MathUtils.x64ToDecimal(sqrtPriceX64).pow(2).mul(Decimal.pow(10, decimalsA - decimalsB));
  }
  static priceToSqrtPriceX64(price, decimalsA, decimalsB) {
    return MathUtils.decimalToX64(
      price.mul(Decimal.pow(10, decimalsB - decimalsA)).sqrt()
    );
  }
  static getNextSqrtPriceX64FromInput(sqrtPriceX64, liquidity, amountIn, zeroForOne) {
    if (!sqrtPriceX64.gt(ZERO)) {
      throw new Error("sqrtPriceX64 must greater than 0");
    }
    if (!liquidity.gt(ZERO)) {
      throw new Error("liquidity must greater than 0");
    }
    return zeroForOne ? this.getNextSqrtPriceFromTokenAmountARoundingUp(
      sqrtPriceX64,
      liquidity,
      amountIn,
      true
    ) : this.getNextSqrtPriceFromTokenAmountBRoundingDown(
      sqrtPriceX64,
      liquidity,
      amountIn,
      true
    );
  }
  static getNextSqrtPriceX64FromOutput(sqrtPriceX64, liquidity, amountOut, zeroForOne) {
    if (!sqrtPriceX64.gt(ZERO)) {
      throw new Error("sqrtPriceX64 must greater than 0");
    }
    if (!liquidity.gt(ZERO)) {
      throw new Error("liquidity must greater than 0");
    }
    return zeroForOne ? this.getNextSqrtPriceFromTokenAmountBRoundingDown(
      sqrtPriceX64,
      liquidity,
      amountOut,
      false
    ) : this.getNextSqrtPriceFromTokenAmountARoundingUp(
      sqrtPriceX64,
      liquidity,
      amountOut,
      false
    );
  }
  static getNextSqrtPriceFromTokenAmountARoundingUp(sqrtPriceX64, liquidity, amount, add) {
    if (amount.eq(ZERO)) return sqrtPriceX64;
    const liquidityLeftShift = liquidity.shln(U64Resolution);
    if (add) {
      const numerator1 = liquidityLeftShift;
      const denominator = liquidityLeftShift.add(amount.mul(sqrtPriceX64));
      if (denominator.gte(numerator1)) {
        return MathUtils.mulDivCeil(numerator1, sqrtPriceX64, denominator);
      }
      return MathUtils.mulDivRoundingUp(
        numerator1,
        ONE,
        numerator1.div(sqrtPriceX64).add(amount)
      );
    } else {
      const amountMulSqrtPrice = amount.mul(sqrtPriceX64);
      if (!liquidityLeftShift.gt(amountMulSqrtPrice)) {
        throw new Error(
          "getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice"
        );
      }
      const denominator = liquidityLeftShift.sub(amountMulSqrtPrice);
      return MathUtils.mulDivCeil(
        liquidityLeftShift,
        sqrtPriceX64,
        denominator
      );
    }
  }
  static getNextSqrtPriceFromTokenAmountBRoundingDown(sqrtPriceX64, liquidity, amount, add) {
    const deltaY = amount.shln(U64Resolution);
    if (add) {
      return sqrtPriceX64.add(deltaY.div(liquidity));
    } else {
      const amountDivLiquidity = MathUtils.mulDivRoundingUp(
        deltaY,
        ONE,
        liquidity
      );
      if (!sqrtPriceX64.gt(amountDivLiquidity)) {
        throw new Error(
          "getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity"
        );
      }
      return sqrtPriceX64.sub(amountDivLiquidity);
    }
  }
  static getSqrtPriceX64FromTick(tick) {
    if (!Number.isInteger(tick)) {
      throw new Error("tick must be integer");
    }
    if (tick < MIN_TICK || tick > MAX_TICK) {
      throw new Error("tick must be in MIN_TICK and MAX_TICK");
    }
    const tickAbs = tick < 0 ? tick * -1 : tick;
    let ratio = (tickAbs & 1) != 0 ? new BN2("18445821805675395072") : new BN2("18446744073709551616");
    if ((tickAbs & 2) != 0)
      ratio = mulRightShift(ratio, new BN2("18444899583751176192"));
    if ((tickAbs & 4) != 0)
      ratio = mulRightShift(ratio, new BN2("18443055278223355904"));
    if ((tickAbs & 8) != 0)
      ratio = mulRightShift(ratio, new BN2("18439367220385607680"));
    if ((tickAbs & 16) != 0)
      ratio = mulRightShift(ratio, new BN2("18431993317065453568"));
    if ((tickAbs & 32) != 0)
      ratio = mulRightShift(ratio, new BN2("18417254355718170624"));
    if ((tickAbs & 64) != 0)
      ratio = mulRightShift(ratio, new BN2("18387811781193609216"));
    if ((tickAbs & 128) != 0)
      ratio = mulRightShift(ratio, new BN2("18329067761203558400"));
    if ((tickAbs & 256) != 0)
      ratio = mulRightShift(ratio, new BN2("18212142134806163456"));
    if ((tickAbs & 512) != 0)
      ratio = mulRightShift(ratio, new BN2("17980523815641700352"));
    if ((tickAbs & 1024) != 0)
      ratio = mulRightShift(ratio, new BN2("17526086738831433728"));
    if ((tickAbs & 2048) != 0)
      ratio = mulRightShift(ratio, new BN2("16651378430235570176"));
    if ((tickAbs & 4096) != 0)
      ratio = mulRightShift(ratio, new BN2("15030750278694412288"));
    if ((tickAbs & 8192) != 0)
      ratio = mulRightShift(ratio, new BN2("12247334978884435968"));
    if ((tickAbs & 16384) != 0)
      ratio = mulRightShift(ratio, new BN2("8131365268886854656"));
    if ((tickAbs & 32768) != 0)
      ratio = mulRightShift(ratio, new BN2("3584323654725218816"));
    if ((tickAbs & 65536) != 0)
      ratio = mulRightShift(ratio, new BN2("696457651848324352"));
    if ((tickAbs & 131072) != 0)
      ratio = mulRightShift(ratio, new BN2("26294789957507116"));
    if ((tickAbs & 262144) != 0)
      ratio = mulRightShift(ratio, new BN2("37481735321082"));
    if (tick > 0) ratio = MaxUint128.div(ratio);
    return ratio;
  }
  static getTickFromPrice(price, decimalsA, decimalsB) {
    return _SqrtPriceMath.getTickFromSqrtPriceX64(
      _SqrtPriceMath.priceToSqrtPriceX64(price, decimalsA, decimalsB)
    );
  }
  static getTickFromSqrtPriceX64(sqrtPriceX64) {
    if (sqrtPriceX64.gt(MAX_SQRT_PRICE_X64) || sqrtPriceX64.lt(MIN_SQRT_PRICE_X64)) {
      throw new Error(
        "Provided sqrtPrice is not within the supported sqrtPrice range."
      );
    }
    const msb = sqrtPriceX64.bitLength() - 1;
    const adjustedMsb = new BN2(msb - 64);
    const log2pIntegerX32 = signedLeftShift(adjustedMsb, 32, 128);
    let bit = new BN2("8000000000000000", "hex");
    let precision = 0;
    let log2pFractionX64 = new BN2(0);
    let r = msb >= 64 ? sqrtPriceX64.shrn(msb - 63) : sqrtPriceX64.shln(63 - msb);
    while (bit.gt(new BN2(0)) && precision < BIT_PRECISION) {
      r = r.mul(r);
      const rMoreThanTwo = r.shrn(127);
      r = r.shrn(63 + rMoreThanTwo.toNumber());
      log2pFractionX64 = log2pFractionX64.add(bit.mul(rMoreThanTwo));
      bit = bit.shrn(1);
      precision += 1;
    }
    const log2pFractionX32 = log2pFractionX64.shrn(32);
    const log2pX32 = log2pIntegerX32.add(log2pFractionX32);
    const logbpX64 = log2pX32.mul(new BN2(LOG_B_2_X32));
    const tickLow = signedRightShift(
      logbpX64.sub(new BN2(LOG_B_P_ERR_MARGIN_LOWER_X64)),
      64,
      128
    ).toNumber();
    const tickHigh = signedRightShift(
      logbpX64.add(new BN2(LOG_B_P_ERR_MARGIN_UPPER_X64)),
      64,
      128
    ).toNumber();
    if (tickLow == tickHigh) {
      return tickLow;
    } else {
      const derivedTickHighSqrtPriceX64 = _SqrtPriceMath.getSqrtPriceX64FromTick(tickHigh);
      return derivedTickHighSqrtPriceX64.lte(sqrtPriceX64) ? tickHigh : tickLow;
    }
  }
};
var TickMath = class _TickMath {
  static getTickWithPriceAndTickspacing(price, tickSpacing, mintDecimalsA, mintDecimalsB) {
    const tick = SqrtPriceMath.getTickFromSqrtPriceX64(
      SqrtPriceMath.priceToSqrtPriceX64(price, mintDecimalsA, mintDecimalsB)
    );
    let result = tick / tickSpacing;
    if (result < 0) {
      result = Math.floor(result);
    } else {
      result = Math.ceil(result);
    }
    return result * tickSpacing;
  }
  static roundPriceWithTickspacing(price, tickSpacing, mintDecimalsA, mintDecimalsB) {
    const tick = _TickMath.getTickWithPriceAndTickspacing(
      price,
      tickSpacing,
      mintDecimalsA,
      mintDecimalsB
    );
    const sqrtPriceX64 = SqrtPriceMath.getSqrtPriceX64FromTick(tick);
    return SqrtPriceMath.sqrtPriceX64ToPrice(
      sqrtPriceX64,
      mintDecimalsA,
      mintDecimalsB
    );
  }
};
var LiquidityMath = class _LiquidityMath {
  static addDelta(x, y) {
    return x.add(y);
  }
  static getTokenAmountAFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (!sqrtPriceX64A.gt(ZERO)) {
      throw new Error("sqrtPriceX64A must greater than 0");
    }
    const numerator1 = liquidity.ushln(U64Resolution);
    const numerator2 = sqrtPriceX64B.sub(sqrtPriceX64A);
    return roundUp ? MathUtils.mulDivRoundingUp(
      MathUtils.mulDivCeil(numerator1, numerator2, sqrtPriceX64B),
      ONE,
      sqrtPriceX64A
    ) : MathUtils.mulDivFloor(numerator1, numerator2, sqrtPriceX64B).div(
      sqrtPriceX64A
    );
  }
  static getTokenAmountBFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (!sqrtPriceX64A.gt(ZERO)) {
      throw new Error("sqrtPriceX64A must greater than 0");
    }
    return roundUp ? MathUtils.mulDivCeil(liquidity, sqrtPriceX64B.sub(sqrtPriceX64A), Q64) : MathUtils.mulDivFloor(liquidity, sqrtPriceX64B.sub(sqrtPriceX64A), Q64);
  }
  static getLiquidityFromTokenAmountA(sqrtPriceX64A, sqrtPriceX64B, amountA, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    const numerator = amountA.mul(sqrtPriceX64A).mul(sqrtPriceX64B);
    const denominator = sqrtPriceX64B.sub(sqrtPriceX64A);
    const result = numerator.div(denominator);
    if (roundUp) {
      return MathUtils.mulDivRoundingUp(result, ONE, MaxU64);
    } else {
      return result.shrn(U64Resolution);
    }
  }
  static getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64B, amountB) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    return MathUtils.mulDivFloor(
      amountB,
      MaxU64,
      sqrtPriceX64B.sub(sqrtPriceX64A)
    );
  }
  static getLiquidityFromTokenAmounts(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, amountA, amountB) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (sqrtPriceCurrentX64.lte(sqrtPriceX64A)) {
      return _LiquidityMath.getLiquidityFromTokenAmountA(
        sqrtPriceX64A,
        sqrtPriceX64B,
        amountA,
        false
      );
    } else if (sqrtPriceCurrentX64.lt(sqrtPriceX64B)) {
      const liquidity0 = _LiquidityMath.getLiquidityFromTokenAmountA(
        sqrtPriceCurrentX64,
        sqrtPriceX64B,
        amountA,
        false
      );
      const liquidity1 = _LiquidityMath.getLiquidityFromTokenAmountB(
        sqrtPriceX64A,
        sqrtPriceCurrentX64,
        amountB
      );
      return liquidity0.lt(liquidity1) ? liquidity0 : liquidity1;
    } else {
      return _LiquidityMath.getLiquidityFromTokenAmountB(
        sqrtPriceX64A,
        sqrtPriceX64B,
        amountB
      );
    }
  }
  static getAmountsFromLiquidity(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (sqrtPriceCurrentX64.lte(sqrtPriceX64A)) {
      return {
        amountA: _LiquidityMath.getTokenAmountAFromLiquidity(
          sqrtPriceX64A,
          sqrtPriceX64B,
          liquidity,
          roundUp
        ),
        amountB: new BN2(0)
      };
    } else if (sqrtPriceCurrentX64.lt(sqrtPriceX64B)) {
      const amountA = _LiquidityMath.getTokenAmountAFromLiquidity(
        sqrtPriceCurrentX64,
        sqrtPriceX64B,
        liquidity,
        roundUp
      );
      const amountB = _LiquidityMath.getTokenAmountBFromLiquidity(
        sqrtPriceX64A,
        sqrtPriceCurrentX64,
        liquidity,
        roundUp
      );
      return { amountA, amountB };
    } else {
      return {
        amountA: new BN2(0),
        amountB: _LiquidityMath.getTokenAmountBFromLiquidity(
          sqrtPriceX64A,
          sqrtPriceX64B,
          liquidity,
          roundUp
        )
      };
    }
  }
  static getAmountsFromLiquidityWithSlippage(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, amountMax, roundUp, amountSlippage) {
    const { amountA, amountB } = _LiquidityMath.getAmountsFromLiquidity(
      sqrtPriceCurrentX64,
      sqrtPriceX64A,
      sqrtPriceX64B,
      liquidity,
      roundUp
    );
    const coefficient = amountMax ? 1 + amountSlippage : 1 - amountSlippage;
    const amount0Slippage = new BN2(
      new Decimal(amountA.toString()).mul(coefficient).toFixed(0)
    );
    const amount1Slippage = new BN2(
      new Decimal(amountB.toString()).mul(coefficient).toFixed(0)
    );
    return {
      amountSlippageA: amount0Slippage,
      amountSlippageB: amount1Slippage
    };
  }
  // public static getAmountsOutFromLiquidity({
  //   poolInfo,
  //   tickLower,
  //   tickUpper,
  //   liquidity,
  //   slippage,
  //   add,
  //   epochInfo,
  //   amountAddFee,
  // }: {
  //   poolInfo: ApiV3PoolInfoConcentratedItem;
  //   tickLower: number;
  //   tickUpper: number;
  //   liquidity: BN;
  //   slippage: number;
  //   add: boolean;
  //
  //   epochInfo: EpochInfo;
  //   amountAddFee: boolean;
  // }): ReturnTypeGetLiquidityAmountOut {
  //   const sqrtPriceX64 = SqrtPriceMath.priceToSqrtPriceX64(
  //     new Decimal(poolInfo.price),
  //     poolInfo.mintA.decimals,
  //     poolInfo.mintB.decimals,
  //   );
  //   const sqrtPriceX64A = SqrtPriceMath.getSqrtPriceX64FromTick(tickLower);
  //   const sqrtPriceX64B = SqrtPriceMath.getSqrtPriceX64FromTick(tickUpper);
  //
  //   const coefficientRe = add ? 1 + slippage : 1 - slippage;
  //
  //   const amounts = LiquidityMath.getAmountsFromLiquidity(
  //     sqrtPriceX64,
  //     sqrtPriceX64A,
  //     sqrtPriceX64B,
  //     liquidity,
  //     add,
  //   );
  //
  //   const [amountA, amountB] = [
  //     getTransferAmountFeeV2(
  //       amounts.amountA,
  //       poolInfo.mintA.extensions?.feeConfig,
  //       epochInfo,
  //       amountAddFee,
  //     ),
  //     getTransferAmountFeeV2(
  //       amounts.amountB,
  //       poolInfo.mintB.extensions?.feeConfig,
  //       epochInfo,
  //       amountAddFee,
  //     ),
  //   ];
  //   const [amountSlippageA, amountSlippageB] = [
  //     getTransferAmountFeeV2(
  //       new BN(
  //         new Decimal(amounts.amountA.toString()).mul(coefficientRe).toFixed(0),
  //       ),
  //       poolInfo.mintA.extensions?.feeConfig,
  //       epochInfo,
  //       amountAddFee,
  //     ),
  //     getTransferAmountFeeV2(
  //       new BN(
  //         new Decimal(amounts.amountB.toString()).mul(coefficientRe).toFixed(0),
  //       ),
  //       poolInfo.mintB.extensions?.feeConfig,
  //       epochInfo,
  //       amountAddFee,
  //     ),
  //   ];
  //
  //   return {
  //     liquidity,
  //     amountA,
  //     amountB,
  //     amountSlippageA,
  //     amountSlippageB,
  //     expirationTime: minExpirationTime(
  //       amountA.expirationTime,
  //       amountB.expirationTime,
  //     ),
  //   };
  // }
};

// src/utils/pda.ts
import {
  getProgramDerivedAddress as getProgramDerivedAddress12,
  getAddressEncoder as getAddressEncoder29,
  getU16Encoder as getU16Encoder7,
  address,
  getI32Encoder as getI32Encoder14,
  Endian
} from "@solana/kit";
var addressEncoder = getAddressEncoder29();
var i32Encoder = getI32Encoder14({ endian: Endian.Big });
var PdaUtils = class {
  /**
   * Derive pool state PDA
   * @param ammConfig - AMM config address
   * @param tokenMintA - Token A mint address
   * @param tokenMintB - Token B mint address
   * @returns Pool state PDA
   */
  static async getPoolStatePda(ammConfig, tokenMintA, tokenMintB) {
    return await getProgramDerivedAddress12({
      programAddress: STABBLE_CLMM_PROGRAM_ID,
      seeds: [
        PDA_SEEDS.POOL_STATE,
        addressEncoder.encode(ammConfig),
        addressEncoder.encode(tokenMintA),
        addressEncoder.encode(tokenMintB)
      ]
    });
  }
  /**
   * Derive AMM config PDA
   * @param index - Config index
   * @returns AMM config PDA
   */
  static async getAmmConfigPda(index) {
    return await getProgramDerivedAddress12({
      programAddress: STABBLE_CLMM_PROGRAM_ID,
      seeds: [PDA_SEEDS.AMM_CONFIG, getU16Encoder7().encode(index)]
    });
  }
  /**
   * Derive position state PDA
   * @param nftMint - Position NFT mint address
   * @returns Position state PDA
   */
  static async getPositionStatePda(nftMint) {
    return await getProgramDerivedAddress12({
      programAddress: STABBLE_CLMM_PROGRAM_ID,
      seeds: [PDA_SEEDS.POSITION_STATE, addressEncoder.encode(nftMint)]
    });
  }
  /**
   * Derive tick array state PDA
   * @param poolState - Pool state address
   * @param startTickIndex - Starting tick index of the array
   * @returns Tick array state PDA
   */
  static async getTickArrayStatePda(poolState, startTickIndex) {
    return await getProgramDerivedAddress12({
      programAddress: STABBLE_CLMM_PROGRAM_ID,
      seeds: [
        PDA_SEEDS.TICK_ARRAY_STATE,
        addressEncoder.encode(poolState),
        i32Encoder.encode(startTickIndex)
      ]
    });
  }
  /**
   * Derive observation state PDA
   * @param poolState - Pool state address
   * @returns Observation state PDA
   */
  static async getObservationStatePda(poolState) {
    return await getProgramDerivedAddress12({
      programAddress: STABBLE_CLMM_PROGRAM_ID,
      seeds: [PDA_SEEDS.OBSERVATION_STATE, addressEncoder.encode(poolState)]
    });
  }
  static async getPoolVaultIdPda(poolAddress, vaultAddress) {
    return await getProgramDerivedAddress12({
      seeds: [
        PDA_SEEDS.POOL_VAULT,
        addressEncoder.encode(poolAddress),
        addressEncoder.encode(vaultAddress)
      ],
      programAddress: STABBLE_CLMM_PROGRAM_ID
    });
  }
  /**
   * Derive tick array bitmap extension PDA
   * @param poolState - Pool state address
   * @returns Tick array bitmap extension PDA
   */
  static async getTickArrayBitmapExtensionPda(poolState) {
    return await getProgramDerivedAddress12({
      programAddress: STABBLE_CLMM_PROGRAM_ID,
      seeds: [PDA_SEEDS.BITMAP_EXTENSION, addressEncoder.encode(poolState)]
    });
  }
  /**
   * Calculate start tick index for tick array containing a specific tick
   * @param tick - Target tick
   * @param tickSpacing - Tick spacing of the pool
   * @returns Start tick index for the tick array
   */
  static getTickArrayStartIndex(tick, tickSpacing) {
    const ticksPerArray = 60;
    const arraySize = ticksPerArray * tickSpacing;
    const arrayIndex = Math.floor(tick / arraySize);
    return arrayIndex * arraySize;
  }
  /**
   * Get all tick array PDAs needed for a price range
   * @param poolState - Pool state address
   * @param tickLower - Lower tick of range
   * @param tickUpper - Upper tick of range
   * @param tickSpacing - Tick spacing of the pool
   * @param tickCurrent - Current pool tick
   * @returns Array of tick array PDAs
   */
  static async getTickArrayPdasForRange(poolState, tickLower, tickUpper, tickSpacing, tickCurrent) {
    const startIndexLower = this.getTickArrayStartIndex(tickLower, tickSpacing);
    const startIndexUpper = this.getTickArrayStartIndex(tickUpper, tickSpacing);
    const startIndexCurrent = this.getTickArrayStartIndex(
      tickCurrent,
      tickSpacing
    );
    const indices = /* @__PURE__ */ new Set([
      startIndexLower,
      startIndexUpper,
      startIndexCurrent
    ]);
    return await Promise.all(
      Array.from(indices).map(
        (index) => this.getTickArrayStatePda(poolState, index)
      )
    );
  }
  /**
   * Derive protocol position state PDA
   * @param poolState - Pool state address
   * @param tickLowerIndex - Lower tick index
   * @param tickUpperIndex - Upper tick index
   * @returns Protocol position state PDA
   */
  static async getProtocolPositionStatePda(poolState, tickLowerIndex, tickUpperIndex) {
    return await getProgramDerivedAddress12({
      programAddress: STABBLE_CLMM_PROGRAM_ID,
      seeds: [
        PDA_SEEDS.POSITION_STATE,
        addressEncoder.encode(poolState),
        i32Encoder.encode(tickLowerIndex),
        i32Encoder.encode(tickUpperIndex)
      ]
    });
  }
  /**
   * Derive operation state PDA
   * @param poolState - Pool state address
   * @returns Operation state PDA
   */
  static async getOperationStatePda(poolState) {
    return await getProgramDerivedAddress12({
      programAddress: STABBLE_CLMM_PROGRAM_ID,
      seeds: [PDA_SEEDS.OPERATION, addressEncoder.encode(poolState)]
    });
  }
};
async function getMetadataPda(mint) {
  return await getProgramDerivedAddress12({
    seeds: [
      "metadata",
      addressEncoder.encode(address(METADATA_PROGRAM_ID)),
      addressEncoder.encode(mint)
    ],
    programAddress: address(METADATA_PROGRAM_ID)
  });
}

// src/types.ts
var ClmmError = class extends Error {
  constructor(code, message, details) {
    super(message);
    this.code = code;
    this.details = details;
    this.name = "ClmmError";
  }
};

// src/utils/tick.ts
import Decimal2 from "decimal.js";
import BN3 from "bn.js";

// src/utils/tickQuery.ts
var FETCH_TICKARRAY_COUNT = 15;
var TickQuery = class {
  static async getTickArrays(rpc, poolId, tickCurrent, tickSpacing, tickArrayBitmapArray, exTickArrayBitmap) {
    const tickArraysToFetch = [];
    const currentTickArrayStartIndex = TickUtils.getTickArrayStartIndexByTick(
      tickCurrent,
      tickSpacing
    );
    const startIndexArray = TickUtils.getInitializedTickArrayInRange(
      tickArrayBitmapArray,
      exTickArrayBitmap,
      tickSpacing,
      currentTickArrayStartIndex,
      Math.floor(FETCH_TICKARRAY_COUNT / 2)
    );
    for (let i = 0; i < startIndexArray.length; i++) {
      const [tickArrayAddress] = await PdaUtils.getTickArrayStatePda(
        poolId,
        startIndexArray[i]
      );
      tickArraysToFetch.push(tickArrayAddress);
    }
    const fetchedTickArrays = await fetchAllTickArrayState(
      rpc,
      tickArraysToFetch
    );
    const tickArrayCache = {};
    for (let i = 0; i < tickArraysToFetch.length; i++) {
      const _info = fetchedTickArrays[i];
      if (_info === null) continue;
      tickArrayCache[_info.data.startTickIndex] = {
        ..._info
      };
    }
    return tickArrayCache;
  }
  // NOTE: Broken
  //
  // public static nextInitializedTick(
  //   programId: PublicKey,
  //   poolId: PublicKey,
  //   tickArrayCache: { [key: string]: TickArray },
  //   tickIndex: number,
  //   tickSpacing: number,
  //   zeroForOne: boolean,
  // ): {
  //   nextTick: Tick;
  //   tickArrayAddress: PublicKey | undefined;
  //   tickArrayStartTickIndex: number;
  // } {
  //   let {
  //     initializedTick: nextTick,
  //     tickArrayAddress,
  //     tickArrayStartTickIndex,
  //   } = this.nextInitializedTickInOneArray(
  //     programId,
  //     poolId,
  //     tickArrayCache,
  //     tickIndex,
  //     tickSpacing,
  //     zeroForOne,
  //   );
  //   while (nextTick == undefined || nextTick.liquidityGross.lten(0)) {
  //     tickArrayStartTickIndex = TickUtils.getNextTickArrayStartIndex(
  //       tickArrayStartTickIndex,
  //       tickSpacing,
  //       zeroForOne,
  //     );
  //     if (this.checkIsValidStartIndex(tickArrayStartTickIndex, tickSpacing)) {
  //       throw new Error("No enough initialized tickArray");
  //     }
  //     const cachedTickArray = tickArrayCache[tickArrayStartTickIndex];
  //
  //     if (cachedTickArray === undefined) continue;
  //
  //     const {
  //       nextTick: _nextTick,
  //       tickArrayAddress: _tickArrayAddress,
  //       tickArrayStartTickIndex: _tickArrayStartTickIndex,
  //     } = this.firstInitializedTickInOneArray(
  //       programId,
  //       poolId,
  //       cachedTickArray,
  //       zeroForOne,
  //     );
  //     [nextTick, tickArrayAddress, tickArrayStartTickIndex] = [
  //       _nextTick,
  //       _tickArrayAddress,
  //       _tickArrayStartTickIndex,
  //     ];
  //   }
  //   if (nextTick == undefined) {
  //     throw new Error("No invaild tickArray cache");
  //   }
  //   return { nextTick, tickArrayAddress, tickArrayStartTickIndex };
  // }
  // NOTE: Broken
  //
  // public static nextInitializedTickArray(
  //   tickIndex: number,
  //   tickSpacing: number,
  //   zeroForOne: boolean,
  //   tickArrayBitmap: BN[],
  //   exBitmapInfo: ReturnType<typeof TickArrayBitmapExtensionLayout.decode>,
  // ): {
  //   isExist: boolean;
  //   nextStartIndex: number;
  // } {
  //   const currentOffset = Math.floor(
  //     tickIndex / TickQuery.tickCount(tickSpacing),
  //   );
  //   const result: number[] = zeroForOne
  //     ? TickUtils.searchLowBitFromStart(
  //         tickArrayBitmap,
  //         exBitmapInfo,
  //         currentOffset - 1,
  //         1,
  //         tickSpacing,
  //       )
  //     : TickUtils.searchHightBitFromStart(
  //         tickArrayBitmap,
  //         exBitmapInfo,
  //         currentOffset + 1,
  //         1,
  //         tickSpacing,
  //       );
  //
  //   return result.length > 0
  //     ? { isExist: true, nextStartIndex: result[0] }
  //     : { isExist: false, nextStartIndex: 0 };
  // }
  // NOTE: Broken
  //
  // public static firstInitializedTickInOneArray(
  //   programId: PublicKey,
  //   poolId: PublicKey,
  //   tickArray: TickArray,
  //   zeroForOne: boolean,
  // ): {
  //   nextTick: Tick | undefined;
  //   tickArrayAddress: PublicKey;
  //   tickArrayStartTickIndex: number;
  // } {
  //   let nextInitializedTick: Tick | undefined = undefined;
  //   if (zeroForOne) {
  //     let i = TICK_ARRAY_SIZE - 1;
  //     while (i >= 0) {
  //       const tickInArray = tickArray.ticks[i];
  //       if (tickInArray.liquidityGross.gtn(0)) {
  //         nextInitializedTick = tickInArray;
  //         break;
  //       }
  //       i = i - 1;
  //     }
  //   } else {
  //     let i = 0;
  //     while (i < TICK_ARRAY_SIZE) {
  //       const tickInArray = tickArray.ticks[i];
  //       if (tickInArray.liquidityGross.gtn(0)) {
  //         nextInitializedTick = tickInArray;
  //         break;
  //       }
  //       i = i + 1;
  //     }
  //   }
  //   const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(
  //     programId,
  //     poolId,
  //     tickArray.startTickIndex,
  //   );
  //   return {
  //     nextTick: nextInitializedTick,
  //     tickArrayAddress,
  //     tickArrayStartTickIndex: tickArray.startTickIndex,
  //   };
  // }
  // NOTE: Broken
  //
  // public static nextInitializedTickInOneArray(
  //   programId: PublicKey,
  //   poolId: PublicKey,
  //   tickArrayCache: { [key: string]: TickArray },
  //   tickIndex: number,
  //   tickSpacing: number,
  //   zeroForOne: boolean,
  // ): {
  //   initializedTick: Tick | undefined;
  //   tickArrayAddress: PublicKey | undefined;
  //   tickArrayStartTickIndex: number;
  // } {
  //   const startIndex = TickUtils.getTickArrayStartIndexByTick(
  //     tickIndex,
  //     tickSpacing,
  //   );
  //   let tickPositionInArray = Math.floor(
  //     (tickIndex - startIndex) / tickSpacing,
  //   );
  //   const cachedTickArray = tickArrayCache[startIndex];
  //   if (cachedTickArray == undefined) {
  //     return {
  //       initializedTick: undefined,
  //       tickArrayAddress: undefined,
  //       tickArrayStartTickIndex: startIndex,
  //     };
  //   }
  //   let nextInitializedTick: Tick | undefined = undefined;
  //   if (zeroForOne) {
  //     while (tickPositionInArray >= 0) {
  //       const tickInArray = cachedTickArray.ticks[tickPositionInArray];
  //       if (tickInArray.liquidityGross.gtn(0)) {
  //         nextInitializedTick = tickInArray;
  //         break;
  //       }
  //       tickPositionInArray = tickPositionInArray - 1;
  //     }
  //   } else {
  //     tickPositionInArray = tickPositionInArray + 1;
  //     while (tickPositionInArray < TICK_ARRAY_SIZE) {
  //       const tickInArray = cachedTickArray.ticks[tickPositionInArray];
  //       if (tickInArray.liquidityGross.gtn(0)) {
  //         nextInitializedTick = tickInArray;
  //         break;
  //       }
  //       tickPositionInArray = tickPositionInArray + 1;
  //     }
  //   }
  //   const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(
  //     programId,
  //     poolId,
  //     startIndex,
  //   );
  //   return {
  //     initializedTick: nextInitializedTick,
  //     tickArrayAddress,
  //     tickArrayStartTickIndex: cachedTickArray.startTickIndex,
  //   };
  // }
  static getArrayStartIndex(tickIndex, tickSpacing) {
    const ticksInArray = this.tickCount(tickSpacing);
    const start = Math.floor(tickIndex / ticksInArray);
    return start * ticksInArray;
  }
  static checkIsValidStartIndex(tickIndex, tickSpacing) {
    if (TickUtils.checkIsOutOfBoundary(tickIndex)) {
      if (tickIndex > MAX_TICK) {
        return false;
      }
      const minStartIndex = TickUtils.getTickArrayStartIndexByTick(
        MIN_TICK,
        tickSpacing
      );
      return tickIndex == minStartIndex;
    }
    return tickIndex % this.tickCount(tickSpacing) == 0;
  }
  static tickCount(tickSpacing) {
    return TICK_ARRAY_SIZE * tickSpacing;
  }
};

// src/utils/tick.ts
var TICK_ARRAY_SIZE = 60;
var TICK_ARRAY_BITMAP_SIZE = 512;
var TickUtils = class _TickUtils {
  /**
   * Validate that a tick is within valid range
   * @param tick - Tick to validate
   * @throws ClmmError if tick is out of range
   */
  static validateTick(tick) {
    if (tick < MIN_TICK) {
      throw new ClmmError(
        "TICK_MUST_BE_GTE_MINIMUM_TICK" /* TICK_MUST_BE_GTE_MINIMUM_TICK */,
        `Tick ${tick} must be >= ${MIN_TICK}`
      );
    }
    if (tick > MAX_TICK) {
      throw new ClmmError(
        "TICK_MUST_BE_LTE_MAXIMUM_TICK" /* TICK_MUST_BE_LTE_MAXIMUM_TICK */,
        `Tick ${tick} must be <= ${MAX_TICK}`
      );
    }
  }
  /**
   * Validate that tick range is valid
   * @param tickLower - Lower tick
   * @param tickUpper - Upper tick
   * @param tickSpacing - Tick spacing for the pool
   * @throws ClmmError if range is invalid
   */
  static validateTickRange(tickLower, tickUpper, tickSpacing) {
    this.validateTick(tickLower);
    this.validateTick(tickUpper);
    if (tickLower >= tickUpper) {
      throw new ClmmError(
        "LOWER_TICK_MUST_BE_BELOW_UPPER_TICK" /* LOWER_TICK_MUST_BE_BELOW_UPPER_TICK */,
        `Lower tick ${tickLower} must be below upper tick ${tickUpper}`
      );
    }
    if (tickLower % tickSpacing !== 0) {
      throw new ClmmError(
        "TICK_MUST_BE_DIVISIBLE_BY_TICK_SPACING" /* TICK_MUST_BE_DIVISIBLE_BY_TICK_SPACING */,
        `Lower tick ${tickLower} must be divisible by tick spacing ${tickSpacing}`
      );
    }
    if (tickUpper % tickSpacing !== 0) {
      throw new ClmmError(
        "TICK_MUST_BE_DIVISIBLE_BY_TICK_SPACING" /* TICK_MUST_BE_DIVISIBLE_BY_TICK_SPACING */,
        `Upper tick ${tickUpper} must be divisible by tick spacing ${tickSpacing}`
      );
    }
  }
  /**
   * Get the start index of the tick array containing a specific tick
   * @param tick - Target tick
   * @param tickSpacing - Tick spacing of the pool
   * @returns Start tick index for the tick array
   */
  static getTickArrayStartIndex(tick, tickSpacing) {
    const ticksPerArray = TICKS_PER_ARRAY;
    const arraySize = ticksPerArray * tickSpacing;
    let arrayIndex;
    if (tick >= 0) {
      arrayIndex = Math.floor(tick / arraySize);
    } else {
      arrayIndex = Math.floor((tick + 1) / arraySize) - 1;
    }
    return arrayIndex * arraySize;
  }
  /**
   * Check if a tick is initialized (has liquidity)
   * @param tick - Tick to check
   * @returns Whether tick is initialized
   */
  static isTickInitialized(tick) {
    return tick.liquidityGross > 0n;
  }
  /**
   * Get all tick array start indices needed for a price range
   * @param tickLower - Lower tick of range
   * @param tickUpper - Upper tick of range
   * @param tickSpacing - Tick spacing of the pool
   * @param tickCurrent - Current pool tick
   * @returns Array of start indices
   */
  static getTickArrayStartIndices(tickLower, tickUpper, tickSpacing, tickCurrent) {
    const startIndexLower = this.getTickArrayStartIndex(tickLower, tickSpacing);
    const startIndexUpper = this.getTickArrayStartIndex(tickUpper, tickSpacing);
    const startIndexCurrent = this.getTickArrayStartIndex(
      tickCurrent,
      tickSpacing
    );
    const indices = /* @__PURE__ */ new Set([
      startIndexLower,
      startIndexUpper,
      startIndexCurrent
    ]);
    return Array.from(indices).sort((a, b) => a - b);
  }
  /**
   * Find next initialized tick in a direction
   * @param ticks - Array of tick states
   * @param startTick - Starting tick index
   * @param tickSpacing - Tick spacing
   * @param zeroForOne - Direction (true = decreasing ticks)
   * @returns Next initialized tick and whether found
   */
  static findNextInitializedTick(ticks, startTick, tickSpacing, zeroForOne) {
    if (zeroForOne) {
      for (let i = ticks.length - 1; i >= 0; i--) {
        const tick = ticks[i];
        if (tick.tick < startTick && this.isTickInitialized(tick)) {
          return { tick: tick.tick, found: true };
        }
      }
    } else {
      for (let i = 0; i < ticks.length; i++) {
        const tick = ticks[i];
        if (tick.tick > startTick && this.isTickInitialized(tick)) {
          return { tick: tick.tick, found: true };
        }
      }
    }
    return { tick: 0, found: false };
  }
  /**
   * Calculate tick index from price
   * @param price - Price (token1/token0)
   * @param decimalsA - Token A decimals
   * @param decimalsB - Token B decimals
   * @returns Tick index
   */
  static priceToTick(price, decimalsA, decimalsB) {
    const adjustedPrice = price * Math.pow(10, decimalsA - decimalsB);
    const tickFloat = Math.log(adjustedPrice) / Math.log(1.0001);
    return Math.floor(tickFloat);
  }
  /**
   * Calculate price from tick index
   * @param tick - Tick index
   * @param decimalsA - Token A decimals
   * @param decimalsB - Token B decimals
   * @returns Price (token1/token0)
   */
  static tickToPrice(tick, decimalsA, decimalsB) {
    const price = Math.pow(1.0001, tick);
    return price * Math.pow(10, decimalsB - decimalsA);
  }
  /**
   * Get the tick index at a given price with proper spacing alignment
   * @param price - Target price
   * @param decimalsA - Token A decimals
   * @param decimalsB - Token B decimals
   * @param tickSpacing - Tick spacing
   * @param roundUp - Whether to round up or down
   * @returns Aligned tick index
   */
  static priceToAlignedTick(price, decimalsA, decimalsB, tickSpacing, roundUp = false) {
    const tick = this.priceToTick(price, decimalsA, decimalsB);
    return this.alignTickToSpacing(tick, tickSpacing, roundUp);
  }
  /**
   * Align tick to spacing requirements
   * @param tick - Raw tick
   * @param tickSpacing - Required spacing
   * @param roundUp - Whether to round up or down
   * @returns Aligned tick
   */
  static alignTickToSpacing(tick, tickSpacing, roundUp = false) {
    const aligned = roundUp ? Math.ceil(tick / tickSpacing) * tickSpacing : Math.floor(tick / tickSpacing) * tickSpacing;
    return Math.max(MIN_TICK, Math.min(MAX_TICK, aligned));
  }
  static checkIsOutOfBoundary(tick) {
    return tick < MIN_TICK || tick > MAX_TICK;
  }
  /**
   * Check if tick array boundary is valid
   * @param startIndex - Start index of tick array
   * @param tickSpacing - Tick spacing
   * @returns Whether boundary is valid
   */
  static isValidTickArrayBoundary(startIndex, tickSpacing) {
    const arraySize = TICKS_PER_ARRAY * tickSpacing;
    return startIndex % arraySize === 0;
  }
  static getTickArrayStartIndexByTick(tickIndex, tickSpacing) {
    return this.getTickArrayBitIndex(tickIndex, tickSpacing) * TickQuery.tickCount(tickSpacing);
  }
  static mergeTickArrayBitmap(bns) {
    let b = new BN3(0);
    for (let i = 0; i < bns.length; i++) {
      b = b.add(bns[i].shln(64 * i));
    }
    return b;
  }
  static searchLowBitFromStart(tickArrayBitmap, exTickArrayBitmap, currentTickArrayBitStartIndex, expectedCount, tickSpacing) {
    const tickArrayBitmaps = [
      ...[...exTickArrayBitmap.negativeTickArrayBitmap].reverse(),
      tickArrayBitmap.slice(0, 8),
      tickArrayBitmap.slice(8, 16),
      ...exTickArrayBitmap.positiveTickArrayBitmap
    ].map((bitmap) => {
      let bns = bitmap.map((b) => {
        if (typeof b == "bigint") return new BN3(b.toString());
        return b;
      });
      return _TickUtils.mergeTickArrayBitmap(bns);
    });
    const result = [];
    while (currentTickArrayBitStartIndex >= -7680) {
      const arrayIndex = Math.floor(
        (currentTickArrayBitStartIndex + 7680) / 512
      );
      const searchIndex = (currentTickArrayBitStartIndex + 7680) % 512;
      if (tickArrayBitmaps[arrayIndex].testn(searchIndex))
        result.push(currentTickArrayBitStartIndex);
      currentTickArrayBitStartIndex--;
      if (result.length === expectedCount) break;
    }
    const tickCount = TickQuery.tickCount(tickSpacing);
    return result.map((i) => i * tickCount);
  }
  static searchHightBitFromStart(tickArrayBitmap, exTickArrayBitmap, currentTickArrayBitStartIndex, expectedCount, tickSpacing) {
    const tickArrayBitmaps = [
      ...[...exTickArrayBitmap.negativeTickArrayBitmap].reverse(),
      tickArrayBitmap.slice(0, 8),
      tickArrayBitmap.slice(8, 16),
      ...exTickArrayBitmap.positiveTickArrayBitmap
    ].map((bitmap) => {
      let bns = bitmap.map((b) => {
        if (typeof b == "bigint") return new BN3(b.toString());
        return b;
      });
      return _TickUtils.mergeTickArrayBitmap(bns);
    });
    const result = [];
    while (currentTickArrayBitStartIndex < 7680) {
      const arrayIndex = Math.floor(
        (currentTickArrayBitStartIndex + 7680) / 512
      );
      const searchIndex = (currentTickArrayBitStartIndex + 7680) % 512;
      if (tickArrayBitmaps[arrayIndex].testn(searchIndex))
        result.push(currentTickArrayBitStartIndex);
      currentTickArrayBitStartIndex++;
      if (result.length === expectedCount) break;
    }
    const tickCount = TickQuery.tickCount(tickSpacing);
    return result.map((i) => i * tickCount);
  }
  static getInitializedTickArrayInRange(tickArrayBitmap, exTickArrayBitmap, tickSpacing, tickArrayStartIndex, expectedCount) {
    const tickArrayOffset = Math.floor(
      tickArrayStartIndex / (tickSpacing * TICK_ARRAY_SIZE)
    );
    return [
      // find right of currenct offset
      ..._TickUtils.searchLowBitFromStart(
        tickArrayBitmap,
        exTickArrayBitmap,
        tickArrayOffset - 1,
        expectedCount,
        tickSpacing
      ),
      // find left of current offset
      ..._TickUtils.searchHightBitFromStart(
        tickArrayBitmap,
        exTickArrayBitmap,
        tickArrayOffset,
        expectedCount,
        tickSpacing
      )
    ];
  }
  static getTickArrayBitIndex(tickIndex, tickSpacing) {
    const ticksInArray = TickQuery.tickCount(tickSpacing);
    let startIndex = tickIndex / ticksInArray;
    if (tickIndex < 0 && tickIndex % ticksInArray != 0) {
      startIndex = Math.ceil(startIndex) - 1;
    } else {
      startIndex = Math.floor(startIndex);
    }
    return startIndex;
  }
  static getTickPrice({
    mintADecimals,
    mintBDecimals,
    tick,
    baseIn
  }) {
    const tickSqrtPriceX64 = SqrtPriceMath.getSqrtPriceX64FromTick(tick);
    const tickPrice = SqrtPriceMath.sqrtPriceX64ToPrice(
      tickSqrtPriceX64,
      mintADecimals,
      mintBDecimals
    );
    return baseIn ? { tick, price: tickPrice, tickSqrtPriceX64 } : { tick, price: new Decimal2(1).div(tickPrice), tickSqrtPriceX64 };
  }
  static getPriceAndTick({
    tickSpacing,
    mintADecimals,
    mintBDecimals,
    price,
    baseIn
  }) {
    const _price = baseIn ? price : new Decimal2(1).div(price);
    const tick = TickMath.getTickWithPriceAndTickspacing(
      _price,
      tickSpacing,
      mintADecimals,
      mintBDecimals
    );
    const tickSqrtPriceX64 = SqrtPriceMath.getSqrtPriceX64FromTick(tick);
    const tickPrice = SqrtPriceMath.sqrtPriceX64ToPrice(
      tickSqrtPriceX64,
      mintADecimals,
      mintBDecimals
    );
    return baseIn ? { tick, price: tickPrice } : { tick, price: new Decimal2(1).div(tickPrice) };
  }
};
async function fetchTickArraysForRange(cluster, poolAddress, tickLower, tickUpper, tickSpacing, tickCurrent) {
  return [];
}

// src/utils/pool.ts
import BN4 from "bn.js";
var PoolUtils = class {
  /**
   * Calculate pool state from raw pool data
   * @param poolState - Raw pool state
   * @param ammConfig - AMM configuration
   * @returns Computed pool information
   */
  static computePoolInfo(poolState, _ammConfig) {
    const currentPrice = SqrtPriceMath.sqrtPriceX64ToPrice(
      new BN4(poolState.sqrtPriceX64.toString()),
      poolState.mintDecimals0,
      poolState.mintDecimals1
    );
    return {
      poolState,
      currentPrice: currentPrice.toNumber(),
      sqrtPriceX64: new BN4(poolState.sqrtPriceX64.toString()),
      tickCurrent: poolState.tickCurrent,
      liquidity: new BN4(poolState.liquidity.toString()),
      vaultABalance: ZERO,
      // Would need to fetch vault accounts
      vaultBBalance: ZERO,
      // Would need to fetch vault accounts
      feeGrowthGlobalA: new BN4(poolState.feeGrowthGlobal0X64.toString()),
      feeGrowthGlobalB: new BN4(poolState.feeGrowthGlobal1X64.toString())
    };
  }
  /**
   * Calculate swap output for exact input
   * @param poolInfo - Pool information
   * @param inputMint - Input token mint
   * @param amountIn - Input amount
   * @param slippageTolerance - Slippage tolerance (0-1)
   * @param tickArrays - Available tick arrays
   * @returns Swap computation result
   */
  static computeSwapExactInput(poolInfo, inputMint, amountIn, _slippageTolerance = 0.01, tickArrays = []) {
    if (amountIn.lte(ZERO)) {
      throw new ClmmError(
        "SWAP_AMOUNT_CANNOT_BE_ZERO" /* SWAP_AMOUNT_CANNOT_BE_ZERO */,
        "Swap amount cannot be zero"
      );
    }
    const zeroForOne = inputMint === poolInfo.poolState.tokenMint0;
    const sqrtPriceLimitX64 = zeroForOne ? MIN_SQRT_RATIO.add(ONE) : MAX_SQRT_RATIO.sub(ONE);
    return this.computeSwap(
      poolInfo,
      amountIn,
      sqrtPriceLimitX64,
      zeroForOne,
      true,
      // exactInput
      tickArrays
    );
  }
  /**
   * Calculate swap input for exact output
   * @param poolInfo - Pool information
   * @param outputMint - Output token mint
   * @param amountOut - Desired output amount
   * @param slippageTolerance - Slippage tolerance (0-1)
   * @param tickArrays - Available tick arrays
   * @returns Swap computation result
   */
  static computeSwapExactOutput(poolInfo, outputMint, amountOut, _slippageTolerance = 0.01, tickArrays = []) {
    if (amountOut.lte(ZERO)) {
      throw new ClmmError(
        "SWAP_AMOUNT_CANNOT_BE_ZERO" /* SWAP_AMOUNT_CANNOT_BE_ZERO */,
        "Swap amount cannot be zero"
      );
    }
    const zeroForOne = outputMint === poolInfo.poolState.tokenMint1;
    const sqrtPriceLimitX64 = zeroForOne ? MIN_SQRT_RATIO.add(ONE) : MAX_SQRT_RATIO.sub(ONE);
    return this.computeSwap(
      poolInfo,
      amountOut,
      sqrtPriceLimitX64,
      zeroForOne,
      false,
      // exactOutput
      tickArrays
    );
  }
  /**
   * Core swap computation
   * @param poolInfo - Pool information
   * @param amount - Swap amount
   * @param sqrtPriceLimitX64 - Price limit
   * @param zeroForOne - Swap direction
   * @param exactInput - Whether exact input or output
   * @param tickArrays - Available tick arrays
   * @returns Swap result
   */
  static computeSwap(poolInfo, amount, sqrtPriceLimitX64, zeroForOne, exactInput, _tickArrays) {
    if (zeroForOne) {
      if (sqrtPriceLimitX64.gte(poolInfo.sqrtPriceX64) || sqrtPriceLimitX64.lte(MIN_SQRT_RATIO)) {
        throw new ClmmError(
          "SQRT_PRICE_X64_OUT_OF_RANGE" /* SQRT_PRICE_X64_OUT_OF_RANGE */,
          "Invalid sqrt price limit for zeroForOne swap"
        );
      }
    } else {
      if (sqrtPriceLimitX64.lte(poolInfo.sqrtPriceX64) || sqrtPriceLimitX64.gte(MAX_SQRT_RATIO)) {
        throw new ClmmError(
          "SQRT_PRICE_X64_OUT_OF_RANGE" /* SQRT_PRICE_X64_OUT_OF_RANGE */,
          "Invalid sqrt price limit for oneForZero swap"
        );
      }
    }
    let sqrtPriceX64 = poolInfo.sqrtPriceX64;
    let liquidity = poolInfo.liquidity;
    let amountRemaining = amount;
    let amountCalculated = ZERO;
    let feeAmount = ZERO;
    const feeBps = 3e3;
    const stepResult = this.computeSwapStep(
      sqrtPriceX64,
      sqrtPriceLimitX64,
      liquidity,
      amountRemaining,
      feeBps,
      exactInput,
      zeroForOne
    );
    sqrtPriceX64 = stepResult.sqrtPriceNextX64;
    amountCalculated = amountCalculated.add(stepResult.amountOut);
    amountRemaining = amountRemaining.sub(stepResult.amountIn);
    feeAmount = feeAmount.add(stepResult.feeAmount);
    return {
      allTrade: amountRemaining.eq(ZERO),
      amountCalculated,
      sqrtPriceX64,
      liquidity,
      feeAmount,
      tickArrays: []
      // Would be populated with required tick arrays
    };
  }
  /**
   * Compute a single swap step
   * @param sqrtPriceCurrentX64 - Current sqrt price
   * @param sqrtPriceTargetX64 - Target sqrt price
   * @param liquidity - Current liquidity
   * @param amountRemaining - Remaining amount to swap
   * @param feeBps - Fee in basis points
   * @param exactInput - Whether exact input
   * @param zeroForOne - Swap direction
   * @returns Step result
   */
  static computeSwapStep(sqrtPriceCurrentX64, sqrtPriceTargetX64, liquidity, amountRemaining, feeBps, exactInput, zeroForOne) {
    const exactIn = exactInput;
    const sqrtPriceStartX64 = sqrtPriceCurrentX64;
    let sqrtPriceNextX64;
    let amountIn;
    let amountOut;
    if (exactIn) {
      const amountRemainingLessFee = MathUtils.mulDivFloor(
        amountRemaining,
        new BN4(1e6 - feeBps),
        new BN4(1e6)
      );
      sqrtPriceNextX64 = SqrtPriceMath.getNextSqrtPriceX64FromInput(
        sqrtPriceCurrentX64,
        liquidity,
        amountRemainingLessFee,
        zeroForOne
      );
    } else {
      sqrtPriceNextX64 = SqrtPriceMath.getNextSqrtPriceX64FromOutput(
        sqrtPriceCurrentX64,
        liquidity,
        amountRemaining,
        zeroForOne
      );
    }
    const max = sqrtPriceTargetX64.eq(sqrtPriceNextX64);
    if (zeroForOne) {
      sqrtPriceNextX64 = max && sqrtPriceNextX64.lt(sqrtPriceTargetX64) ? sqrtPriceTargetX64 : sqrtPriceNextX64;
    } else {
      sqrtPriceNextX64 = max && sqrtPriceNextX64.gt(sqrtPriceTargetX64) ? sqrtPriceTargetX64 : sqrtPriceNextX64;
    }
    if (zeroForOne) {
      amountIn = sqrtPriceNextX64.eq(sqrtPriceTargetX64) && exactIn ? amountRemaining : this.getAmount0Delta(
        sqrtPriceNextX64,
        sqrtPriceStartX64,
        liquidity,
        true
      );
      amountOut = this.getAmount1Delta(
        sqrtPriceNextX64,
        sqrtPriceStartX64,
        liquidity,
        false
      );
    } else {
      amountIn = sqrtPriceNextX64.eq(sqrtPriceTargetX64) && exactIn ? amountRemaining : this.getAmount1Delta(
        sqrtPriceStartX64,
        sqrtPriceNextX64,
        liquidity,
        true
      );
      amountOut = this.getAmount0Delta(
        sqrtPriceStartX64,
        sqrtPriceNextX64,
        liquidity,
        false
      );
    }
    if (!exactIn && amountOut.gt(amountRemaining)) {
      amountOut = amountRemaining;
    }
    const feeAmount = exactIn && !sqrtPriceNextX64.eq(sqrtPriceTargetX64) ? amountRemaining.sub(amountIn) : MathUtils.mulDivRoundingUp(
      amountIn,
      new BN4(feeBps),
      new BN4(1e6 - feeBps)
    );
    return {
      sqrtPriceNextX64,
      amountIn,
      amountOut,
      feeAmount
    };
  }
  /**
   * Calculate amount0 delta between two sqrt prices
   * @param sqrtRatioAX64 - First sqrt ratio
   * @param sqrtRatioBX64 - Second sqrt ratio
   * @param liquidity - Liquidity amount
   * @param roundUp - Whether to round up
   * @returns Amount0 delta
   */
  static getAmount0Delta(sqrtRatioAX64, sqrtRatioBX64, liquidity, roundUp) {
    if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
      [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
    }
    const numerator1 = liquidity.shln(64);
    const numerator2 = sqrtRatioBX64.sub(sqrtRatioAX64);
    if (roundUp) {
      return MathUtils.mulDivRoundingUp(
        MathUtils.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX64),
        ONE,
        sqrtRatioAX64
      );
    } else {
      return MathUtils.mulDivFloor(
        MathUtils.mulDivFloor(numerator1, numerator2, sqrtRatioBX64),
        ONE,
        sqrtRatioAX64
      );
    }
  }
  /**
   * Calculate amount1 delta between two sqrt prices
   * @param sqrtRatioAX64 - First sqrt ratio
   * @param sqrtRatioBX64 - Second sqrt ratio
   * @param liquidity - Liquidity amount
   * @param roundUp - Whether to round up
   * @returns Amount1 delta
   */
  static getAmount1Delta(sqrtRatioAX64, sqrtRatioBX64, liquidity, roundUp) {
    if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
      [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
    }
    if (roundUp) {
      return MathUtils.mulDivRoundingUp(
        liquidity,
        sqrtRatioBX64.sub(sqrtRatioAX64),
        Q64
      );
    } else {
      return MathUtils.mulDivFloor(
        liquidity,
        sqrtRatioBX64.sub(sqrtRatioAX64),
        Q64
      );
    }
  }
  /**
   * Calculate optimal liquidity amounts for a position
   * @param poolInfo - Pool information
   * @param tickLower - Lower tick
   * @param tickUpper - Upper tick
   * @param amount0Desired - Desired amount of token 0
   * @param amount1Desired - Desired amount of token 1
   * @returns Liquidity calculation result
   */
  static calculateLiquidity(poolInfo, tickLower, tickUpper, amount0Desired, amount1Desired) {
    const sqrtRatioA = new BN4(
      SqrtPriceMath.getTickFromSqrtPriceX64(new BN4(tickLower))
    );
    const sqrtRatioB = new BN4(
      SqrtPriceMath.getTickFromSqrtPriceX64(new BN4(tickUpper))
    );
    const sqrtRatioCurrent = poolInfo.sqrtPriceX64;
    let liquidity;
    let amount0;
    let amount1;
    if (poolInfo.tickCurrent < tickLower) {
      liquidity = this.getLiquidityFromAmount0(
        sqrtRatioA,
        sqrtRatioB,
        amount0Desired
      );
      amount0 = amount0Desired;
      amount1 = ZERO;
    } else if (poolInfo.tickCurrent >= tickUpper) {
      liquidity = this.getLiquidityFromAmount1(
        sqrtRatioA,
        sqrtRatioB,
        amount1Desired
      );
      amount0 = ZERO;
      amount1 = amount1Desired;
    } else {
      const liquidity0 = this.getLiquidityFromAmount0(
        sqrtRatioCurrent,
        sqrtRatioB,
        amount0Desired
      );
      const liquidity1 = this.getLiquidityFromAmount1(
        sqrtRatioA,
        sqrtRatioCurrent,
        amount1Desired
      );
      liquidity = liquidity0.lt(liquidity1) ? liquidity0 : liquidity1;
      amount0 = this.getAmount0FromLiquidity(
        sqrtRatioCurrent,
        sqrtRatioB,
        liquidity
      );
      amount1 = this.getAmount1FromLiquidity(
        sqrtRatioA,
        sqrtRatioCurrent,
        liquidity
      );
    }
    return { liquidity, amount0, amount1 };
  }
  /**
   * Calculate liquidity from token0 amount
   * @param sqrtRatioAX64 - Lower sqrt ratio
   * @param sqrtRatioBX64 - Upper sqrt ratio
   * @param amount0 - Token0 amount
   * @returns Liquidity
   */
  static getLiquidityFromAmount0(sqrtRatioAX64, sqrtRatioBX64, amount0) {
    if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
      [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
    }
    const intermediate = MathUtils.mulDivFloor(
      sqrtRatioAX64,
      sqrtRatioBX64,
      Q64
    );
    return MathUtils.mulDivFloor(
      amount0,
      intermediate,
      sqrtRatioBX64.sub(sqrtRatioAX64)
    );
  }
  /**
   * Calculate liquidity from token1 amount
   * @param sqrtRatioAX64 - Lower sqrt ratio
   * @param sqrtRatioBX64 - Upper sqrt ratio
   * @param amount1 - Token1 amount
   * @returns Liquidity
   */
  static getLiquidityFromAmount1(sqrtRatioAX64, sqrtRatioBX64, amount1) {
    if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
      [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
    }
    return MathUtils.mulDivFloor(
      amount1,
      Q64,
      sqrtRatioBX64.sub(sqrtRatioAX64)
    );
  }
  /**
   * Calculate token0 amount from liquidity
   * @param sqrtRatioAX64 - Lower sqrt ratio
   * @param sqrtRatioBX64 - Upper sqrt ratio
   * @param liquidity - Liquidity amount
   * @returns Token0 amount
   */
  static getAmount0FromLiquidity(sqrtRatioAX64, sqrtRatioBX64, liquidity) {
    if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
      [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
    }
    return MathUtils.mulDivFloor(
      MathUtils.mulDivFloor(liquidity, Q64, sqrtRatioAX64),
      sqrtRatioBX64.sub(sqrtRatioAX64),
      sqrtRatioBX64
    );
  }
  /**
   * Calculate token1 amount from liquidity
   * @param sqrtRatioAX64 - Lower sqrt ratio
   * @param sqrtRatioBX64 - Upper sqrt ratio
   * @param liquidity - Liquidity amount
   * @returns Token1 amount
   */
  static getAmount1FromLiquidity(sqrtRatioAX64, sqrtRatioBX64, liquidity) {
    if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
      [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
    }
    return MathUtils.mulDivFloor(
      liquidity,
      sqrtRatioBX64.sub(sqrtRatioAX64),
      Q64
    );
  }
};

// src/utils/index.ts
import {
  getAddressEncoder as getAddressEncoder30
} from "@solana/kit";
function validateAddress(address4, name = "address") {
  if (!address4 || address4.length === 0) {
    throw new ClmmError(
      "POOL_NOT_FOUND" /* POOL_NOT_FOUND */,
      `Invalid ${name}: address cannot be empty`
    );
  }
}
function validateAmount(amount, name = "amount") {
  if (amount <= 0n) {
    throw new ClmmError(
      "ZERO_MINT_AMOUNT" /* ZERO_MINT_AMOUNT */,
      `Invalid ${name}: must be greater than 0`
    );
  }
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function formatAmount(amount, decimals, precision = 6) {
  const divisor = BigInt(10 ** decimals);
  const quotient = amount / divisor;
  const remainder = amount % divisor;
  if (remainder === 0n) {
    return quotient.toString();
  }
  const remainderStr = remainder.toString().padStart(decimals, "0");
  const trimmedRemainder = remainderStr.replace(/0+$/, "").substring(0, precision);
  if (trimmedRemainder === "") {
    return quotient.toString();
  }
  return `${quotient}.${trimmedRemainder}`;
}
function approximatelyEqual(a, b, tolerance = 1n) {
  const diff = a > b ? a - b : b - a;
  return diff <= tolerance;
}
async function retry(fn, maxRetries = 3, initialDelay = 1e3) {
  let lastError;
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      if (attempt === maxRetries) {
        break;
      }
      const delay = initialDelay * Math.pow(2, attempt);
      await sleep(delay);
    }
  }
  throw new ClmmError(
    "TRANSACTION_FAILED" /* TRANSACTION_FAILED */,
    `Operation failed after ${maxRetries + 1} attempts: ${lastError?.message || "Unknown error"}`
  );
}
function basisPointsToPercentage(basisPoints) {
  return basisPoints / 1e4;
}
function percentageToBasisPoints(percentage) {
  return Math.round(percentage * 1e4);
}
function isValidSolanaAddress(address4) {
  try {
    const decoded = Buffer.from(address4, "base64");
    return decoded.length === 32;
  } catch {
    return false;
  }
}
function addresstoBytes(address4) {
  const encoder = getAddressEncoder30();
  return encoder.encode(address4);
}
function getFakeSigner(address4) {
  return {
    address: address4,
    signAndSendTransactions: async (transactions, _config) => {
      return transactions.map(
        () => new Uint8Array(64).fill(0)
      );
    }
  };
}
function getApisFromEndpoint(rpc) {
  if ("requestAirdrop" in rpc) {
    return API_ENDPONTS.devnet;
  }
  return API_ENDPONTS.mainnet;
}

// src/clmm.ts
var Clmm = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Create a new AMM configuration
   * @param params - Configuration parameters
   * @returns Instruction result
   */
  async createAmmConfig(params) {
    const {
      owner,
      index,
      tickSpacing,
      tradeFeeRate,
      protocolFeeRate,
      fundFeeRate
    } = params;
    const ammConfigPda = await PdaUtils.getAmmConfigPda(index);
    const instruction = await getCreateAmmConfigInstructionAsync({
      owner,
      ammConfig: ammConfigPda[0],
      index,
      tickSpacing,
      tradeFeeRate,
      protocolFeeRate,
      fundFeeRate
    });
    return {
      instruction,
      extInfo: {
        ammConfigAddress: ammConfigPda[0]
      },
      signers: [owner]
    };
  }
  /**
   * NOTE: Not Implemented
   *
   * Open a new liquidity position (V2)
   * @param params - Position parameters
   * @returns Instruction result
   */
  async openPositionV2(params) {
    return {};
  }
  /**
   * NOTE: Not Implemented
   *
   * Increase liquidity in an existing position
   * @param params - Increase liquidity parameters
   * @returns Instruction result
   */
  async increaseLiquidity(params) {
    return {};
  }
  /**
   * NOTE: Not Implemented
   *
   * Decrease liquidity from an existing position
   * @param params - Decrease liquidity parameters
   * @returns Instruction result
   */
  async decreaseLiquidity(_params) {
    return {};
  }
};

// src/pool-manager.ts
import {
  address as address3
} from "@solana/kit";
import { TOKEN_PROGRAM_ADDRESS } from "@solana-program/token";
import BN5 from "bn.js";
import Decimal3 from "decimal.js";
var PoolManager = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Make create pool instructions
   * @param params - Pool creation parameters
   * @returns Instruction result following Raydium pattern
   */
  async makeCreatePoolInstructions(params) {
    const {
      owner,
      tokenMintA,
      tokenMintB,
      ammConfigId,
      initialPrice,
      mintADecimals,
      mintBDecimals
    } = params;
    const addressA = address3(tokenMintA);
    const addressB = address3(tokenMintB);
    const isAFirst = new BN5(Buffer.from(addressB)).gt(
      new BN5(Buffer.from(addressA))
    );
    const [token0, token1, decimals0, decimals1, priceAdjusted] = isAFirst ? [
      tokenMintA,
      tokenMintB,
      mintADecimals,
      mintBDecimals,
      new Decimal3(1).div(initialPrice)
    ] : [tokenMintB, tokenMintA, mintBDecimals, mintADecimals, initialPrice];
    const initialPriceX64 = SqrtPriceMath.priceToSqrtPriceX64(
      priceAdjusted,
      decimals0,
      decimals1
    );
    const [poolPda] = await PdaUtils.getPoolStatePda(
      ammConfigId,
      token0,
      token1
    );
    const [observationPda] = await PdaUtils.getObservationStatePda(poolPda);
    const [tickArrayBitmapPda] = await PdaUtils.getTickArrayBitmapExtensionPda(poolPda);
    const [tokenVault0] = await PdaUtils.getPoolVaultIdPda(poolPda, token0);
    const [tokenVault1] = await PdaUtils.getPoolVaultIdPda(poolPda, token1);
    const instruction = await getCreatePoolInstructionAsync({
      poolCreator: owner,
      ammConfig: ammConfigId,
      poolState: poolPda,
      tokenMint0: token0,
      tokenMint1: token1,
      tokenVault0,
      tokenVault1,
      observationState: observationPda,
      tickArrayBitmap: tickArrayBitmapPda,
      tokenProgram0: TOKEN_PROGRAM_ADDRESS,
      tokenProgram1: TOKEN_PROGRAM_ADDRESS,
      sqrtPriceX64: BigInt(initialPriceX64.toString()),
      openTime: BigInt(0)
    });
    return {
      instructions: [instruction],
      signers: [],
      instructionTypes: ["CreatePool"],
      address: {
        poolId: poolPda,
        observationId: observationPda,
        tokenVault0,
        tokenVault1
      },
      lookupTableAddress: []
    };
  }
  /**
   * Make create AMM config instructions
   * @param params - Config creation parameters
   * @returns Instruction result following Raydium pattern
   */
  async makeCreateAmmConfigInstructions(params) {
    const {
      owner,
      index,
      tickSpacing,
      tradeFeeRate,
      protocolFeeRate,
      fundFeeRate
    } = params;
    const ammConfigPda = await PdaUtils.getAmmConfigPda(index);
    const instruction = getCreateAmmConfigInstruction({
      owner,
      ammConfig: ammConfigPda[0],
      systemProgram: SYSTEM_PROGRAM_ID,
      index,
      tickSpacing,
      tradeFeeRate,
      protocolFeeRate,
      fundFeeRate
    });
    return {
      instructions: [instruction],
      signers: [owner],
      instructionTypes: ["CreateAmmConfig"],
      address: {
        ammConfigId: ammConfigPda[0]
      },
      lookupTableAddress: []
    };
  }
  /**
   * Fetch pool information by address
   * @param poolAddress - Pool state address
   * @returns Pool information
   */
  async getPool(poolAddress) {
    try {
      const poolState = await fetchMaybePoolState(
        this.config.rpc,
        poolAddress,
        { commitment: this.config.commitment }
      );
      if (!poolState.exists) {
        return null;
      }
      return this.enrichPoolInfo(poolState.data);
    } catch (error) {
      throw new ClmmError(
        "POOL_NOT_FOUND" /* POOL_NOT_FOUND */,
        `Failed to fetch pool: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Find pool by token pair and config index
   * @param tokenA - First token mint
   * @param tokenB - Second token mint
   * @param ammConfigIndex - AMM config index (default: 0)
   * @returns Pool information if found
   */
  async getPoolByTokenPairAndConfig(tokenA, tokenB, ammConfigIndex = 0) {
    const ammConfigPda = await PdaUtils.getAmmConfigPda(ammConfigIndex);
    const poolPda = await PdaUtils.getPoolStatePda(
      ammConfigPda[0],
      tokenA,
      tokenB
    );
    return this.getPool(poolPda[0]);
  }
  async getAllPools(rpc) {
    try {
      let accounts = await rpc.getProgramAccounts(STABBLE_CLMM_PROGRAM_ID, {
        commitment: "finalized",
        encoding: "base64",
        filters: [
          {
            dataSize: BigInt(getPoolStateSize())
          }
        ]
      }).send();
      let poolsAddresses = accounts.map((a) => a.pubkey);
      return fetchAllPoolState(rpc, poolsAddresses);
    } catch (error) {
      throw new ClmmError(
        "TRANSACTION_FAILED" /* TRANSACTION_FAILED */,
        `Failed to fetch pools: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Calculate pool price from sqrt price
   * @param sqrtPriceX64 - Square root price in Q64.64 format
   * @param decimalsA - Token A decimals
   * @param decimalsB - Token B decimals
   * @returns Human-readable price
   */
  calculatePoolPrice(sqrtPriceX64, decimalsA, decimalsB) {
    return SqrtPriceMath.sqrtPriceX64ToPrice(
      sqrtPriceX64,
      decimalsA,
      decimalsB
    );
  }
  /**
   * Enrich pool state with calculated fields
   */
  enrichPoolInfo(poolState) {
    const tokenA = {
      mint: poolState.tokenMint0,
      symbol: "TOKEN_A",
      // Would fetch from metadata
      decimals: poolState.mintDecimals0
    };
    const tokenB = {
      mint: poolState.tokenMint1,
      symbol: "TOKEN_B",
      // Would fetch from metadata
      decimals: poolState.mintDecimals1
    };
    const currentPrice = this.calculatePoolPrice(
      poolState.sqrtPriceX64,
      tokenA.decimals,
      tokenB.decimals
    );
    return {
      ...poolState,
      currentPrice,
      tokenA,
      tokenB,
      // These would be calculated from additional data sources
      tvl: void 0,
      volume24h: void 0,
      apy: void 0
    };
  }
  /**
   * Validate fee tier
   * @param fee - Fee tier to validate
   * @returns True if valid
   */
  isValidFeeTier(fee) {
    return Object.values(FEE_TIERS).includes(fee);
  }
  /**
   * Get tick spacing for fee tier
   * @param fee - Fee tier
   * @returns Tick spacing
   */
  getTickSpacing(fee) {
    const spacing = TICK_SPACINGS[fee];
    if (!spacing) {
      throw new ClmmError(
        "INVALID_TICK_RANGE" /* INVALID_TICK_RANGE */,
        `Invalid fee tier: ${fee}`
      );
    }
    return spacing;
  }
};

// src/position-manager.ts
import { generateKeyPairSigner } from "@solana/kit";
import { findAssociatedTokenPda } from "@solana-program/token";
import { TOKEN_2022_PROGRAM_ADDRESS } from "@solana-program/token-2022";
import BN6 from "bn.js";
var PositionManager = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Make open position from liquidity instructions
   * Use this when you know the exact liquidity amount you want to provide
   * @param params - Position opening parameters
   * @returns Instruction result following Raydium pattern
   */
  async makeOpenPositionFromLiquidityInstructions(params) {
    const {
      poolAccount,
      ownerInfo,
      tickLower,
      tickUpper,
      liquidity,
      amountMaxA,
      amountMaxB,
      withMetadata = true,
      getEphemeralSigners
    } = params;
    const signers = [];
    let nftMintAccount;
    if (getEphemeralSigners) {
      nftMintAccount = getEphemeralSigners()[0];
    } else {
      let k = await generateKeyPairSigner();
      signers.push(k);
      nftMintAccount = k;
    }
    const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndex(
      tickLower,
      poolAccount.data.tickSpacing
    );
    const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndex(
      tickUpper,
      poolAccount.data.tickSpacing
    );
    const [positionStatePda] = await PdaUtils.getPositionStatePda(
      nftMintAccount.address
    );
    const [metadataPda] = await getMetadataPda(nftMintAccount.address);
    const [positionNftAccountPda] = await findAssociatedTokenPda({
      mint: nftMintAccount.address,
      owner: ownerInfo.wallet,
      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
    });
    const [protocolPositionPda] = await PdaUtils.getProtocolPositionStatePda(
      poolAccount.address,
      tickLower,
      tickUpper
    );
    const instruction = await getOpenPositionWithToken22NftInstructionAsync({
      payer: ownerInfo.feePayer,
      positionNftOwner: ownerInfo.wallet,
      positionNftMint: nftMintAccount,
      positionNftAccount: positionNftAccountPda,
      poolState: poolAccount.address,
      protocolPosition: protocolPositionPda,
      tokenAccount0: ownerInfo.tokenAccountA,
      tokenAccount1: ownerInfo.tokenAccountB,
      tokenVault0: poolAccount.data.tokenVault0,
      tokenVault1: poolAccount.data.tokenVault1,
      vault0Mint: poolAccount.data.tokenMint0,
      vault1Mint: poolAccount.data.tokenMint0,
      tickLowerIndex: tickLower,
      tickUpperIndex: tickUpper,
      tickArrayLowerStartIndex,
      tickArrayUpperStartIndex,
      liquidity,
      amount0Max: amountMaxA,
      amount1Max: amountMaxB,
      withMetadata,
      baseFlag: null
    });
    return {
      instructions: [instruction],
      signers,
      instructionTypes: ["OpenPositionV2"],
      address: {
        positionNftMint: nftMintAccount.address,
        positionNftAccount: positionNftAccountPda,
        metadataAccount: metadataPda,
        personalPosition: positionStatePda
      },
      lookupTableAddress: []
    };
  }
  /**
   * Make open position from base token amount instructions
   * Use this when you know how much of one specific token you want to deposit
   * @param params - Position opening parameters
   * @returns Instruction result following Raydium pattern
   */
  async makeOpenPositionFromBaseInstructions(params) {
    const {
      poolAccount,
      ownerInfo,
      tickLower,
      tickUpper,
      base,
      baseAmount,
      otherAmountMax,
      withMetadata = true,
      getEphemeralSigners
    } = params;
    const signers = [];
    let nftMintAccount;
    if (getEphemeralSigners) {
      nftMintAccount = getEphemeralSigners()[0];
    } else {
      let k = await generateKeyPairSigner();
      signers.push(k);
      nftMintAccount = k;
    }
    const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndexByTick(
      tickLower,
      poolAccount.data.tickSpacing
    );
    const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndexByTick(
      tickUpper,
      poolAccount.data.tickSpacing
    );
    const [tickArrayLower] = await PdaUtils.getTickArrayStatePda(
      poolAccount.address,
      tickArrayLowerStartIndex
    );
    const [tickArrayUpper] = await PdaUtils.getTickArrayStatePda(
      poolAccount.address,
      tickArrayUpperStartIndex
    );
    const [positionStatePda] = await PdaUtils.getPositionStatePda(
      nftMintAccount.address
    );
    const [metadataPda] = await getMetadataPda(nftMintAccount.address);
    const [positionNftAccountPda] = await findAssociatedTokenPda({
      mint: nftMintAccount.address,
      owner: ownerInfo.wallet.address,
      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
    });
    const [protocolPositionPda] = await PdaUtils.getProtocolPositionStatePda(
      poolAccount.address,
      tickLower,
      tickUpper
    );
    const amount0Max = base === "MintA" ? baseAmount : otherAmountMax;
    const amount1Max = base === "MintA" ? otherAmountMax : baseAmount;
    const instruction = await getOpenPositionWithToken22NftInstructionAsync({
      payer: ownerInfo.wallet,
      positionNftOwner: ownerInfo.wallet.address,
      positionNftMint: nftMintAccount,
      positionNftAccount: positionNftAccountPda,
      poolState: poolAccount.address,
      protocolPosition: protocolPositionPda,
      tokenAccount0: ownerInfo.tokenAccountA,
      tokenAccount1: ownerInfo.tokenAccountB,
      tokenVault0: poolAccount.data.tokenVault0,
      tokenVault1: poolAccount.data.tokenVault1,
      vault0Mint: poolAccount.data.tokenMint0,
      vault1Mint: poolAccount.data.tokenMint1,
      tickLowerIndex: tickLower,
      tickUpperIndex: tickUpper,
      tickArrayLowerStartIndex,
      tickArrayUpperStartIndex,
      tickArrayLower,
      tickArrayUpper,
      liquidity: BigInt(0),
      amount0Max,
      amount1Max,
      withMetadata,
      baseFlag: base === "MintA" ? true : false
      // true = MintA is base, false = MintB is base
    });
    return {
      instructions: [instruction],
      signers,
      instructionTypes: ["OpenPositionV2"],
      address: {
        positionNftMint: nftMintAccount.address,
        positionNftAccount: positionNftAccountPda,
        metadataAccount: metadataPda,
        personalPosition: positionStatePda
      },
      lookupTableAddress: []
    };
  }
  /**
   * Make increase liquidity V2 instructions
   * @param params - Increase liquidity parameters
   * @returns Instruction result following Raydium pattern
   */
  async makeIncreaseLiquidityV2Instructions(params) {
    const {
      ownerPosition,
      poolState,
      ownerInfo,
      liquidity,
      amountMaxA,
      amountMaxB
    } = params;
    const [personalPosition] = await PdaUtils.getPositionStatePda(
      ownerPosition.nftMint
    );
    const [positionNftAccount] = await findAssociatedTokenPda({
      mint: ownerPosition.nftMint,
      owner: ownerInfo.wallet.address,
      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
    });
    const [protocolPositionPda] = await PdaUtils.getProtocolPositionStatePda(
      poolState.address,
      ownerPosition.tickLowerIndex,
      ownerPosition.tickUpperIndex
    );
    const [tickArrayLower] = await PdaUtils.getTickArrayStatePda(
      poolState.address,
      PdaUtils.getTickArrayStartIndex(
        ownerPosition.tickLowerIndex,
        poolState.data.tickSpacing
      )
    );
    const [tickArrayUpper] = await PdaUtils.getTickArrayStatePda(
      poolState.address,
      PdaUtils.getTickArrayStartIndex(
        ownerPosition.tickUpperIndex,
        poolState.data.tickSpacing
      )
    );
    const instruction = getIncreaseLiquidityV2Instruction({
      nftOwner: ownerInfo.wallet,
      nftAccount: positionNftAccount,
      personalPosition,
      poolState: poolState.address,
      protocolPosition: protocolPositionPda,
      tickArrayLower,
      tickArrayUpper,
      tokenAccount0: ownerInfo.tokenAccountA,
      tokenAccount1: ownerInfo.tokenAccountB,
      tokenVault0: poolState.data.tokenVault0,
      tokenVault1: poolState.data.tokenVault1,
      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,
      vault0Mint: poolState.data.tokenMint0,
      vault1Mint: poolState.data.tokenMint1,
      liquidity,
      amount0Max: amountMaxA,
      amount1Max: amountMaxB,
      baseFlag: null
    });
    return {
      instructions: [instruction],
      signers: [],
      instructionTypes: ["IncreaseLiquidityV2"],
      address: {
        tickArrayLower,
        tickArrayUpper,
        positionNftAccount,
        personalPosition,
        protocolPositionPda
      },
      lookupTableAddress: []
      // TODO:
    };
  }
  /**
   * Make decrease liquidity V2 instructions
   * @param params - Decrease liquidity parameters
   * @returns Instruction result following Raydium pattern
   */
  async makeDecreaseLiquidityV2Instructions(params) {
    const {
      ownerPosition,
      poolState,
      ownerInfo,
      liquidity,
      amountMinA,
      amountMinB
    } = params;
    const [personalPosition] = await PdaUtils.getPositionStatePda(
      ownerPosition.nftMint
    );
    const [positionNftAccount] = await findAssociatedTokenPda({
      mint: ownerPosition.nftMint,
      owner: ownerInfo.wallet.address,
      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
    });
    const [protocolPositionPda] = await PdaUtils.getProtocolPositionStatePda(
      poolState.address,
      ownerPosition.tickLowerIndex,
      ownerPosition.tickUpperIndex
    );
    const [tickArrayLower] = await PdaUtils.getTickArrayStatePda(
      poolState.address,
      PdaUtils.getTickArrayStartIndex(
        ownerPosition.tickLowerIndex,
        poolState.data.tickSpacing
      )
    );
    const [tickArrayUpper] = await PdaUtils.getTickArrayStatePda(
      poolState.address,
      PdaUtils.getTickArrayStartIndex(
        ownerPosition.tickUpperIndex,
        poolState.data.tickSpacing
      )
    );
    const instruction = getDecreaseLiquidityV2Instruction({
      nftOwner: ownerInfo.wallet,
      nftAccount: positionNftAccount,
      personalPosition,
      poolState: poolState.address,
      protocolPosition: protocolPositionPda,
      tokenVault0: poolState.data.tokenVault0,
      tokenVault1: poolState.data.tokenVault1,
      tickArrayLower,
      tickArrayUpper,
      recipientTokenAccount0: ownerInfo.tokenAccountA,
      recipientTokenAccount1: ownerInfo.tokenAccountB,
      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,
      vault0Mint: poolState.data.tokenMint0,
      vault1Mint: poolState.data.tokenMint1,
      liquidity,
      amount0Min: amountMinA,
      amount1Min: amountMinB
    });
    return {
      instructions: [instruction],
      signers: [],
      instructionTypes: ["DecreaseLiquidityV2"],
      address: {
        tickArrayLower,
        tickArrayUpper,
        positionNftAccount,
        personalPosition,
        protocolPositionPda
      },
      lookupTableAddress: []
    };
  }
  /**
   * Make close position instructions
   * @param params - Close position parameters
   * @returns Instruction result following established pattern
   */
  async makeClosePositionInstructions(params) {
    const { ownerPosition, ownerInfo } = params;
    const [personalPosition] = await PdaUtils.getPositionStatePda(
      ownerPosition.nftMint
    );
    const [positionNftAccount] = await findAssociatedTokenPda({
      mint: ownerPosition.nftMint,
      owner: ownerInfo.wallet.address,
      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
    });
    const instruction = getClosePositionInstruction({
      nftOwner: ownerInfo.wallet,
      positionNftMint: ownerPosition.nftMint,
      positionNftAccount,
      personalPosition,
      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
    });
    return {
      instructions: [instruction],
      signers: [],
      instructionTypes: ["ClosePosition"],
      address: { positionNftAccount, personalPosition },
      lookupTableAddress: []
    };
  }
  /**
   * Get position information by NFT mint
   * @param positionMint - Position NFT mint
   * @returns Position information
   */
  async getPosition(positionMint) {
    try {
      const positionStatePda = await PdaUtils.getPositionStatePda(positionMint);
      const positionState = await fetchMaybePersonalPositionState(
        this.config.rpc,
        positionStatePda[0],
        { commitment: this.config.commitment }
      );
      if (!positionState.exists) {
        return null;
      }
      return positionState.data;
    } catch (error) {
      throw new ClmmError(
        "POSITION_NOT_FOUND" /* POSITION_NOT_FOUND */,
        `Failed to fetch position: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Enrich position state with computed fields from pool data
   * @param position - Raw position state from blockchain
   * @param pool - Pool state from blockchain
   * @returns Enriched position info with calculated amounts and prices
   */
  enrichPositionInfo(position, pool) {
    const sqrtPriceLowerX64 = SqrtPriceMath.getSqrtPriceX64FromTick(
      position.tickLowerIndex
    );
    const sqrtPriceUpperX64 = SqrtPriceMath.getSqrtPriceX64FromTick(
      position.tickUpperIndex
    );
    const sqrtPriceCurrentX64 = new BN6(pool.sqrtPriceX64.toString());
    let amount0;
    let amount1;
    const liquidity = new BN6(position.liquidity.toString());
    if (pool.tickCurrent < position.tickLowerIndex) {
      amount0 = PoolUtils.getAmount0FromLiquidity(
        sqrtPriceLowerX64,
        sqrtPriceUpperX64,
        liquidity
      );
      amount1 = new BN6(0);
    } else if (pool.tickCurrent >= position.tickUpperIndex) {
      amount0 = new BN6(0);
      amount1 = PoolUtils.getAmount1FromLiquidity(
        sqrtPriceLowerX64,
        sqrtPriceUpperX64,
        liquidity
      );
    } else {
      amount0 = PoolUtils.getAmount0FromLiquidity(
        sqrtPriceCurrentX64,
        sqrtPriceUpperX64,
        liquidity
      );
      amount1 = PoolUtils.getAmount1FromLiquidity(
        sqrtPriceLowerX64,
        sqrtPriceCurrentX64,
        liquidity
      );
    }
    const priceLower = TickUtils.tickToPrice(
      position.tickLowerIndex,
      pool.mintDecimals0,
      pool.mintDecimals1
    );
    const priceUpper = TickUtils.tickToPrice(
      position.tickUpperIndex,
      pool.mintDecimals0,
      pool.mintDecimals1
    );
    const inRange = pool.tickCurrent >= position.tickLowerIndex && pool.tickCurrent < position.tickUpperIndex;
    const unclaimedFees = {
      token0: new BN6(position.tokenFeesOwed0.toString()),
      token1: new BN6(position.tokenFeesOwed1.toString())
    };
    const ageSeconds = 0;
    return {
      ...position,
      tokenMint0: pool.tokenMint0,
      tokenMint1: pool.tokenMint1,
      amount0: BigInt(amount0.toString()),
      amount1: BigInt(amount1.toString()),
      priceRange: {
        lower: priceLower,
        upper: priceUpper
      },
      inRange,
      ageSeconds,
      unclaimedFees,
      // valueUsd is optional and requires external price feeds
      valueUsd: void 0,
      // unclaimedRewards is optional
      unclaimedRewards: void 0
    };
  }
  /**
   * Get all positions for a wallet with enriched information
   * @param wallet - Wallet address
   * @returns Array of enriched positions owned by the wallet
   */
  async getPositionsForWallet(wallet) {
    try {
      const response = await this.config.rpc.getTokenAccountsByOwner(
        wallet,
        { programId: TOKEN_2022_PROGRAM_ADDRESS },
        { encoding: "jsonParsed" }
      ).send();
      const response22 = await this.config.rpc.getTokenAccountsByOwner(
        wallet,
        { programId: TOKEN_2022_PROGRAM_ADDRESS },
        { encoding: "jsonParsed" }
      ).send();
      const allAccounts = [...response.value, ...response22.value];
      const nftTokenAccounts = allAccounts.filter((account) => {
        const parsedInfo = account.account.data.parsed.info;
        return parsedInfo.tokenAmount.amount == "1" && parsedInfo.tokenAmount.decimals == 0;
      });
      const positions = await Promise.all(
        nftTokenAccounts.map(
          (ta) => this.getPosition(ta.account.data.parsed.info.mint)
        )
      );
      const validPositions = positions.filter(
        (p) => !!p
      );
      const enrichedPositions = await Promise.all(
        validPositions.map(async (position) => {
          try {
            const poolAccount = await fetchMaybePoolState(
              this.config.rpc,
              position.poolId,
              { commitment: this.config.commitment }
            );
            if (!poolAccount.exists) {
              console.warn(`Pool ${position.poolId} not found for position`);
              return null;
            }
            return this.enrichPositionInfo(position, poolAccount.data);
          } catch (error) {
            console.error(`Failed to enrich position: ${error}`);
            return null;
          }
        })
      );
      return enrichedPositions.filter((p) => !!p);
    } catch (error) {
      throw new ClmmError(
        "POSITION_NOT_FOUND" /* POSITION_NOT_FOUND */,
        `Failed to fetch positions for user: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
};

// src/api/config.ts
import axios from "axios";
var ClmmConfigApi = class {
  constructor(config) {
    this.config = config;
    this.client = axios.create({
      baseURL: this.config.baseUrl,
      timeout: this.config.timeout ?? 1e4,
      headers: {
        "Content-Type": "application/json"
      }
    });
  }
  client;
  /**
   * Fetch all configs
   * @returns CLMM config information or null if not found
   */
  async getClmmConfigs() {
    try {
      const response = await this.client.get("/clmm-configs");
      return response.data;
    } catch (error) {
      if (this.isNotFoundError(error)) return null;
      throw this.handleApiError(error);
    }
  }
  /**
   * Handle API errors and convert to Error
   * @param error - Error from axios
   * @returns Error with appropriate message
   */
  handleApiError(error) {
    if (axios.isAxiosError(error)) {
      const axiosError = error;
      if (axiosError.code === "ECONNABORTED") {
        return new Error("API request timeout");
      }
      if (axiosError.response) {
        const status = axiosError.response.status;
        const message = axiosError.response.data?.message || axiosError.message;
        if (status === 404) {
          return new Error(`CLMM config not found: ${message}`);
        }
        if (status >= 500) {
          return new Error(`API server error: ${message}`);
        }
        return new Error(`API request failed: ${message}`);
      }
      if (axiosError.request) {
        return new Error("No response from API server");
      }
    }
    return new Error(
      `Unknown API error: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
  /**
   * Check if error is a 404 Not Found
   * @param error - Error to check
   * @returns True if 404 error
   */
  isNotFoundError(error) {
    return axios.isAxiosError(error) && error.response?.status === 404;
  }
};

// src/api/pools.ts
import axios2 from "axios";
var PoolsApi = class {
  constructor(config) {
    this.config = config;
    this.client = axios2.create({
      baseURL: this.config.baseUrl,
      timeout: this.config.timeout ?? 1e4,
      headers: {
        "Content-Type": "application/json"
      }
    });
  }
  client;
  /**
   * Fetch a single pool by address
   * @param poolAddress - Pool state address
   * @returns Pool information or null if not found
   */
  async getPool(poolAddress) {
    try {
      const response = await this.client.get(
        `/pools/${poolAddress}`
      );
      return response.data.pool;
    } catch (error) {
      if (this.isNotFoundError(error)) return null;
      throw this.handleApiError(error);
    }
  }
  /**
   * Fetch all pools
   * @returns Array of pool information
   */
  async getAllPools() {
    try {
      const response = await this.client.get("/pools");
      return response.data;
    } catch (error) {
      throw this.handleApiError(error);
    }
  }
  /**
   * Fetch pools by token pair
   * @param tokenA - First token mint
   * @param tokenB - Second token mint
   * @returns Array of pool information matching the token pair
   */
  async getPoolsByTokenPair(tokenA, tokenB) {
    try {
      const response = await this.client.get("/pools", {
        params: {
          tokenA,
          tokenB
        }
      });
      return response.data;
    } catch (error) {
      if (this.isNotFoundError(error)) return [];
      throw this.handleApiError(error);
    }
  }
  /**
   * Handle API errors and convert to Error
   * @param error - Error from axios
   * @returns Error with appropriate message
   */
  handleApiError(error) {
    if (axios2.isAxiosError(error)) {
      const axiosError = error;
      if (axiosError.code === "ECONNABORTED") {
        return new Error("API request timeout");
      }
      if (axiosError.response) {
        const status = axiosError.response.status;
        const message = axiosError.response.data?.message || axiosError.message;
        if (status === 404) {
          return new Error(`Pool not found: ${message}`);
        }
        if (status >= 500) {
          return new Error(`API server error: ${message}`);
        }
        return new Error(`API request failed: ${message}`);
      }
      if (axiosError.request) {
        return new Error("No response from API server");
      }
    }
    return new Error(
      `Unknown API error: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
  /**
   * Check if error is a 404 Not Found
   * @param error - Error to check
   * @returns True if 404 error
   */
  isNotFoundError(error) {
    return axios2.isAxiosError(error) && error.response?.status === 404;
  }
};

// src/api/index.ts
var ClmmApi = class {
  constructor(config) {
    this.config = config;
    this.pools = new PoolsApi(this.config);
    this.clmmConfig = new ClmmConfigApi(this.config);
  }
  pools;
  clmmConfig;
};

// src/client.ts
var ClmmSdk = class _ClmmSdk {
  /** Core CLMM functionality (Raydium-style) */
  clmm;
  /** API functionality */
  api;
  /** Pool management functionality */
  pools;
  /** Position management functionality */
  positions;
  /** Swap functionality */
  // public readonly swap: SwapManager;
  /** Rewards and fee collection functionality */
  // public readonly rewards: RewardsManager;
  /** SDK configuration */
  config;
  constructor(config) {
    this.config = config;
    this.clmm = new Clmm(config);
    const baseUrl = getApisFromEndpoint(config.rpc);
    const apiConfig = config.apiConfig ? config.apiConfig : { baseUrl };
    this.api = new ClmmApi(apiConfig);
    this.pools = new PoolManager(config);
    this.positions = new PositionManager(config);
  }
  /**
   * Create a new instance with updated configuration
   * @param newConfig - Updated configuration
   * @returns New SDK instance
   */
  withConfig(newConfig) {
    return new _ClmmSdk({
      ...this.config,
      ...newConfig
    });
  }
  /**
   * Get the current program address
   * @returns Program address
   */
  getProgramAddress() {
    return this.config.programAddress || "6dMXqGZ3ga2dikrYS9ovDXgHGh5RUsb2RTUj6hrQXhk6";
  }
  /**
   * Get the current commitment level
   * @returns Commitment level
   */
  getCommitment() {
    return this.config.commitment || "confirmed";
  }
};
function createClmmSdk(config) {
  return new ClmmSdk(config);
}

// src/index.ts
var DEFAULT_SDK_CONFIG = {
  commitment: "confirmed",
  programAddress: "6dMXqGZ3ga2dikrYS9ovDXgHGh5RUsb2RTUj6hrQXhk6"
};
export {
  AMM_V3_PROGRAM_ADDRESS,
  API_ENDPONTS,
  BIT_PRECISION,
  Clmm,
  ClmmSdk,
  DEFAULT_CONFIG,
  DEFAULT_DEADLINE_SECONDS,
  DEFAULT_SDK_CONFIG,
  DEFAULT_SLIPPAGE_TOLERANCE,
  FEE_RATE_DENOMINATOR,
  FEE_TIERS,
  LOG_B_2_X32,
  LOG_B_P_ERR_MARGIN_LOWER_X64,
  LOG_B_P_ERR_MARGIN_UPPER_X64,
  LiquidityMath,
  MAX_SQRT_PRICE_X64,
  MAX_SQRT_RATIO,
  MAX_TICK,
  METADATA_PROGRAM_ID,
  MIN_SQRT_PRICE_X64,
  MIN_SQRT_RATIO,
  MIN_TICK,
  MathUtils,
  MaxU64,
  MaxUint128,
  NEGATIVE_ONE,
  ONE,
  PDA_SEEDS,
  PdaUtils,
  PoolManager,
  PoolUtils,
  PositionManager,
  Q128,
  Q64,
  STABBLE_CLMM_PROGRAM_ID,
  SYSTEM_PROGRAM_ID,
  SYSVAR_RENT_PROGRAM_ID,
  SqrtPriceMath,
  TICKS_PER_ARRAY,
  TICK_ARRAY_BITMAP_SIZE,
  TICK_ARRAY_SIZE,
  TICK_SPACINGS,
  TickMath,
  TickUtils,
  U64Resolution,
  ZERO,
  addresstoBytes,
  approximatelyEqual,
  basisPointsToPercentage,
  createClmmSdk,
  fetchAmmConfig,
  fetchMaybeAmmConfig,
  fetchMaybePersonalPositionState,
  fetchMaybePoolState,
  fetchPersonalPositionState,
  fetchPoolState,
  fetchTickArraysForRange,
  formatAmount,
  generated_exports as generated,
  getAmmV3ErrorMessage,
  getApisFromEndpoint,
  getClosePositionInstruction,
  getCreateAmmConfigInstruction,
  getCreatePoolInstruction,
  getDecreaseLiquidityInstruction,
  getFakeSigner,
  getIncreaseLiquidityInstruction,
  getMetadataPda,
  getOpenPositionInstruction,
  getOpenPositionV2Instruction,
  getSwapInstruction,
  getSwapV2Instruction,
  isAmmV3Error,
  isValidSolanaAddress,
  percentageToBasisPoints,
  retry,
  sleep,
  validateAddress,
  validateAmount
};
