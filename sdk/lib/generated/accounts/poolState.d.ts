/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
import { fetchEncodedAccount, fetchEncodedAccounts, type Account, type Address, type EncodedAccount, type FetchAccountConfig, type FetchAccountsConfig, type FixedSizeCodec, type FixedSizeDecoder, type FixedSizeEncoder, type MaybeAccount, type MaybeEncodedAccount, type ReadonlyUint8Array } from '@solana/kit';
import { type RewardInfo, type RewardInfoArgs } from '../types';
export declare const POOL_STATE_DISCRIMINATOR: Uint8Array<ArrayBuffer>;
export declare function getPoolStateDiscriminatorBytes(): ReadonlyUint8Array;
export type PoolState = {
    discriminator: ReadonlyUint8Array;
    /** Bump to identify PDA */
    bump: ReadonlyUint8Array;
    ammConfig: Address;
    owner: Address;
    /** Token pair of the pool, where token_mint_0 address < token_mint_1 address */
    tokenMint0: Address;
    tokenMint1: Address;
    /** Token pair vault */
    tokenVault0: Address;
    tokenVault1: Address;
    /** observation account key */
    observationKey: Address;
    /** mint0 and mint1 decimals */
    mintDecimals0: number;
    mintDecimals1: number;
    /** The minimum number of ticks between initialized ticks */
    tickSpacing: number;
    /** The currently in range liquidity available to the pool. */
    liquidity: bigint;
    /** The current price of the pool as a sqrt(token_1/token_0) Q64.64 value */
    sqrtPriceX64: bigint;
    /** The current tick of the pool, i.e. according to the last tick transition that was run. */
    tickCurrent: number;
    padding3: number;
    padding4: number;
    /**
     * The fee growth as a Q64.64 number, i.e. fees of token_0 and token_1 collected per
     * unit of liquidity for the entire life of the pool.
     */
    feeGrowthGlobal0X64: bigint;
    feeGrowthGlobal1X64: bigint;
    /** The amounts of token_0 and token_1 that are owed to the protocol. */
    protocolFeesToken0: bigint;
    protocolFeesToken1: bigint;
    /** The amounts in and out of swap token_0 and token_1 */
    swapInAmountToken0: bigint;
    swapOutAmountToken1: bigint;
    swapInAmountToken1: bigint;
    swapOutAmountToken0: bigint;
    /**
     * Bitwise representation of the state of the pool
     * bit0, 1: disable open position and increase liquidity, 0: normal
     * bit1, 1: disable decrease liquidity, 0: normal
     * bit2, 1: disable collect fee, 0: normal
     * bit3, 1: disable collect reward, 0: normal
     * bit4, 1: disable swap, 0: normal
     */
    status: number;
    /** Leave blank for future use */
    padding: ReadonlyUint8Array;
    rewardInfos: Array<RewardInfo>;
    /** Packed initialized tick array state */
    tickArrayBitmap: Array<bigint>;
    /** except protocol_fee and fund_fee */
    totalFeesToken0: bigint;
    /** except protocol_fee and fund_fee */
    totalFeesClaimedToken0: bigint;
    totalFeesToken1: bigint;
    totalFeesClaimedToken1: bigint;
    fundFeesToken0: bigint;
    fundFeesToken1: bigint;
    openTime: bigint;
    recentEpoch: bigint;
    padding1: Array<bigint>;
    padding2: Array<bigint>;
};
export type PoolStateArgs = {
    /** Bump to identify PDA */
    bump: ReadonlyUint8Array;
    ammConfig: Address;
    owner: Address;
    /** Token pair of the pool, where token_mint_0 address < token_mint_1 address */
    tokenMint0: Address;
    tokenMint1: Address;
    /** Token pair vault */
    tokenVault0: Address;
    tokenVault1: Address;
    /** observation account key */
    observationKey: Address;
    /** mint0 and mint1 decimals */
    mintDecimals0: number;
    mintDecimals1: number;
    /** The minimum number of ticks between initialized ticks */
    tickSpacing: number;
    /** The currently in range liquidity available to the pool. */
    liquidity: number | bigint;
    /** The current price of the pool as a sqrt(token_1/token_0) Q64.64 value */
    sqrtPriceX64: number | bigint;
    /** The current tick of the pool, i.e. according to the last tick transition that was run. */
    tickCurrent: number;
    padding3: number;
    padding4: number;
    /**
     * The fee growth as a Q64.64 number, i.e. fees of token_0 and token_1 collected per
     * unit of liquidity for the entire life of the pool.
     */
    feeGrowthGlobal0X64: number | bigint;
    feeGrowthGlobal1X64: number | bigint;
    /** The amounts of token_0 and token_1 that are owed to the protocol. */
    protocolFeesToken0: number | bigint;
    protocolFeesToken1: number | bigint;
    /** The amounts in and out of swap token_0 and token_1 */
    swapInAmountToken0: number | bigint;
    swapOutAmountToken1: number | bigint;
    swapInAmountToken1: number | bigint;
    swapOutAmountToken0: number | bigint;
    /**
     * Bitwise representation of the state of the pool
     * bit0, 1: disable open position and increase liquidity, 0: normal
     * bit1, 1: disable decrease liquidity, 0: normal
     * bit2, 1: disable collect fee, 0: normal
     * bit3, 1: disable collect reward, 0: normal
     * bit4, 1: disable swap, 0: normal
     */
    status: number;
    /** Leave blank for future use */
    padding: ReadonlyUint8Array;
    rewardInfos: Array<RewardInfoArgs>;
    /** Packed initialized tick array state */
    tickArrayBitmap: Array<number | bigint>;
    /** except protocol_fee and fund_fee */
    totalFeesToken0: number | bigint;
    /** except protocol_fee and fund_fee */
    totalFeesClaimedToken0: number | bigint;
    totalFeesToken1: number | bigint;
    totalFeesClaimedToken1: number | bigint;
    fundFeesToken0: number | bigint;
    fundFeesToken1: number | bigint;
    openTime: number | bigint;
    recentEpoch: number | bigint;
    padding1: Array<number | bigint>;
    padding2: Array<number | bigint>;
};
export declare function getPoolStateEncoder(): FixedSizeEncoder<PoolStateArgs>;
export declare function getPoolStateDecoder(): FixedSizeDecoder<PoolState>;
export declare function getPoolStateCodec(): FixedSizeCodec<PoolStateArgs, PoolState>;
export declare function decodePoolState<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<PoolState, TAddress>;
export declare function decodePoolState<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<PoolState, TAddress>;
export declare function fetchPoolState<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<Account<PoolState, TAddress>>;
export declare function fetchMaybePoolState<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<MaybeAccount<PoolState, TAddress>>;
export declare function fetchAllPoolState(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<Account<PoolState>[]>;
export declare function fetchAllMaybePoolState(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<MaybeAccount<PoolState>[]>;
export declare function getPoolStateSize(): number;
//# sourceMappingURL=poolState.d.ts.map