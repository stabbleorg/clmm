/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
import { fetchEncodedAccount, fetchEncodedAccounts, type Account, type Address, type EncodedAccount, type FetchAccountConfig, type FetchAccountsConfig, type FixedSizeCodec, type FixedSizeDecoder, type FixedSizeEncoder, type MaybeAccount, type MaybeEncodedAccount, type ReadonlyUint8Array } from '@solana/kit';
import { type PositionRewardInfo, type PositionRewardInfoArgs } from '../types';
export declare const PERSONAL_POSITION_STATE_DISCRIMINATOR: Uint8Array<ArrayBuffer>;
export declare function getPersonalPositionStateDiscriminatorBytes(): ReadonlyUint8Array;
export type PersonalPositionState = {
    discriminator: ReadonlyUint8Array;
    /** Bump to identify PDA */
    bump: ReadonlyUint8Array;
    /** Mint address of the tokenized position */
    nftMint: Address;
    /** The ID of the pool with which this token is connected */
    poolId: Address;
    /** The lower bound tick of the position */
    tickLowerIndex: number;
    /** The upper bound tick of the position */
    tickUpperIndex: number;
    /** The amount of liquidity owned by this position */
    liquidity: bigint;
    /** The token_0 fee growth of the aggregate position as of the last action on the individual position */
    feeGrowthInside0LastX64: bigint;
    /** The token_1 fee growth of the aggregate position as of the last action on the individual position */
    feeGrowthInside1LastX64: bigint;
    /** The fees owed to the position owner in token_0, as of the last computation */
    tokenFeesOwed0: bigint;
    /** The fees owed to the position owner in token_1, as of the last computation */
    tokenFeesOwed1: bigint;
    rewardInfos: Array<PositionRewardInfo>;
    recentEpoch: bigint;
    padding: Array<bigint>;
};
export type PersonalPositionStateArgs = {
    /** Bump to identify PDA */
    bump: ReadonlyUint8Array;
    /** Mint address of the tokenized position */
    nftMint: Address;
    /** The ID of the pool with which this token is connected */
    poolId: Address;
    /** The lower bound tick of the position */
    tickLowerIndex: number;
    /** The upper bound tick of the position */
    tickUpperIndex: number;
    /** The amount of liquidity owned by this position */
    liquidity: number | bigint;
    /** The token_0 fee growth of the aggregate position as of the last action on the individual position */
    feeGrowthInside0LastX64: number | bigint;
    /** The token_1 fee growth of the aggregate position as of the last action on the individual position */
    feeGrowthInside1LastX64: number | bigint;
    /** The fees owed to the position owner in token_0, as of the last computation */
    tokenFeesOwed0: number | bigint;
    /** The fees owed to the position owner in token_1, as of the last computation */
    tokenFeesOwed1: number | bigint;
    rewardInfos: Array<PositionRewardInfoArgs>;
    recentEpoch: number | bigint;
    padding: Array<number | bigint>;
};
export declare function getPersonalPositionStateEncoder(): FixedSizeEncoder<PersonalPositionStateArgs>;
export declare function getPersonalPositionStateDecoder(): FixedSizeDecoder<PersonalPositionState>;
export declare function getPersonalPositionStateCodec(): FixedSizeCodec<PersonalPositionStateArgs, PersonalPositionState>;
export declare function decodePersonalPositionState<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<PersonalPositionState, TAddress>;
export declare function decodePersonalPositionState<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<PersonalPositionState, TAddress>;
export declare function fetchPersonalPositionState<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<Account<PersonalPositionState, TAddress>>;
export declare function fetchMaybePersonalPositionState<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<MaybeAccount<PersonalPositionState, TAddress>>;
export declare function fetchAllPersonalPositionState(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<Account<PersonalPositionState>[]>;
export declare function fetchAllMaybePersonalPositionState(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<MaybeAccount<PersonalPositionState>[]>;
export declare function getPersonalPositionStateSize(): number;
//# sourceMappingURL=personalPositionState.d.ts.map